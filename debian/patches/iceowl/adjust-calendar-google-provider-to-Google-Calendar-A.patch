From: Christoph Goehre <chris@sigxcpu.org>
Date: Mon, 19 Jan 2015 21:12:12 -0500
Subject: adjust calendar-google-provider to Google Calendar API v2

https://developers.google.com/google-apps/calendar/v2/developers_guide_protocol
https://bugzilla.mozilla.org/show_bug.cgi?id=1079189
Closes: #770008
---
 .../chrome/calendar/providers/gdata/gdata.dtd      |    6 +
 .../calendar/providers/gdata/gdata.properties      |   13 +-
 calendar/providers/gdata/Makefile.in               |   16 +
 .../gdata/components/calGoogleCalendar.js          | 1522 ++++++++------------
 .../gdata/components/calGoogleCalendar.manifest    |    2 +
 .../gdata/components/calGoogleCalendarModule.js    |   49 -
 .../components/calGoogleCalendarModule.manifest    |   11 -
 .../providers/gdata/components/calGoogleRequest.js |  420 ------
 .../providers/gdata/components/calGoogleSession.js |  577 --------
 .../providers/gdata/components/calGoogleUtils.js   | 1312 -----------------
 calendar/providers/gdata/components/moz.build      |   10 -
 .../providers/gdata/content/browserRequest.css     |   59 +
 calendar/providers/gdata/content/browserRequest.js |  113 ++
 .../providers/gdata/content/browserRequest.xul     |   34 +
 .../providers/gdata/content/calendarCreation.xul   |   12 -
 .../providers/gdata/content/gdata-bindings.css     |   22 +
 .../gdata/content/gdata-calendar-creation.js       |  246 ++++
 .../gdata/content/gdata-calendar-creation.xul      |   52 +
 .../gdata/content/gdata-calendar-event-dialog.js   |  206 +++
 .../gdata/content/gdata-calendar-event-dialog.xul  |    9 +
 .../gdata/content/gdata-calendar-properties.js     |   33 +
 .../gdata/content/gdata-calendar-properties.xul    |    9 +
 .../gdata/content/gdata-event-dialog-reminder.js   |   72 +
 .../gdata/content/gdata-event-dialog-reminder.xul  |    1 +
 .../providers/gdata/content/gdata-list-tree.xml    |  233 +++
 .../providers/gdata/content/gdata-migration.js     |    6 +-
 calendar/providers/gdata/defaults/preferences.js   |    2 +
 calendar/providers/gdata/install.rdf               |   13 +-
 calendar/providers/gdata/jar.mn                    |   17 +-
 calendar/providers/gdata/makeversion.py            |   21 +-
 calendar/providers/gdata/modules/OAuth2.jsm        |  273 ++++
 calendar/providers/gdata/modules/gdataLogging.jsm  |  130 ++
 calendar/providers/gdata/modules/gdataRequest.jsm  |  513 +++++++
 calendar/providers/gdata/modules/gdataSession.jsm  |  498 +++++++
 calendar/providers/gdata/modules/gdataUtils.jsm    | 1350 +++++++++++++++++
 calendar/providers/gdata/modules/shim/Calendar.jsm |  188 +++
 calendar/providers/gdata/modules/shim/Http.jsm     |   79 +
 calendar/providers/gdata/modules/shim/Loader.jsm   |  206 +++
 .../providers/gdata/modules/shim/Preferences.jsm   |   13 +
 calendar/providers/gdata/modules/shim/Promise.jsm  |  156 ++
 calendar/providers/gdata/modules/shim/Task.jsm     |  139 ++
 calendar/providers/gdata/modules/shim/Timer.jsm    |   14 +
 calendar/providers/gdata/modules/timezoneMap.jsm   |  106 ++
 calendar/providers/gdata/moz.build                 |   28 +-
 .../providers/gdata/public/calIGoogleCalendar.idl  |   81 --
 .../providers/gdata/public/calIGoogleRequest.idl   |  123 --
 .../providers/gdata/public/calIGoogleSession.idl   |   84 --
 calendar/providers/gdata/public/moz.build          |   13 -
 calendar/test/unit/test_gdata_provider.js          | 1464 +++++++++++++++++++
 calendar/test/unit/xpcshell.ini                    |    1 +
 50 files changed, 6910 insertions(+), 3647 deletions(-)
 create mode 100644 calendar/providers/gdata/components/calGoogleCalendar.manifest
 delete mode 100644 calendar/providers/gdata/components/calGoogleCalendarModule.js
 delete mode 100644 calendar/providers/gdata/components/calGoogleCalendarModule.manifest
 delete mode 100644 calendar/providers/gdata/components/calGoogleRequest.js
 delete mode 100644 calendar/providers/gdata/components/calGoogleSession.js
 delete mode 100644 calendar/providers/gdata/components/calGoogleUtils.js
 delete mode 100644 calendar/providers/gdata/components/moz.build
 create mode 100644 calendar/providers/gdata/content/browserRequest.css
 create mode 100644 calendar/providers/gdata/content/browserRequest.js
 create mode 100644 calendar/providers/gdata/content/browserRequest.xul
 delete mode 100644 calendar/providers/gdata/content/calendarCreation.xul
 create mode 100644 calendar/providers/gdata/content/gdata-bindings.css
 create mode 100644 calendar/providers/gdata/content/gdata-calendar-creation.js
 create mode 100644 calendar/providers/gdata/content/gdata-calendar-creation.xul
 create mode 100644 calendar/providers/gdata/content/gdata-calendar-event-dialog.js
 create mode 100644 calendar/providers/gdata/content/gdata-calendar-properties.js
 create mode 100644 calendar/providers/gdata/content/gdata-calendar-properties.xul
 create mode 100644 calendar/providers/gdata/content/gdata-event-dialog-reminder.js
 create mode 100644 calendar/providers/gdata/content/gdata-list-tree.xml
 create mode 100644 calendar/providers/gdata/modules/OAuth2.jsm
 create mode 100644 calendar/providers/gdata/modules/gdataLogging.jsm
 create mode 100644 calendar/providers/gdata/modules/gdataRequest.jsm
 create mode 100644 calendar/providers/gdata/modules/gdataSession.jsm
 create mode 100644 calendar/providers/gdata/modules/gdataUtils.jsm
 create mode 100644 calendar/providers/gdata/modules/shim/Calendar.jsm
 create mode 100644 calendar/providers/gdata/modules/shim/Http.jsm
 create mode 100644 calendar/providers/gdata/modules/shim/Loader.jsm
 create mode 100644 calendar/providers/gdata/modules/shim/Preferences.jsm
 create mode 100644 calendar/providers/gdata/modules/shim/Promise.jsm
 create mode 100644 calendar/providers/gdata/modules/shim/Task.jsm
 create mode 100644 calendar/providers/gdata/modules/shim/Timer.jsm
 create mode 100644 calendar/providers/gdata/modules/timezoneMap.jsm
 delete mode 100644 calendar/providers/gdata/public/calIGoogleCalendar.idl
 delete mode 100644 calendar/providers/gdata/public/calIGoogleRequest.idl
 delete mode 100644 calendar/providers/gdata/public/calIGoogleSession.idl
 delete mode 100644 calendar/providers/gdata/public/moz.build
 create mode 100644 calendar/test/unit/test_gdata_provider.js

diff --git a/calendar/locales/en-US/chrome/calendar/providers/gdata/gdata.dtd b/calendar/locales/en-US/chrome/calendar/providers/gdata/gdata.dtd
index 3b6dd6a..15dd1b4 100644
--- a/calendar/locales/en-US/chrome/calendar/providers/gdata/gdata.dtd
+++ b/calendar/locales/en-US/chrome/calendar/providers/gdata/gdata.dtd
@@ -13,4 +13,10 @@
 <!ENTITY gdata.migration.upgrade.accesskey "U">
 <!ENTITY gdata.migration.showagain.label "Always check ">
 
+<!ENTITY gdata.reminder.default "Default Reminder">
 <!ENTITY gdata.reminder.action.sms.label "Send a Text Message">
+
+<!ENTITY gdata.wizard.session.description "Please pick an existing session or enter your email address to create a new session. You only need one session per account.">
+<!ENTITY gdata.wizard.calendars.description "Please select the calendars and task lists you would like to subscribe to.">
+
+<!ENTITY gdata.wizard.nextstep.description "Please advance to the next step to set up your calendars.">
diff --git a/calendar/locales/en-US/chrome/calendar/providers/gdata/gdata.properties b/calendar/locales/en-US/chrome/calendar/providers/gdata/gdata.properties
index 36819d5..6889050 100644
--- a/calendar/locales/en-US/chrome/calendar/providers/gdata/gdata.properties
+++ b/calendar/locales/en-US/chrome/calendar/providers/gdata/gdata.properties
@@ -16,5 +16,14 @@
 extensions.{a62ef8ec-5fdc-40c2-873c-223b8a6925cc}.description=Allows bidirectional access to Google Calendar
 extensions.{a62ef8ec-5fdc-40c2-873c-223b8a6925cc}.name=Provider for Google Calendar
 
-# Dialog strings
-loginDialogTitle=Google Calendar Login
+# Events with only free/busy access don't have a title. Use this instead:
+busyTitle=Busy (%1$S)
+
+quotaExceeded=The quota for %1$S has been exceeded, please try again later.
+providerOutdated=This version of the provider has expired, please update to the latest version.
+
+reminderOutOfRange=Google Calendar only allows reminders up to 4 weeks before the event starts.
+
+syncProgressEvent=Synchronizing %1$S event %2$S of %3$S
+syncProgressTask=Synchronizing %1$S task %2$S of %3$S
+syncStatus=Synchronizing Calendar %1$S
diff --git a/calendar/providers/gdata/Makefile.in b/calendar/providers/gdata/Makefile.in
index 75faf79..0cb2518 100644
--- a/calendar/providers/gdata/Makefile.in
+++ b/calendar/providers/gdata/Makefile.in
@@ -14,6 +14,10 @@ DIST_FILES = install.rdf
 XPI_PKGNAME = gdata-provider-$(GDATA_VERSION).$(AB_CD).$(MOZ_PKG_PLATFORM)
 XPI_VERSION = $(GDATA_VERSION)
 XPI_NO_UNIVERSAL = 1
+XPI_EM_ID = {a62ef8ec-5fdc-40c2-873c-223b8a6925cc}
+ifndef DISABLE_LIGHTNING_INSTALL
+XPI_INSTALL_EXTENSION = $(XPI_EM_ID)
+endif
 
 THUNDERBIRD_VERSION := $(shell cat $(topsrcdir)/mail/config/version.txt)
 SEAMONKEY_VERSION := $(shell cat $(topsrcdir)/suite/config/version.txt)
@@ -30,5 +34,17 @@ DEFINES += -DAB_CD=$(AB_CD) \
 
 PREF_JS_EXPORTS = $(srcdir)/defaults/preferences.js
 
+ifeq (cocoa,$(MOZ_WIDGET_TOOLKIT))
+# If the macbundle dist dir was already created, sync the gdata provider here to avoid
+# the need to make -C objdir/mail/app each time
+tools repackage::
+	[ -d $(DIST)/$(MOZ_MACBUNDLE_NAME) ] && rsync -a $(FINAL_TARGET)/ $(DIST)/$(MOZ_MACBUNDLE_NAME)/Contents/Resources/extensions/$(XPI_EM_ID) || true
+endif
+
+# stage the extension for use in packaged tests
+stage-package:
+	$(NSINSTALL) -D $(PKG_STAGE)/extensions/$(XPI_EM_ID)
+	(cd $(FINAL_TARGET) && tar $(TAR_CREATE_FLAGS) - *) | (cd $(PKG_STAGE)/extensions/$(XPI_EM_ID) && tar -xf -)
+
 include $(topsrcdir)/config/rules.mk
 include $(topsrcdir)/calendar/lightning/lightning-packager.mk
diff --git a/calendar/providers/gdata/components/calGoogleCalendar.js b/calendar/providers/gdata/components/calGoogleCalendar.js
index dc814ac..8021c23 100644
--- a/calendar/providers/gdata/components/calGoogleCalendar.js
+++ b/calendar/providers/gdata/components/calGoogleCalendar.js
@@ -2,13 +2,27 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-Components.utils.import("resource://calendar/modules/calProviderUtils.jsm");
-Components.utils.import("resource://calendar/modules/calXMLUtils.jsm");
-Components.utils.import("resource://calendar/modules/calUtils.jsm");
-Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
-Components.utils.import("resource://gre/modules/Preferences.jsm");
+Components.utils.import("resource://gdata-provider/modules/shim/Loader.jsm").shimIt(this);
+Components.utils.import("resource://gdata-provider/modules/shim/Calendar.jsm");
+
+CuImport("resource://gre/modules/Preferences.jsm", this);
+CuImport("resource://gre/modules/Promise.jsm", this);
+CuImport("resource://gre/modules/Services.jsm", this);
+CuImport("resource://gre/modules/Task.jsm", this);
+CuImport("resource://gre/modules/XPCOMUtils.jsm", this);
+
+CuImport("resource://calendar/modules/calProviderUtils.jsm", this);
+CuImport("resource://calendar/modules/calUtils.jsm", this);
+
+CuImport("resource://gdata-provider/modules/gdataLogging.jsm", this);
+CuImport("resource://gdata-provider/modules/gdataRequest.jsm", this);
+CuImport("resource://gdata-provider/modules/gdataSession.jsm", this);
+CuImport("resource://gdata-provider/modules/gdataUtils.jsm", this);
 
 const cICL = Components.interfaces.calIChangeLog;
+const cIOL = Components.interfaces.calIOperationListener;
+
+const MIN_REFRESH_INTERVAL = 30;
 
 /**
  * calGoogleCalendar
@@ -20,223 +34,242 @@ const cICL = Components.interfaces.calIChangeLog;
  */
 function calGoogleCalendar() {
     this.initProviderBase();
+    this.mThrottle = Object.create(null);
 }
+
 const calGoogleCalendarClassID = Components.ID("{d1a6e988-4b4d-45a5-ba46-43e501ea96e3}");
 const calGoogleCalendarInterfaces = [
     Components.interfaces.calICalendar,
-    Components.interfaces.calIGoogleCalendar,
     Components.interfaces.calISchedulingSupport,
     Components.interfaces.calIChangeLog
 ];
 calGoogleCalendar.prototype = {
     __proto__: cal.ProviderBase.prototype,
+
     classID: calGoogleCalendarClassID,
     QueryInterface: XPCOMUtils.generateQI(calGoogleCalendarInterfaces),
     classInfo: XPCOMUtils.generateCI({
-        classID: calGoogleCalendarClassID,
-        contractID: "@mozilla.org/calendar/calendar;1?type=gdata",
         classDescription: "Google Calendar Provider",
+        contractID: "@mozilla.org/calendar/calendar;1?type=gdata",
+        classID: calGoogleCalendarClassID,
         interfaces: calGoogleCalendarInterfaces
     }),
 
+    /* Used to reset the local cache between releases */
+    CACHE_DB_VERSION: 2,
+
     /* Member Variables */
-    mSession: null,
-    mFullUri: null,
     mCalendarName: null,
-
-    /*
-     * Google Calendar Provider attributes
-     */
-
-    /**
-     * readonly attribute googleCalendarName
-     * Google's Calendar name. This represents the <calendar name> in
-     * http[s]://www.google.com/calendar/feeds/<calendar name>/private/full
-     */
-    get googleCalendarName() {
-        return this.mCalendarName;
+    mThrottle: null,
+    mThrottleLimits: {
+      "calendarList": 3600 * 1000,
+      "events": 30 * 1000,
+      "tasks": 30 * 1000
     },
 
-    get isDefaultCalendar() {
-        return !/@group\.calendar\.google\.com$/.test(this.mCalendarName);
-    },
+    /* Public Members */
+    session: null,
 
     /**
-     * attribute session
-     * An calGoogleSession Object that handles the session requests.
+     * Make sure a session is available.
      */
-    get session() {
-        return this.mSession;
-    },
-    set session(v) {
-        return this.mSession = v;
+    ensureSession: function() {
+        if (!this.session) {
+            // Now actually set up the session
+            let sessionMgr = getGoogleSessionManager();
+            this.session = sessionMgr.getSessionByCalendar(this, true);
+
+            // Aside from setting up the session, bump the refresh interval to
+            // a higher value if its below the minimal refresh interval to
+            // avoid exceeding quota.
+            let interval = this.getProperty("refreshInterval");
+            if (interval < MIN_REFRESH_INTERVAL && interval != 0) {
+                cal.LOG("[calGoogleCalendar] Sorry, auto-refresh intervals under " + MIN_REFRESH_INTERVAL + " minutes would cause the quota to be reached too fast.");
+                this.setProperty("refreshInterval", 2 * MIN_REFRESH_INTERVAL);
+            }
+        }
     },
 
-    get title() {
-        throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
-    },
-    set title(v) {
-        throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
+    ensureWritable: function() {
+        // Check if calendar is readonly
+        if (this.readOnly) {
+            const cIE = Components.interfaces.calIErrors;
+            throw new Components.Exception("", cIE.CAL_IS_READONLY);
+        }
     },
 
-    get access() {
-        throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
-    },
-    set access(v) {
-        throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
-    },
+    get isDefaultCalendar() !this.mCalendarName.endsWith("@group.calendar.google.com"),
 
-    get selected() {
-        throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
-    },
-    set selected(v) {
-        throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
-    },
+    /*
+     * implement calICalendar
+     */
+    get type() "gdata",
+    get providerID() "{a62ef8ec-5fdc-40c2-873c-223b8a6925cc}",
+    get canRefresh() true,
 
-    get hidden() {
-        throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
-    },
-    set hidden(v) {
-        throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
-    },
+    get id() this.mID,
+    set id(val) {
+        let setter = this.__proto__.__proto__.__lookupSetter__("id");
+        val = setter.call(this, val);
 
-    get color() {
-        throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
-    },
-    set color(v) {
-        throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
+        if (this.id && this.uri) {
+            this.ensureSession();
+        }
+        return val;
     },
 
-    get timezone() {
-        throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
-    },
-    set timezone(v) {
-        throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
-    },
-    /**
-     * findSession
-     * Populates the Session Object based on the preferences or the result of a
-     * login prompt.
-     *
-     * @param aIgnoreExistingSession If set, find the session regardless of
-     *                               whether the session has been previously set
-     *                               or not
-     */
-    findSession: function cGC_findSession(aIgnoreExistingSession) {
-        if (this.mSession && !aIgnoreExistingSession) {
-            return true;
-        }
+    get uri() this.mUri,
+    set uri(aUri) {
+        const protocols = ["http", "https", "webcal", "webcals"];
+        this.mUri = aUri;
+        if (aUri && aUri.schemeIs("googleapi")) {
+            // new format:  googleapi://session-id/?calendar=calhash@group.calendar.google.com&tasks=taskhash
+            let [fullUser, path] = aUri.path.substr(2).split("/", 2);
+            let parameters = new Map(path.substr(1).split("&").filter(Boolean)
+                             .map(function(x) x.split("=", 2).map(decodeURIComponent)));
+
+            if (parameters.size == 0) {
+                this.mCalendarName = fullUser;
+                this.mTasklistName = this.isDefaultCalendar ? "@default" : null;
+            } else {
+                this.mCalendarName = parameters.get("calendar");
+                this.mTasklistName = parameters.get("tasks");
+            }
 
-        // We need to find out which Google account fits to this calendar.
-        let sessionMgr = getGoogleSessionManager();
-        let googleUser = getCalendarPref(this, "googleUser");
-        if (googleUser) {
-            this.mSession = sessionMgr.getSessionByUsername(googleUser, true);
-        } else {
-            // We have no user, therefore we need to ask the user. Show a
-            // user/password prompt and set the session based on those
-            // values.
-
-            let username = { value: null };
-            if (this.isDefaultCalendar) {
-                // Only pre-fill the username if this is the default calendar,
-                // otherwise users might think the cryptic hash is the username
-                // they have to use.
-                username.value = this.mCalendarName;
+            // Users that installed 1.0 had an issue where secondary calendars
+            // were migrated to their own session. This code fixes that and
+            // should be removed once 1.0.1 has been out for a while.
+            let googleUser = Preferences.get("calendar.google.calPrefs." + fullUser + ".googleUser");
+            if (googleUser && googleUser != fullUser) {
+                let newUri = "googleapi://" + googleUser + "/" + path;
+                cal.LOG("[calGoogleCalendar] Migrating url format from " + aUri.spec + " to " + newUri);
+                this.setProperty("uri", newUri);
+                this.mUri = Services.io.newURI(newUri, null, null);
             }
-            let password = { value: null };
-            let persist = { value: false };
-
-            if (getCalendarCredentials(this.mCalendarName,
-                                       username,
-                                       password,
-                                       persist)) {
-                this.mSession = sessionMgr.getSessionByUsername(username.value,
-                                                                true);
-
-                this.mSession.password = password.value;
-                this.mSession.persist = persist.value;
-                setCalendarPref(this,
-                                "googleUser",
-                                "CHAR",
-                                this.mSession.userName);
-            } else {
-                // The password dialog was canceled, disable the calendar.
-                this.setProperty("disabled", true);
-                return false;
+
+            // Unit tests will use a local uri, if the magic parameter is passed.
+            let port = parameters.get("testport");
+            if (port) {
+                cal.LOG("[calGoogleCalendar] Redirecting request to test port " + port);
+                API_BASE.EVENTS = "http://localhost:" + port + "/calendar/v3/";
+                API_BASE.TASKS = "http://localhost:" + port + "/tasks/v1/";
             }
-        }
-        return true;
-    },
+        } else if (aUri && protocols.some(function(scheme) { return aUri.schemeIs(scheme); })) {
+            // Parse google url, catch private cookies, public calendars,
+            // basic and full types, bogus ics file extensions, invalid hostnames
+            let re = new RegExp("/calendar/(feeds|ical)/" +
+                                "([^/]+)/(public|private|free-busy)-?([^/]+)?/" +
+                                "(full|basic)(.ics)?$");
+
+            let matches = aUri.path.match(re);
+            if (matches) {
+                this.mCalendarName = decodeURIComponent(matches[2]);
+
+                let googleUser = Preferences.get("calendar.google.calPrefs." + this.mCalendarName + ".googleUser");
+                let newUri = "googleapi://" + (googleUser || this.mCalendarName) + "/?calendar=" + matches[2];
+
+                // Use the default task list, but only if this is the primary account.
+                if (googleUser && googleUser == this.mCalendarName) {
+                    this.mTasklistName = "@default";
+                    newUri += "&tasks=%40default";
+                }
 
-    /**
-     * ensureSession
-     * Make sure a session is available. If not, throw an exception
-     */
-    ensureSession: function cGC_ensureSession() {
-        if (!this.mSession ||
-            !this.mSession.password ||
-            this.mSession.password == "") {
-            if (!this.findSession) {
-                throw new Components.Exception("Session was canceled",
-                                               Components.results.NS_ERROR_FAILURE);
+                cal.LOG("[calGoogleCalendar] Migrating url format from " + aUri.spec +
+                        " to " + newUri);
+                this.setProperty("uri", newUri);
+                this.mUri = Services.io.newURI(newUri, null, null);
             }
         }
-    },
-
-    /*
-     * implement calICalendar
-     */
-    get type() {
-        return "gdata";
-    },
 
-    get providerID() {
-        return "{a62ef8ec-5fdc-40c2-873c-223b8a6925cc}";
-    },
+        if (this.id && this.uri) {
+            this.ensureSession();
+        }
 
-    get uri() {
         return this.mUri;
     },
 
-    get fullUri() {
-        return this.mFullUri;
+    createEventsURI: function (/* ...extraParts */) {
+        let extraParts = Array.slice(arguments);
+        let eventsURI = null;
+        if (this.mCalendarName) {
+            let encodedName = encodeURIComponent(this.mCalendarName);
+            let parts = ["calendars", encodedName].concat(Array.filter(extraParts, Boolean));
+            eventsURI = API_BASE.EVENTS + parts.join("/");
+        }
+        return eventsURI;
     },
-    set uri(aUri) {
-        // Parse google url, catch private cookies, public calendars,
-        // basic and full types, bogus ics file extensions, invalid hostnames
-        let re = new RegExp("/calendar/(feeds|ical)/" +
-                            "([^/]+)/(public|private)-?([^/]+)?/" +
-                            "(full|basic)(.ics)?$");
 
-        let matches = aUri.path.match(re);
+    createUsersURI: function(/* ...extraParts */) {
+        let extraParts = Array.slice(arguments);
+        let parts = ["users", "me"].concat(extraParts).map(encodeURIComponent);
+        return API_BASE.EVENTS + parts.join("/");
+    },
 
-        if (!matches) {
-            throw new Components.Exception(aUri, Components.results.NS_ERROR_MALFORMED_URI);
+    createTasksURI: function(/* ...extraParts */) {
+        let extraParts = Array.slice(arguments);
+        let tasksURI = null;
+        if (this.mTasklistName) {
+            let encodedName = encodeURIComponent(this.mTasklistName);
+            let parts = ["lists", encodedName].concat(Array.filter(extraParts, Boolean));
+            tasksURI = API_BASE.TASKS + parts.join("/");
+        }
+        return tasksURI;
+    },
+
+    STALE_TIME: 7 * 86400,
+
+    getUpdatedMin: function getUpdatedMin(aWhich) {
+        let updatedMin = null;
+        let lastUpdated = this.getProperty("lastUpdated." + aWhich);
+        if (lastUpdated) {
+            updatedMin = cal.createDateTime(lastUpdated);
+            let lastWeek = cal.now();
+            lastWeek.second -= this.STALE_TIME;
+            if (updatedMin.compare(lastWeek) <= 0) {
+                cal.LOG("[calGoogleCalendar] Last updated time for " + aWhich +
+                        " is very old, doing full sync");
+                this.resetLog();
+                updatedMin = null;
+            }
         }
+        return updatedMin ? getCorrectedDate(updatedMin) : null;
+    },
 
-        // Set internal Calendar Name
-        this.mCalendarName = decodeURIComponent(matches[2]);
+    checkThrottle: function(type) {
+        let shouldRequest = true;
+        let now = new Date().getTime();
 
-        // Set normalized url. We need private visibility and full projection
-        this.mFullUri = aUri.clone();
-        this.mFullUri.path = "/calendar/feeds/" + matches[2] + "/private/full";
+        if (type in this.mThrottle) {
+            let then = this.mThrottle[type];
 
-        // Remember the uri as it was passed, in case the calendar manager
-        // relies on it.
-        this.mUri = aUri;
+            if (now - then < this.mThrottleLimits[type]) {
+                shouldRequest = false;
+            }
+        }
 
-        this.findSession(true);
-        return this.mUri;
+        if (shouldRequest) {
+            this.mThrottle[type] = now;
+        } else {
+            cal.LOG("[calGoogleCalendar] Skipping " + type + " request to reduce requests");
+        }
+
+        return shouldRequest;
     },
 
-    getProperty: function cGC_getProperty(aName) {
+    getProperty: function(aName) {
         switch (aName) {
+            case "googleCalendarName":
+                return this.mCalendarName;
+            case "isDefaultCalendar":
+                return this.isDefaultCalendar;
+
             // Capabilities
+            case "cache.enabled":
+            case "cache.always":
+                return true;
             case "capabilities.timezones.floating.supported":
             case "capabilities.attachments.supported":
             case "capabilities.priority.supported":
-            case "capabilities.tasks.supported":
             case "capabilities.alarms.oninvitations.supported":
                 return false;
             case "capabilities.privacy.values":
@@ -245,13 +278,22 @@ calGoogleCalendar.prototype = {
                 return 5;
             case "capabilities.alarms.actionValues":
                 return ["DISPLAY", "EMAIL", "SMS"];
-            case "organizerId":
-                return "mailto:" + this.googleCalendarName;
-            case "organizerCN":
-                if (this.mSession) {
-                    return this.session.fullName;
+            case "capabilities.tasks.supported":
+                return !!this.mTasklistName;
+            case "capabilities.events.supported":
+                return !!this.mCalendarName;
+            case "readOnly":
+                // If this calendar displays events, make it readonly if we are
+                // not the owner or have write access.
+                let accessRole = this.getProperty("settings.accessRole");
+                let isReader = (accessRole == "freeBusyReader" || accessRole == "reader");
+                if (this.mCalendarName && isReader) {
+                    return true;
                 }
+                // Otherwise fall through
                 break;
+            case "organizerId":
+                return "mailto:" + this.mCalendarName;
             case "itip.transport":
                 if (!this.isDefaultCalendar ||
                     !Preferences.get("calendar.google.enableEmailInvitations", false)) {
@@ -276,846 +318,446 @@ calGoogleCalendar.prototype = {
         return this.__proto__.__proto__.getProperty.apply(this, arguments);
     },
 
-    get canRefresh() {
-        return true;
+    setProperty: function(aName, aValue) {
+        switch (aName) {
+            case "refreshInterval":
+                if (aValue < MIN_REFRESH_INTERVAL && aValue != 0) {
+                    cal.LOG("[calGoogleCalendar] Sorry, auto-refresh intervals under " +
+                            MIN_REFRESH_INTERVAL + " minutes would cause the quota " +
+                            "to be reached too fast.");
+                    this.superCalendar.setProperty("refreshInterval", 2 * MIN_REFRESH_INTERVAL);
+                    return;
+                }
+                break;
+        }
+
+        return this.__proto__.__proto__.setProperty.apply(this, arguments);
     },
 
-    adoptItem: function cGC_adoptItem(aItem, aListener) {
-        cal.LOG("[calGoogleCalendar] Adding item " + aItem.title);
+    addItemOrUseCache: calendarShim.addItemOrUseCache,
+    adoptItemOrUseCache: calendarShim.adoptItemOrUseCache,
+    modifyItemOrUseCache: calendarShim.modifyItemOrUseCache,
+    deleteItemOrUseCache: calendarShim.deleteItemOrUseCache,
+    notifyPureOperationComplete: calendarShim.notifyPureOperationComplete,
 
-        try {
-            // Check if calendar is readonly
-            if (this.readOnly) {
-                throw new Components.Exception("",
-                                               Components.interfaces.calIErrors.CAL_IS_READONLY);
+    addItem: function(aItem, aListener) this.adoptItem(aItem.clone(), aListener),
+    adoptItem: function(aItem, aListener) {
+        function stackContains(part, max) {
+            if (max === undefined) max = 8;
+            let stack = Components.stack.caller;
+            while (stack && --max) {
+                if (stack.filename && stack.filename.endsWith(part)) {
+                    return true;
+                }
+                stack = stack.caller;
             }
+            return false;
+        }
 
-            // Make sure the item is an event
-            aItem = aItem.QueryInterface(Components.interfaces.calIEvent);
+        // Now this sucks...both invitations and the offline cache send over
+        // items with the id set, but we have no way to figure out which is
+        // happening just by inspecting the item. Adding offline items should
+        // not be an import, but invitations should.
+        let isImport = aItem.id && (aItem.id == "xpcshell-import" || stackContains("calItipUtils.jsm"));
+        let request = new calGoogleRequest();
 
-            // Check if we have a session. If not, then the user has canceled
-            // the login prompt.
-            this.ensureSession();
+        Task.spawn(function() {
+            let itemData = ItemToJSON(aItem, this.offlineStorage, isImport);
 
             // Add the calendar to the item, for later use.
             aItem.calendar = this.superCalendar;
 
-            let request = new calGoogleRequest(this);
-            let xmlEntry = ItemToXMLEntry(aItem, this,
-                                          this.session.userName,
-                                          this.session.fullName);
-
             request.type = request.ADD;
-            request.uri = this.fullUri.spec;
-            request.setUploadData("application/atom+xml; charset=UTF-8", cal.xml.serializeDOM(xmlEntry));
-            request.operationListener = aListener;
             request.calendar = this;
-            request.newItem = aItem;
-            request.responseListener = { onResult: this.addItem_response.bind(this) };
-            request.addQueryParameter("ctz", calendarDefaultTimezone().tzid);
-
-            this.session.asyncItemRequest(request);
-            return request;
-        } catch (e) {
-            cal.LOG("[calGoogleCalendar] adoptItem failed before request " + aItem.title + "\n:" + e);
-            if (e.result == Components.interfaces.calIErrors.CAL_IS_READONLY) {
-                // The calendar is readonly, make sure this is set and
-                // notify the user. This can come from above or from
-                // mSession.addItem which checks for the editURI
-                this.readOnly = true;
-            }
-
-            this.notifyOperationComplete(aListener,
-                                         e.result,
-                                         Components.interfaces.calIOperationListener.ADD,
-                                         null,
-                                         e.message);
-        }
-        return null;
-    },
-
-    addItem: function cGC_addItem(aItem, aListener) {
-        // Google assigns an ID to every event added. Any id set here or in
-        // adoptItem will be overridden.
-        return this.adoptItem(aItem.clone(), aListener);
-    },
-
-    modifyItem: function cGC_modifyItem(aNewItem, aOldItem, aListener) {
-        cal.LOG("[calGoogleCalendar] Modifying item " + aOldItem.title);
+            if (cal.isEvent(aItem)) {
+                if (isImport) {
+                    cal.LOG("[calGoogleCalendar] Adding invitation event " + aItem.title);
+                    request.uri = this.createEventsURI("events", "import");
+                } else {
+                    cal.LOG("[calGoogleCalendar] Adding regular event " + aItem.title);
+                    request.uri = this.createEventsURI("events");
+                }
 
-        try {
-            if (this.readOnly) {
-                throw new Components.Exception("",
-                                               Components.interfaces.calIErrors.CAL_IS_READONLY);
+                if (Preferences.get("calendar.google.sendEventNotifications", false)) {
+                    request.addQueryParameter("sendNotifications", "true");
+                }
+            } else if (cal.isToDo(aItem)) {
+                cal.LOG("[calGoogleCalendar] Adding task " + aItem.title);
+                request.uri = this.createTasksURI("tasks");
+                // Tasks sent with an id will cause a bad request
+                delete itemData.id;
             }
 
-            // Check if we have a session. If not, then the user has canceled
-            // the login prompt.
-            this.ensureSession();
-
-            // Check if enough fields have changed to warrant sending the event
-            // to google. This saves network traffic. Also check if the item isn't
-            // the same to work around a bug in the cache layer.
-            if (aOldItem != aNewItem && relevantFieldsMatch(aOldItem, aNewItem)) {
-                cal.LOG("[calGoogleCalendar] Not requesting item modification for " + aOldItem.id +
-                        "(" + aOldItem.title + "), relevant fields match");
-
-                this.notifyOperationComplete(aListener,
-                                             Components.results.NS_OK,
-                                             Components.interfaces.calIOperationListener.MODIFY,
-                                             aNewItem.id,
-                                             aNewItem);
-                this.mObservers.notify("onModifyItem", [aNewItem, aOldItem]);
-                return null;
+            if (!request.uri) {
+                throw Components.Exception("Item type not supported",
+                                           Components.results.NS_ERROR_NOT_IMPLEMENTED);
             }
 
-            // Set up the request
-            let request = new calGoogleRequest(this.session);
-
-            // We need to clone the new item, its possible that ItemToXMLEntry
-            // will modify the item. For example, if the item is organized by
-            // someone else, we cannot save alarms on it and they should
-            // therefore not be added in the returned item.
-            let newItem = aNewItem.clone();
-
-            let xmlEntry = ItemToXMLEntry(newItem, this,
-                                          this.session.userName,
-                                          this.session.fullName);
-
-            if (aOldItem.parentItem != aOldItem &&
-                !aOldItem.parentItem.recurrenceInfo.getExceptionFor(aOldItem.startDate)) {
-
-                // In this case we are modifying an occurence, not deleting it
-                request.type = request.ADD;
-                request.uri = this.fullUri.spec;
-            } else {
-                // We are  making a negative exception or modifying a parent item
-                request.type = request.MODIFY;
-                request.uri = getItemEditURI(aOldItem);
+            request.setUploadData("application/json; charset=UTF-8",
+                                  JSON.stringify(itemData));
+            let data = yield this.session.asyncItemRequest(request);
+
+            // All we need to do now is parse the item and complete the
+            // operation. The cache layer will take care of adding the item
+            // to the storage.
+            let defaultTimezone = cal.calendarDefaultTimezone();
+            let metaData = Object.create(null);
+            let item = JSONToItem(data, this, defaultTimezone,
+                                  this.defaultReminders || [],
+                                  null, metaData);
+
+            // Make sure to update the etag and id
+            saveItemMetadata(this.offlineStorage, item.hashId, metaData);
+
+            if (aItem.id && item.id != aItem.id) {
+                // Looks like the id changed, probably because its an offline
+                // item. This really sucks for us now, because the cache will
+                // reset the wrong item. As a hack, delete the item with its
+                // original id and complete the adoptItem call with the new
+                // item. This will add the new item to the calendar.
+                let pcal = promisifyCalendar(this.offlineStorage);
+                yield pcal.deleteItem(aItem);
             }
-
-            request.setUploadData("application/atom+xml; charset=UTF-8", cal.xml.serializeDOM(xmlEntry));
-            request.responseListener = { onResult: this.modifyItem_response.bind(this) };
-            request.operationListener = aListener;
-            request.newItem = newItem;
-            request.oldItem = aOldItem;
+            throw new Task.Result(item);
+        }.bind(this)).then(function(item) {
+            cal.LOG("[calGoogleCalendar] Adding " + item.title + " succeeded");
+            this.observers.notify("onAddItem", [item]);
+            this.notifyOperationComplete(aListener, Components.results.NS_OK,
+                                         cIOL.ADD, item.id, item);
+        }.bind(this), function(e) {
+            let code = e.result || Components.results.NS_ERROR_FAILURE;
+            cal.ERROR("[calGoogleCalendar] Adding Item " + aItem.title +
+                      " failed:" + code + ": " + e.message);
+            this.notifyPureOperationComplete(aListener, code, cIOL.ADD, aItem.id, e.message);
+        }.bind(this));
+        return request;
+    },
+
+    modifyItem: function(aNewItem, aOldItem, aListener) {
+        cal.LOG("[calGoogleCalendar] Modifying item " + aNewItem.title + " (" +
+                (aNewItem.recurrenceId ? aNewItem.recurrenceId.icalString :
+                "master item") + ")");
+
+        // Set up the request
+        let request = new calGoogleRequest();
+        Task.spawn(function() {
+            request.type = request.MODIFY;
             request.calendar = this;
-            request.addQueryParameter("ctz", calendarDefaultTimezone().tzid);
-
-            this.session.asyncItemRequest(request);
-            return request;
-        } catch (e) {
-            cal.LOG("[calGoogleCalendar] modifyItem failed before request " +
-                    aNewItem.title + "(" + aNewItem.id + "):\n" + e);
-
-            if (e.result == Components.interfaces.calIErrors.CAL_IS_READONLY) {
-                // The calendar is readonly, make sure this is set and
-                // notify the user. This can come from above or from
-                // mSession.modifyItem which checks for the editURI
-                this.readOnly = true;
+            if (cal.isEvent(aNewItem)) {
+                request.uri = this.createEventsURI("events", getGoogleId(aNewItem, this.offlineStorage));
+            } else if (cal.isToDo(aNewItem)) {
+                request.uri = this.createTasksURI("tasks", aNewItem.id);
             }
 
-            this.notifyOperationComplete(aListener,
-                                         e.result,
-                                         Components.interfaces.calIOperationListener.MODIFY,
-                                         null,
-                                         e.message);
-        }
-        return null;
-    },
+            if (!request.uri) {
+                throw Components.Exception("Item type not supported",
+                                           Components.results.NS_ERROR_NOT_IMPLEMENTED);
+            }
 
-    deleteItem: function cGC_deleteItem(aItem, aListener) {
-        cal.LOG("[calGoogleCalendar] Deleting item " + aItem.title + "(" + aItem.id + ")");
+            request.setUploadData("application/json; charset=UTF-8",
+                                  JSON.stringify(ItemToJSON(aNewItem, this.offlineStorage)));
 
-        try {
-            if (this.readOnly) {
-                throw new Components.Exception("",
-                                               Components.interfaces.calIErrors.CAL_IS_READONLY);
+            // Set up etag from storage so we don't overwrite any foreign changes
+            let refItem = aOldItem || aNewItem;
+            let meta = getItemMetadata(this.offlineStorage, refItem) ||
+                       getItemMetadata(this.offlineStorage, refItem.parentItem);
+            if (meta && meta.etag) {
+                request.addRequestHeader("If-Match", meta.etag);
+            } else {
+                cal.ERROR("[calGoogleCalendar] Missing ETag for " + refItem.hashId);
             }
 
-            // Check if we have a session. If not, then the user has canceled
-            // the login prompt.
-            this.ensureSession();
-
-            // We need the item in the response, since google dosen't return any
-            // item XML data on delete, and we need to call the observers.
-            let request = new calGoogleRequest(this);
+            let data;
+            try {
+                data = yield this.session.asyncItemRequest(request);
+            } catch (e if e.result == calGoogleRequest.CONFLICT_MODIFY ||
+                          e.result == calGoogleRequest.CONFLICT_DELETED) {
+                data = yield checkResolveConflict(request, this, aNewItem);
+            }
 
-            request.type = request.DELETE;
-            request.uri = getItemEditURI(aItem);
-            request.operationListener = aListener;
-            request.oldItem = aItem;
-            request.calendar = this;
-            request.responseListener = { onResult: this.deleteItem_response.bind(this) };
-
-            this.session.asyncItemRequest(request);
-            return request;
-        } catch (e) {
-            cal.LOG("[calGoogleCalendar] deleteItem failed before request for " +
-                    aItem.title + "(" + aItem.id + "):\n" + e);
-
-            if (e.result == Components.interfaces.calIErrors.CAL_IS_READONLY) {
-                // The calendar is readonly, make sure this is set and
-                // notify the user. This can come from above or from
-                // mSession.deleteItem which checks for the editURI
-                this.readOnly = true;
+            // All we need to do now is parse the item and complete the
+            // operation. The cache layer will take care of adding the item
+            // to the storage cache.
+            let defaultTimezone = cal.calendarDefaultTimezone();
+            let metaData = Object.create(null);
+            let item = JSONToItem(data, this, defaultTimezone,
+                                  this.defaultReminders || [],
+                                  aNewItem.clone(), metaData);
+
+            // Make sure to update the etag. Do so before switching to the
+            // parent item, as google saves its own etags for changed
+            // instances.
+            migrateItemMetadata(this.offlineStorage, aOldItem, item, metaData);
+
+            if (item.recurrenceId) {
+                // If we only modified an exception item, then we need to
+                // set the parent item and modify the exception.
+                let modifiedItem = aNewItem.parentItem.clone();
+                if (item.status == "CANCELLED") {
+                    // Canceled means the occurrence is an EXDATE.
+                    modifiedItem.recurrenceInfo.removeOccurrenceAt(item.recurrenceId);
+                } else {
+                    // Not canceled means the occurrence was modified.
+                    modifiedItem.recurrenceInfo.modifyException(item, true);
+                }
+                item = modifiedItem;
             }
 
-            this.notifyOperationComplete(aListener,
-                                         e.result,
-                                         Components.interfaces.calIOperationListener.DELETE,
-                                         null,
-                                         e.message);
-        }
-        return null;
+            throw new Task.Result(item);
+        }.bind(this)).then(function (item) {
+            cal.LOG("[calGoogleCalendar] Modifying " + aNewItem.title + " succeeded");
+            this.observers.notify("onModifyItem", [item, aOldItem]);
+            this.notifyOperationComplete(aListener, Components.results.NS_OK,
+                                         cIOL.MODIFY, item.id, item);
+
+        }.bind(this), function(e) {
+            let code = e.result || Components.results.NS_ERROR_FAILURE;
+            if (code != Components.interfaces.calIErrors.OPERATION_CANCELLED) {
+                cal.ERROR("[calGoogleCalendar] Modifying item " + aNewItem.title +
+                          " failed:" + code + ": " + e.message);
+            }
+            this.notifyPureOperationComplete(aListener, code, cIOL.MODIFY, aNewItem.id, e.message);
+        }.bind(this));
+        return request;
     },
 
-    getItem: function cGC_getItem(aId, aListener) {
-        // This function needs a test case using mechanisms in bug 365212
-        cal.LOG("[calGoogleCalendar] Getting item with id " + aId);
-        try {
-
-            // Check if we have a session. If not, then the user has canceled
-            // the login prompt.
-            this.ensureSession();
-
-            // Set up the request
-
-            let request = new calGoogleRequest(this);
+    deleteItem: function(aItem, aListener) {
+        cal.LOG("[calGoogleCalendar] Deleting item " + aItem.title + "(" + aItem.id + ")");
 
-            request.itemId = aId;
-            request.type = request.GET;
-            request.uri = this.fullUri.spec;
-            request.operationListener = aListener;
-            request.responseListener = { onResult: this.getItem_response.bind(this) };
+        let request = new calGoogleRequest();
+        Task.spawn(function() {
+            request.type = request.DELETE;
             request.calendar = this;
-
-            // Request Parameters
-            request.addQueryParameter("ctz", calendarDefaultTimezone().tzid);
-            request.addQueryParameter("max-results", kMANY_EVENTS);
-            request.addQueryParameter("singleevents", "false");
-
-            this.session.asyncItemRequest(request);
-            return request;
-        } catch (e) {
-            cal.LOG("[calGoogleCalendar] getItem failed before request " + aId + "):\n" + e);
-
-            this.notifyOperationComplete(aListener,
-                                         e.result,
-                                         Components.interfaces.calIOperationListener.GET,
-                                         null,
-                                         e.message);
-        }
-        return null;
-    },
-
-    getItems: function cGC_getItems(aItemFilter,
-                                    aCount,
-                                    aRangeStart,
-                                    aRangeEnd,
-                                    aListener) {
-        try {
-            // Check if we have a session. If not, then the user has canceled
-            // the login prompt.
-            this.ensureSession();
-
-            // item base type
-            let wantEvents = ((aItemFilter &
-                               Components.interfaces.calICalendar.ITEM_FILTER_TYPE_EVENT) != 0);
-            let wantInvitations = ((aItemFilter &
-                 Components.interfaces.calICalendar.ITEM_FILTER_REQUEST_NEEDS_ACTION) != 0);
-
-            if (!wantEvents) {
-                // Events are not wanted, nothing to do. The
-                // notifyOperationComplete in the catch block below will catch
-                // this.
-                throw new Components.Exception("", Components.results.NS_OK);
+            if (cal.isEvent(aItem)) {
+                request.uri = this.createEventsURI("events", getGoogleId(aItem, this.offlineStorage));
+                if (Preferences.get("calendar.google.sendEventNotifications", false)) {
+                    request.addQueryParameter("sendNotifications", "true");
+                }
+            } else if (cal.isToDo(aItem)) {
+                request.uri = this.createTasksURI("tasks", aItem.id);
             }
 
-            // Requesting only a DATE returns items based on UTC. Therefore, we make
-            // sure both start and end dates include a time and timezone. This may
-            // not quite be what was requested, but I'd say its a shortcoming of
-            // rfc3339.
-            if (aRangeStart) {
-                aRangeStart = aRangeStart.clone();
-                aRangeStart.isDate = false;
-            }
-            if (aRangeEnd) {
-                aRangeEnd = aRangeEnd.clone();
-                aRangeEnd.isDate = false;
+            if (!request.uri) {
+                throw Components.Exception("Item type not supported",
+                                           Components.results.NS_ERROR_NOT_IMPLEMENTED);
             }
 
-            let rfcRangeStart = cal.toRFC3339(aRangeStart);
-            let rfcRangeEnd = cal.toRFC3339(aRangeEnd);
+            // Set up etag from storage so we don't overwrite any foreign changes
+            let meta = getItemMetadata(this.offlineStorage, aItem) ||
+                       getItemMetadata(this.offlineStorage, aItem.parentItem);
+            if (meta && meta.etag) {
+                request.addRequestHeader("If-Match", meta.etag);
+            } else {
+                cal.ERROR("[calGoogleCalendar] Missing ETag for " + aItem.hashId);
+            }
 
-            let request = new calGoogleRequest(this);
+            try {
+                yield this.session.asyncItemRequest(request);
+            } catch (e if e.result == calGoogleRequest.CONFLICT_MODIFY ||
+                          e.result == calGoogleRequest.CONFLICT_DELETED) {
+                yield checkResolveConflict(request, this, aItem);
+            }
 
-            request.type = request.GET;
-            request.uri = this.fullUri.spec;
-            request.operationListener = aListener;
-            request.calendar = this;
-            request.itemRangeStart = aRangeStart;
-            request.itemRangeEnd = aRangeEnd;
-            request.itemFilter = aItemFilter;
-
-            // Request Parameters
-            request.addQueryParameter("ctz", calendarDefaultTimezone().tzid);
-            request.addQueryParameter("max-results",
-                                      aCount ? aCount : kMANY_EVENTS);
-            request.addQueryParameter("singleevents", "false");
-            request.addQueryParameter("start-min", rfcRangeStart);
-            request.addQueryParameter("start-max", rfcRangeEnd);
-            request.responseListener = { onResult: this.getItems_response.bind(this) };
-            this.session.asyncItemRequest(request);
-            return request;
-        } catch (e) {
-            this.notifyOperationComplete(aListener,
-                                         e.result,
-                                         Components.interfaces.calIOperationListener.GET,
-                                         null,
-                                         e.message);
-        }
-        return null;
+            deleteItemMetadata(this.offlineStorage, aItem);
+
+            throw new Task.Result(aItem);
+        }.bind(this)).then(function (item) {
+            cal.LOG("[calGoogleCalendar] Deleting " + aItem.title + " succeeded");
+            this.observers.notify("onDeleteItem", [item]);
+            this.notifyOperationComplete(aListener, Components.results.NS_OK,
+                                         cIOL.DELETE, item.id, item);
+        }.bind(this), function(e) {
+            let code = e.result || Components.results.NS_ERROR_FAILURE;
+            if (code != Components.interfaces.calIErrors.OPERATION_CANCELLED) {
+                cal.ERROR("[calGoogleCalendar] Deleting item " + aItem.title +
+                          " failed:" + code + ": " + e.message);
+            }
+            this.notifyPureOperationComplete(aListener, code, cIOL.DELETE, aItem.id, e.message);
+        }.bind(this));
+        return request;
     },
 
-    refresh: function cGC_refresh() {
-        this.mObservers.notify("onLoad", [this]);
+    getItem: function(aId, aListener) {
+        this.mOfflineStorage.getItem.apply(this.mOfflineStorage, arguments);
     },
 
-    /*
-     * Google Calendar Provider Response Listener functions
-     */
-
-    /**
-     * addItem_response
-     * Response function, called by the session object when an item was added
-     *
-     * @param aOperation The calIGoogleRequest processing the request
-     * @param aData      In case of an error, this is the error string, otherwise
-     *                     an XML representation of the added item.
-     */
-    addItem_response: function cGC_addItem_response(aOperation, aData) {
-        // First, have the general response retrieve the item
-        let item, e;
-        try {
-            item = DataToItem(aOperation, aData, this, null);
-            if (!resolveConflicts(aOperation, item)) {
-                // If a conflict occurred and the user wants to overwrite, a new
-                // request will be sent. bail out here, this method will be
-                // called again
-                return;
-            }
-        } catch (exp) {
-            item = null;
-            e = exp;
-        }
-
-        let resultCode;
-        if (item) {
-            cal.LOG("[calGoogleCalendar] Adding item " + item.title + " successful");
-            this.mObservers.notify("onAddItem", [item]);
-            resultCode = Components.results.NS_OK;
-        } else {
-            cal.LOG("[calGoogleCalendar] Adding item " + aOperation.newItem.id + " failed, status " + aOperation.status + ", Exception: " + e);
-            resultCode = isCacheException(e) ? Components.results.NS_ERROR_NOT_AVAILABLE : e.result || Components.results.NS_ERROR_FAILURE;
-        }
+    getItems: function(aFilter, aCount, aRangeStart, aRangeEnd, aListener) {
+        this.mOfflineStorage.getItems.apply(this.mOfflineStorage, arguments);
+    },
 
-        this.notifyOperationComplete(aOperation.operationListener,
-                                     resultCode,
-                                     Components.interfaces.calIOperationListener.ADD,
-                                     (item ? item.id : null),
-                                     (item ? item : e.message));
+    refresh: function() {
+        this.mObservers.notify("onLoad", [this]);
     },
 
     /**
-     * modifyItem_response
-     * Response function, called by the session object when an item was modified
-     *
-     * @param aOperation The calIGoogleRequest processing the request
-     * @param aData      In case of an error, this is the error string, otherwise
-     *                     an XML representation of the added item.
+     * Implement calIChangeLog
      */
-    modifyItem_response: function cGC_modifyItem_response_onResult(aOperation,
-                                                                   aData) {
-        let self = this;
-        function notifyObserver(item, oldItem) {
-            if (item && item.parentItem != item) {
-                item.parentItem.recurrenceInfo.modifyException(item, false);
-                item = item.parentItem;
-                oldItem = oldItem.parentItem;
-            }
-            // Notify Observers
-            if (item) {
-                self.mObservers.notify("onModifyItem", [item, oldItem]);
-            }
+    get offlineStorage() this.mOfflineStorage,
+    set offlineStorage(val) {
+        this.mOfflineStorage = val;
+        let cacheVersion = this.getProperty("cache.version");
+        let resetPromise;
+        if (cacheVersion && cacheVersion != this.CACHE_DB_VERSION) {
+            cal.LOG("[calGoogleCalendar] Migrating cache from " +
+                    cacheVersion + " to " + this.CACHE_DB_VERSION);
+            this.resetSync()
+            resetPromise = this.resetSync();
+        } else if (!cacheVersion) {
+            resetPromise = Promise.resolve();
         }
 
-        // First, convert the data to an item and make sure no conflicts occurred.
-        let newItem, e;
-        try {
-            newItem = DataToItem(aOperation, aData, this, aOperation.newItem);
-            if (!resolveConflicts(aOperation, newItem)) {
-                // If a conflict occurred and the user wants to overwrite, a new
-                // request will be sent. bail out here, this method will be
-                // called again
-                return;
-            }
-        } catch (exp) {
-            newItem = null;
-            e = exp;
+        if (resetPromise) {
+            resetPromise.then(function() {
+                this.setProperty("cache.version", this.CACHE_DB_VERSION);
+            }.bind(this));
         }
 
-        let resultCode;
-        if (newItem) {
-            cal.LOG("[calGoogleCalendar] Modifying item " + newItem.id + " successful");
-            notifyObserver(newItem, aOperation.oldItem);
-            resultCode = Components.results.NS_OK;
-        } else {
-            cal.LOG("[calGoogleCalendar] Modifying item " + aOperation.oldItem.id + " failed, status " + aOperation.status + ", Exception: " + e);
-            resultCode = isCacheException(e) ? Components.results.NS_ERROR_NOT_AVAILABLE : e.result || Components.results.NS_ERROR_FAILURE;
-        }
-        this.notifyOperationComplete(aOperation.operationListener,
-                                     resultCode,
-                                     Components.interfaces.calIOperationListener.MODIFY,
-                                     (newItem ? newItem.id : null),
-                                     (newItem ? newItem : e.message));
+        return val;
     },
 
-    /**
-     * deleteItem_response
-     * Response function, called by the session object when an Item was deleted
-     *
-     * @param aOperation The calIGoogleRequest processing the request
-     * @param aData      In case of an error, this is the error string, otherwise
-     *                     an XML representation of the added item.
-     */
-    deleteItem_response: function cGC_deleteItem_response_onResult(aOperation,
-                                                                   aData) {
-        let item, e;
-        try {
-            item = DataToItem(aOperation, aData, this, aOperation.oldItem);
-            if (!resolveConflicts(aOperation, item)) {
-                // If a conflict occurred and the user wants to overwrite, a new
-                // request will be sent. bail out here, this method will be
-                // called again
-                return;
-            }
-        } catch (exp) {
-            item = null;
-            e = exp;
-        }
-
-        let resultCode;
-        if (item) {
-            cal.LOG("[calGoogleCalendar] Deleting item " + aOperation.oldItem.id + " successful");
-            this.mObservers.notify("onDeleteItem", [item]);
-            resultCode = Components.results.NS_OK;
-        } else {
-            cal.LOG("[calGoogleCalendar] Deleting item " + aOperation.oldItem.id + " failed, status " + aOperation.status + ", Exception: " + e);
-            resultCode = isCacheException(e) ? Components.results.NS_ERROR_NOT_AVAILABLE : e.result || Components.results.NS_ERROR_FAILURE;
-        }
-        this.notifyOperationComplete(aOperation.operationListener,
-                                     resultCode,
-                                     Components.interfaces.calIOperationListener.DELETE,
-                                     (item ? item.id : null),
-                                     (item ? item : e.message));
+    resetLog: function() {
+        this.resetSync().then(function() {
+            this.mObservers.notify("onLoad", [this]);
+        }.bind(this));
     },
 
-    /**
-     * getItem_response
-     * Response function, called by the session object when a single Item was
-     * downloaded.
-     *
-     * @param aOperation The calIGoogleRequest processing the request
-     * @param aData      In case of an error, this is the error string, otherwise
-     *                     an XML representation of the added item.
-     */
-    getItem_response: function cGC_getItem_response_onResult(aOperation,
-                                                             aData) {
-        // XXX Due to google issue 399, we need to parse a full feed here.
-        try {
-            if (!Components.isSuccessCode(aOperation.status)) {
-                throw new Components.Exception(aData, aOperation.status);
-            }
-
-            // A feed was passed back, parse it.
-            let xml = cal.xml.parseString(aData);
-            let timezoneString = gdataXPathFirst(xml, 'atom:feed/gCal:timezone/@value') || "UTC";
-            let timezone = gdataTimezoneService.getTimezone(timezoneString);
-
-            // We might be able to get the full name through this feed's author
-            // tags. We need to make sure we have a session for that.
-            this.ensureSession();
-
-            // Get the item entry by id.
-            let itemXPath = 'atom:feed/atom:entry[substring-before(atom:id/text(), "' + aOperation.itemId + '")!="" or gCal:uid/@value="' + aOperation.itemId + '"]';
-            let itemEntry = gdataXPathFirst(xml, itemXPath);
-            if (!itemEntry) {
-                // Item wasn't found. Skip onGetResult and just complete. Not
-                // finding an item isn't a user-important error, it may be a
-                // wanted case. (i.e itip)
-                cal.LOG("[calGoogleCalendar] Item " + aOperation.itemId + " not found in calendar " + this.name);
-                throw new Components.Exception("Item not found", Components.results.NS_OK);
-            }
-            let item = XMLEntryToItem(itemEntry, timezone, this);
-            item.calendar = this.superCalendar;
-
-            if (item.recurrenceInfo) {
-                // If this item is recurring, get all exceptions for this item.
-                for each (let entry in gdataXPath(xml, 'atom:feed/atom:entry[gd:originalEvent/@id="' + aOperation.itemId + '"]')) {
-                    let excItem = XMLEntryToItem(entry, timezone, this);
-
-                    // Google uses the status field to reflect negative
-                    // exceptions.
-                    if (excItem.status == "CANCELED") {
-                        item.recurrenceInfo.removeOccurrenceAt(excItem.recurrenceId);
-                    } else {
-                        excItem.calendar = this;
-                        item.recurrenceInfo.modifyException(excItem, true);
-                    }
+    resetSync: function() {
+        let deferred = Promise.defer();
+        cal.LOG("[calGoogleCalendar] Resetting last updated counter for " + this.name);
+        this.setProperty("syncToken.events", "");
+        this.setProperty("lastUpdated.tasks", "");
+        this.mThrottle = Object.create(null);
+        this.mOfflineStorage.QueryInterface(Components.interfaces.calICalendarProvider)
+                            .deleteCalendar(this.mOfflineStorage, {
+            onDeleteCalendar: function(aCalendar, aStatus, aDetal) {
+                if (Components.isSuccessCode(aStatus)) {
+                    deferred.resolve();
+                } else {
+                    deferred.reject(aDetail);
                 }
             }
-            // We are done, notify the listener of our result and that we are
-            // done.
-            cal.LOG("[calGoogleCalendar] Item " + aOperation.itemId + " was found in calendar " + this.name);
-            aOperation.operationListener.onGetResult(this.superCalendar,
-                                                     Components.results.NS_OK,
-                                                     Components.interfaces.calIEvent,
-                                                     null,
-                                                     1,
-                                                     [item]);
-            this.notifyOperationComplete(aOperation.operationListener,
-                                         Components.results.NS_OK,
-                                         Components.interfaces.calIOperationListener.GET,
-                                         item.id,
-                                         null);
-        } catch (e) {
-            if (!Components.isSuccessCode(e.result)) {
-                cal.LOG("[calGoogleCalendar] Error getting item " + aOperation.itemId + ":\n" + e);
-                Components.utils.reportError(e);
-            }
-            this.notifyOperationComplete(aOperation.operationListener,
-                                         e.result,
-                                         Components.interfaces.calIOperationListener.GET,
-                                         null,
-                                         e.message);
-        }
+       });
+       return deferred.promise;
     },
 
-    /**
-     * getItems_response
-     * Response function, called by the session object when an Item feed was
-     * downloaded.
-     *
-     * @param aOperation The calIGoogleRequest processing the request
-     * @param aData      In case of an error, this is the error string, otherwise
-     *                     an XML representation of the added item.
-     */
-    getItems_response: function cGC_getItems_response(aOperation, aData) {
-        // To simplify code, provide a one-stop function to call, independant of
-        // if and what type of listener was passed.
-        let listener = aOperation.operationListener ||
-            { onGetResult: function() {}, onOperationComplete: function() {} };
-
-        cal.LOG("[calGoogleCalendar] Received response for " + aOperation.uri);
-        try {
-            // Check if the call succeeded
-            if (!Components.isSuccessCode(aOperation.status)) {
-                throw new Components.Exception(aData, aOperation.status);
-            }
+    replayChangesOn: function(aListener) {
+        // Figure out if the user is idle, no need to synchronize if so.
+        let idleTime = Components.classes["@mozilla.org/widget/idleservice;1"]
+                                 .getService(Components.interfaces.nsIIdleService)
+                                 .idleTime;
+        let maxIdleTime = Preferences.get("calendar.google.idleTime", 300) * 1000;
 
-            // A feed was passed back, parse it.
-            let xml = cal.xml.parseString(aData);
-            let timezoneString = gdataXPathFirst(xml, 'atom:feed/gCal:timezone/@value') || "UTC";
-            let timezone = gdataTimezoneService.getTimezone(timezoneString);
-
-            // We might be able to get the full name through this feed's author
-            // tags. We need to make sure we have a session for that.
-            this.ensureSession();
-
-            if (gdataXPathFirst(xml, 'atom:feed/atom:author/atom:email/text()') == this.mSession.userName) {
-                // If the current entry contains the user's email, then we can
-                // extract the user's full name also.
-                this.mSession.fullName = gdataXPathFirst(xml, 'atom:feed/atom:author/atom:name/text()');
-            }
-
-            let wantInvitations = ((aOperation.itemFilter &
-                 Components.interfaces.calICalendar.ITEM_FILTER_REQUEST_NEEDS_ACTION) != 0);
+        if (maxIdleTime != 0 && idleTime > maxIdleTime) {
+            cal.LOG("[calGoogleCalendar] Skipping refresh since user is idle");
+            aListener.onResult({ status: Components.results.NS_OK }, null);
+            return Promise.resolve();
+        }
 
-            // Parse all <entry> tags
-            for each (let entry in gdataXPath(xml, 'atom:feed/atom:entry')) {
-                if (gdataXPathFirst(entry, 'gd:originalEvent')) {
-                    // This is an exception. If we are doing an uncached
-                    // operation, then skip it for now since it will be parsed
-                    // later.
-                    continue;
+        // Now that we've determined we are not idle we can continue with the sync.
+        let maxResults = Preferences.get("calendar.google.maxResultsPerRequest", null);
+
+        // We are going to be making potentially lots of changes to the offline
+        // storage, start a batch operation.
+        this.mOfflineStorage.startBatch();
+
+        // Update the calendar settings
+        let calendarPromise = Promise.resolve();
+        if (this.mCalendarName && this.checkThrottle("calendarList")) {
+            let calendarRequest = new calGoogleRequest();
+            calendarRequest.calendar = this;
+            calendarRequest.type = calendarRequest.GET;
+            calendarRequest.uri = this.createUsersURI("calendarList", this.mCalendarName)
+            calendarPromise = this.session.asyncItemRequest(calendarRequest).then(function(aData) {
+                if (aData.defaultReminders) {
+                    this.defaultReminders = aData.defaultReminders.map(function(x) JSONToAlarm(x, true));
+                } else {
+                    this.defaultReminders = [];
                 }
 
-                let item = XMLEntryToItem(entry, timezone, this);
-                item.calendar = this.superCalendar;
-
-                if (wantInvitations) {
-                    // If invitations are wanted and this is not an invitation,
-                    // or if the user is not an attendee, or has already accepted
-                    // then this is not an invitation.
-                    let att = item.getAttendeeById("mailto:" + this.session.userName);
-                    if (!this.isInvitation(item) ||
-                        !att ||
-                        att.participationStatus != "NEEDS-ACTION") {
-                        continue;
-                    }
+                for each (let k in ["accessRole", "backgroundColor", "description",
+                                    "foregroundColor", "location", "primary",
+                                    "summary", "summaryOverride", "timeZone"]) {
+                    this.setProperty("settings." + k, aData[k]);
                 }
+                this.setProperty("settings.defaultReminders", JSON.stringify(aData.defaultReminders));
+            }.bind(this));
+        }
 
-                cal.LOG("[calGoogleCalendar] Parsing entry:\n" + cal.xml.serializeDOM(entry) + "\n");
-
-                if (item.recurrenceInfo) {
-                    // If we are doing an uncached operation, then we need to
-                    // gather all exceptions and put them into the item.
-                    // Otherwise, our listener will take care of mapping the
-                    // exception to the base item.
-                    for each (let oid in gdataXPath(xml, 'atom:feed/atom:entry[gd:originalEvent/@id="' + item.id + '"]')) {
-                        // Get specific fields so we can speed up the parsing process
-                        let status = gdataXPathFirst(oid, 'gd:eventStatus/@value').substring(39);
-
-                        if (status == "canceled") {
-                            let rId = gdataXPathFirst(oid, 'gd:when/@startTime');
-                            let rDate = cal.fromRFC3339(rId, timezone);
-                            cal.LOG("[calGoogleCalendar] Negative exception " + rId + "/" + rDate);
-                            item.recurrenceInfo.removeOccurrenceAt(rDate);
-                        } else {
-                            // Parse the exception and modify the current item
-                            let excItem = XMLEntryToItem(oid, timezone, this);
-
-                            if (excItem) {
-                                // Google uses the status field to reflect negative
-                                // exceptions.
-                                excItem.calendar = this;
-                                item.recurrenceInfo.modifyException(excItem, true);
-                            }
-                        }
-                    }
+        // Set up a request for the events
+        let eventsRequest = new calGoogleRequest();
+        let eventsPromise = Promise.resolve();
+        eventsRequest.calendar = this;
+        eventsRequest.type = eventsRequest.GET;
+        eventsRequest.uri = this.createEventsURI("events");
+        eventsRequest.addQueryParameter("timeZone", cal.calendarDefaultTimezone().tzid);
+        eventsRequest.addQueryParameter("maxResults", maxResults);
+        let syncToken = this.getProperty("syncToken.events");
+        if (syncToken) {
+            eventsRequest.addQueryParameter("showDeleted", "true");
+            eventsRequest.addQueryParameter("syncToken", syncToken);
+        }
+        if (eventsRequest.uri && this.checkThrottle("events")) {
+            let saver = new ItemSaver(this);
+            eventsPromise = this.session.asyncPaginatedRequest(eventsRequest, null, function(aData) {
+                // On each request...
+                saver.parseItemStream(aData);
+            }.bind(this), function(aData) {
+                // On last request...
+                saver.processRemainingExceptions();
+
+                if (aData.nextSyncToken) {
+                    cal.LOG("[calGoogleCalendar] New sync token for " +
+                            this.name + "(events) is now: " + aData.nextSyncToken);
+                    this.setProperty("syncToken.events", aData.nextSyncToken);
                 }
-
-                item.makeImmutable();
-                LOGitem(item);
-
-                // This is an uncached call, expand the item and tell our
-                // get listener about the item.
-                let expandedItems = expandItems(item, aOperation);
-                listener.onGetResult(this.superCalendar,
-                                     Components.results.NS_OK,
-                                     Components.interfaces.calIEvent,
-                                     null,
-                                     expandedItems.length,
-                                     expandedItems);
-            }
-            // Operation Completed successfully.
-            this.notifyOperationComplete(listener,
-                                         Components.results.NS_OK,
-                                         Components.interfaces.calIOperationListener.GET,
-                                         null,
-                                         null);
-        } catch (e) {
-            cal.LOG("[calGoogleCalendar] Error getting items:\n" + e);
-            this.notifyOperationComplete(listener,
-                                         e.result,
-                                         Components.interfaces.calIOperationListener.GET,
-                                         null,
-                                         e.message);
+            }.bind(this));
         }
-    },
-
-    /**
-     * Implement calIChangeLog
-     */
-    get offlineStorage() {
-        return this.mOfflineStorage;
-    },
-
-    set offlineStorage(val) {
-        return (this.mOfflineStorage = val);
-    },
-
-    resetLog: function cGC_resetLog() {
-        cal.LOG("[calGoogleCalendar] Resetting last updated counter for " + this.name);
-        this.deleteProperty("google.lastUpdated");
-    },
 
-    replayChangesOn: function cGC_replayChangesOn(aListener) {
-        let lastUpdate = this.getProperty("google.lastUpdated");
-        let lastUpdateDateTime;
-        if (lastUpdate) {
-            // Set up the last sync stamp
-            lastUpdateDateTime = createDateTime();
-            lastUpdateDateTime.icalString = lastUpdate;
-
-            // Set up last week
-            let lastWeek = getCorrectedDate(now().getInTimezone(UTC()));
-            lastWeek.day -= 7;
-            if (lastWeek.compare(lastUpdateDateTime) >= 0) {
-                // The last sync was longer than a week ago. Google requires a full
-                // sync in that case. This call also takes care of calling
-                // resetLog().
-                this.superCalendar.wrappedJSObject.setupCachedCalendar();
-                lastUpdateDateTime = null;
-            }
-            cal.LOG("[calGoogleCalendar] The calendar " + this.name + " was last modified: " + lastUpdateDateTime);
+        // Set up a request for tasks
+        let tasksRequest = new calGoogleRequest();
+        let tasksPromise = Promise.resolve();
+        tasksRequest.calendar = this;
+        tasksRequest.type = tasksRequest.GET;
+        tasksRequest.uri = this.createTasksURI("tasks");
+        tasksRequest.addQueryParameter("maxResults", maxResults);
+        let lastUpdated = this.getUpdatedMin("tasks");
+        if (lastUpdated) {
+            tasksRequest.addQueryParameter("updatedMin", cal.toRFC3339(lastUpdated));
+            tasksRequest.addQueryParameter("showDeleted", "true");
         }
-
-        let request = new calGoogleRequest(this.mSession);
-
-        request.type = request.GET;
-        request.uri = this.fullUri.spec
-        request.destinationCal = this.mOfflineStorage;
-
-        let calendar = this;
-        request.responseListener = { onResult: this.syncItems_response.bind(this, (lastUpdateDateTime == null)) }
-        request.operationListener = aListener;
-        request.calendar = this;
-
-        // Request Parameters
-        request.addQueryParameter("ctz", calendarDefaultTimezone().tzid);
-        request.addQueryParameter("max-results", kMANY_EVENTS);
-        request.addQueryParameter("singleevents", "false");
-
-        if (lastUpdateDateTime) {
-            // Partial sync requires sending updated-min
-            request.addQueryParameter("updated-min", cal.toRFC3339(lastUpdateDateTime));
+        if (tasksRequest.uri && this.checkThrottle("tasks")) {
+            let saver = new ItemSaver(this);
+            tasksPromise = this.session.asyncPaginatedRequest(tasksRequest, function(aData) {
+                // On the first request...
+                cal.LOG("[calGoogleCalendar] Last sync date for " + this.name +
+                        "(tasks) is now: " + tasksRequest.requestDate.toString());
+                let lastUpdated = tasksRequest.requestDate.icalString;
+                this.setProperty("lastUpdated.tasks", lastUpdated);
+            }.bind(this), function(aData) {
+                // On each request...
+                saver.parseItemStream(aData);
+            }.bind(this));
         }
 
-        // Request the item. The response function is ready to take care of both
-        // uncached getItem requests and this type of synchronization request.
-        this.mSession.asyncItemRequest(request);
-    },
-
-    /**
-     * syncItems_response
-     * Response function, called by the session object when an Item feed was
-     * downloaded.
-     *
-     * @param aIsFullSync   If set, this is a full sync rather than an update.
-     * @param aOperation    The calIGoogleRequest processing the request
-     * @param aData         In case of an error, this is the error string, otherwise
-     *                        an XML representation of the added item.
-     */
-    syncItems_response: function cGC_syncItems_response(aIsFullSync, aOperation, aData) {
-        cal.LOG("[calGoogleCalendar] Received response for " + aOperation.uri + (aIsFullSync ? " (full sync)" : ""));
-        try {
-            // Check if the call succeeded
-            if (!Components.isSuccessCode(aOperation.status)) {
-                throw new Components.Exception(aData, aOperation.status);
-            }
-
-            // A feed was passed back, parse it.
-            let xml = cal.xml.parseString(aData);
-            let timezoneString = gdataXPathFirst(xml, 'atom:feed/gCal:timezone/@value') || "UTC";
-            let timezone = gdataTimezoneService.getTimezone(timezoneString);
-
-            // We might be able to get the full name through this feed's author
-            // tags. We need to make sure we have a session for that.
-            this.ensureSession();
-
-            if (gdataXPathFirst(xml, 'atom:feed/atom:author/atom:email/text()') == this.mSession.userName) {
-                // If the current entry contains the user's email, then we can
-                // extract the user's full name also.
-                this.mSession.fullName = gdataXPathFirst(xml, 'atom:feed/atom:author/atom:name/text()');
-            }
-
-            // This is the calendar we should sync changes into.
-            let destinationCal = aOperation.destinationCal;
-
-            for each (let entry in gdataXPath(xml, 'atom:feed/atom:entry')) {
-                let recurrenceId = getRecurrenceIdFromEntry(entry, timezone);
-                if (aIsFullSync && recurrenceId) {
-                    // On a full sync, we parse exceptions different.
-                    continue;
-                }
-                cal.LOG("[calGoogleCalendar] Parsing entry:\n" + entry + "\n");
-
-                let referenceItemObj = {}
-                destinationCal.getItem(getIdFromEntry(entry),
-                                       new syncSetter(referenceItemObj));
-                let referenceItem = referenceItemObj.value &&
-                                    referenceItemObj.value.clone();
-
-                // Parse the item. If we got a reference item from the storage
-                // calendar, put that in to make sure we get all exceptions and
-                // such.
-                let item = XMLEntryToItem(entry,
-                                          timezone,
-                                          this,
-                                          (recurrenceId && referenceItem ? null : referenceItem));
-                item.calendar = this.superCalendar;
-
-                if (aIsFullSync && item.recurrenceInfo) {
-                    // On a full synchronization, we can go ahead and pre-parse
-                    // all exceptions and then add the item at once. This way we
-                    // make sure
-                    for each (let oid in gdataXPath(xml, 'atom:feed/atom:entry[gd:originalEvent/@id="' + item.id + '"]')) {
-                        // Get specific fields so we can speed up the parsing process
-                        let status = gdataXPathFirst(oid, 'gd:eventStatus/@value').substring(39);
-
-                        if (status == "canceled") {
-                            let rId = gdataXPathFirst(oid, 'gd:when/@startTime');
-                            let rDate = cal.fromRFC3339(rId, timezone);
-                            item.recurrenceInfo.removeOccurrenceAt(rDate);
-                            cal.LOG("[calGoogleCalendar] Negative exception " + rId + "/" + rDate);
-                        } else {
-                            // Parse the exception and modify the current item
-                            let excItem = XMLEntryToItem(oid, timezone, this);
-
-                            if (excItem) {
-                                // Google uses the status field to reflect negative
-                                // exceptions.
-                                excItem.calendar = this;
-                                item.recurrenceInfo.modifyException(excItem, true);
-                            }
-                        }
-                    }
-                }
-
-                LOGitem(item);
-
-                if (!aIsFullSync && item.recurrenceId && referenceItem) {
-                    // This is a single occurrence that has been updated.
-                    if (item.status == "CANCELED") {
-                        // Canceled means the occurrence is an EXDATE.
-                        referenceItem.recurrenceInfo.removeOccurrenceAt(item.recurrenceId);
-                    } else {
-                        // Not canceled means the occurrence was modified.
-                        item.parentItem = referenceItem;
-                        referenceItem.recurrenceInfo.modifyException(item, true);
-                    }
-                    destinationCal.modifyItem(referenceItem, null, null);
-                } else if (!item.recurrenceId) {
-                    // This is a normal item. If it was canceled, then it should
-                    // be deleted, otherwise it should be either added or
-                    // modified. The relaxed mode of the destination calendar
-                    // takes care of the latter two cases.
-                    if (item.status == "CANCELED") {
-                        destinationCal.deleteItem(item, null);
-                    } else {
-                        destinationCal.modifyItem(item, null, null);
-                    }
-                } else {
-                    // We could not find the parent item for the occurrence in
-                    // the feed.
-                    WARN("occurrence without parent for item "  + item.id);
-                }
+        return PromiseAll([calendarPromise, eventsPromise, tasksPromise]).then(function() {
+            this.mOfflineStorage.endBatch();
+            aListener.onResult({ status: Components.results.NS_OK }, null);
+        }.bind(this), function(e) {
+            this.mOfflineStorage.endBatch();
+            let code = e.result || Components.results.NS_ERROR_FAILURE;
+            if (code == calGoogleRequest.RESOURCE_GONE) {
+                cal.LOG("[calGoogleCalendar] Server did not accept " +
+                        "incremental update, resetting calendar and " +
+                        "starting over.");
+                this.resetSync().then(function() {
+                    this.replayChangesOn(aListener);
+                }.bind(this));
+            } else {
+                cal.LOG("[calGoogleCalendar] Error syncing:\n" + code + ":" +
+                        stringException(e));
+                aListener.onResult({ status: code }, e.message);
             }
-
-            // Set the last updated timestamp to now.
-            cal.LOG("[calGoogleCalendar] Last sync date for " + this.name + " is now: " +
-                    aOperation.requestDate.toString());
-            this.setProperty("google.lastUpdated",
-                             aOperation.requestDate.icalString);
-
-            // Tell our listener we are done.
-            aOperation.operationListener.onResult(aOperation, null);
-        } catch (e) {
-            cal.LOG("[calGoogleCalendar] Error syncing items:\n" + e);
-            aOperation.operationListener.onResult({ status: e.result }, e.message);
-        }
+        }.bind(this));
     },
 
     /**
@@ -1123,7 +765,7 @@ calGoogleCalendar.prototype = {
      * provider, but we want to advertise that we will always take care of
      * notifications.
      */
-    canNotify: function cGC_canNotify(aMethod, aItem) {
-        return true;
-    }
+    canNotify: function(aMethod, aItem) true
 };
+
+var NSGetFactory = XPCOMUtils.generateNSGetFactory([calGoogleCalendar]);
diff --git a/calendar/providers/gdata/components/calGoogleCalendar.manifest b/calendar/providers/gdata/components/calGoogleCalendar.manifest
new file mode 100644
index 0000000..512d1a9
--- /dev/null
+++ b/calendar/providers/gdata/components/calGoogleCalendar.manifest
@@ -0,0 +1,2 @@
+component {d1a6e988-4b4d-45a5-ba46-43e501ea96e3} calGoogleCalendar.js
+contract @mozilla.org/calendar/calendar;1?type=gdata {d1a6e988-4b4d-45a5-ba46-43e501ea96e3}
diff --git a/calendar/providers/gdata/components/calGoogleCalendarModule.js b/calendar/providers/gdata/components/calGoogleCalendarModule.js
deleted file mode 100644
index 8d45071..0000000
--- a/calendar/providers/gdata/components/calGoogleCalendarModule.js
+++ /dev/null
@@ -1,49 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-Components.utils.import("resource://gre/modules/Services.jsm");
-Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
-Components.utils.import("resource://calendar/modules/calUtils.jsm");
-
-// These constants are used internally to signal errors, to avoid the need for
-// our own error range in calIErrors
-const kGOOGLE_LOGIN_FAILED = 1;
-const kGOOGLE_CONFLICT_DELETED = 2;
-const kGOOGLE_CONFLICT_MODIFY = 3
-
-/** Module Registration */
-const calendarScriptLoadOrder = [
-    "calUtils.js",
-];
-
-const gdataScriptLoadOrder = [
-    "calGoogleCalendar.js",
-    "calGoogleSession.js",
-    "calGoogleRequest.js",
-    "calGoogleUtils.js"
-];
-
-function NSGetFactory(cid) {
-    if (!this.scriptsLoaded) {
-        // First load the calendar scripts
-        cal.loadScripts(calendarScriptLoadOrder, Components.utils.getGlobalForObject(this));
-
-        // Now load gdata extension scripts. __LOCATION__ is the current
-        // filename, so  __LOCATION__.parent == . We expect to find the
-        // subscripts in ./../js
-        let thisDir = __LOCATION__.parent.parent.clone();
-        thisDir.append("js");
-        cal.loadScripts(gdataScriptLoadOrder, Components.utils.getGlobalForObject(this), thisDir);
-        this.scriptsLoaded = true;
-    }
-
-    let components = [
-        calGoogleCalendar,
-        calGoogleSession,
-        calGoogleSessionManager,
-        calGoogleRequest
-    ];
-
-    return (XPCOMUtils.generateNSGetFactory(components))(cid);
-}
diff --git a/calendar/providers/gdata/components/calGoogleCalendarModule.manifest b/calendar/providers/gdata/components/calGoogleCalendarModule.manifest
deleted file mode 100644
index 8362c5e..0000000
--- a/calendar/providers/gdata/components/calGoogleCalendarModule.manifest
+++ /dev/null
@@ -1,11 +0,0 @@
-component {d1a6e988-4b4d-45a5-ba46-43e501ea96e3} calGoogleCalendarModule.js
-contract @mozilla.org/calendar/calendar;1?type=gdata {d1a6e988-4b4d-45a5-ba46-43e501ea96e3}
-
-component {652f6233-e03f-438a-bd3b-39877f68c0f4} calGoogleCalendarModule.js
-contract @mozilla.org/calendar/providers/gdata/session;1 {652f6233-e03f-438a-bd3b-39877f68c0f4}
-
-component {6a7ba1f0-f271-49b0-8e93-5ca33651b4af} calGoogleCalendarModule.js
-contract @mozilla.org/calendar/providers/gdata/session-manager;1 {6a7ba1f0-f271-49b0-8e93-5ca33651b4af}
-
-component {53a3438a-21bc-4a0f-b813-77a8b4f19282} calGoogleCalendarModule.js
-contract @mozilla.org/calendar/providers/gdata/request;1 {53a3438a-21bc-4a0f-b813-77a8b4f19282}
diff --git a/calendar/providers/gdata/components/calGoogleRequest.js b/calendar/providers/gdata/components/calGoogleRequest.js
deleted file mode 100644
index 60fecd5..0000000
--- a/calendar/providers/gdata/components/calGoogleRequest.js
+++ /dev/null
@@ -1,420 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-Components.utils.import("resource://calendar/modules/calUtils.jsm");
-Components.utils.import("resource://gre/modules/Services.jsm");
-Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
-Components.utils.import("resource://gre/modules/Preferences.jsm");
-
-/**
- * calGoogleRequest
- * This class represents a HTTP request sent to Google
- *
- * @constructor
- * @class
- */
-function calGoogleRequest(aSession) {
-    this.mQueryParameters = new Array();
-    this.mSession = aSession;
-    this.wrappedJSObject = this;
-}
-const calGoogleRequestClassID = Components.ID("{53a3438a-21bc-4a0f-b813-77a8b4f19282}");
-const calGoogleRequestInterfaces = [
-    Components.interfaces.calIGoogleRequest,
-    Components.interfaces.calIOperation,
-    Components.interfaces.nsIStreamLoaderObserver,
-    Components.interfaces.nsIInterfaceRequestor,
-    Components.interfaces.nsIChannelEventSink
-];
-calGoogleRequest.prototype = {
-
-    /* Members */
-    mUploadContent: null,
-    mUploadData: null,
-    mSession: null,
-    mExtraData: null,
-    mQueryParameters: null,
-    mType: null,
-    mCalendar: null,
-    mLoader: null,
-    mStatus: Components.results.NS_OK,
-
-    /* Constants */
-    LOGIN: 0,
-    ADD: 1,
-    MODIFY: 2,
-    DELETE: 3,
-    GET: 4,
-
-    /* Simple Attributes */
-    method: "GET",
-    id: null,
-    uri: null,
-    responseListener: null,
-    operationListener: null,
-    reauthenticate: true,
-
-    itemRangeStart: null,
-    itemRangeEnd: null,
-    itemFilter: null,
-    itemId: null,
-    calendar: null,
-    newItem: null,
-    oldItem: null,
-    destinationCal: null,
-
-    classID: calGoogleRequestClassID,
-    QueryInterface: XPCOMUtils.generateQI(calGoogleRequestInterfaces),
-    classInfo: XPCOMUtils.generateCI({
-        classID: calGoogleRequestClassID,
-        contractID: "@mozilla.org/calendar/providers/gdata/request;1",
-        classDescription: "Google Calendar Request",
-        interfaces: calGoogleRequestInterfaces
-    }),
-
-    /**
-     * Implement calIOperation
-     */
-    get isPending() {
-        return (this.mLoader && this.mLoader.request != null);
-    },
-
-    get status() {
-        if (this.isPending) {
-            return this.mLoader.request.status;
-        } else {
-            return this.mStatus;
-        }
-    },
-
-    cancel: function cGR_cancel(aStatus) {
-        if (this.isPending) {
-            this.mLoader.request.cancel(aStatus);
-            this.mStatus = aStatus;
-        }
-    },
-
-    /**
-     * attribute type
-     * The type of this reqest. Must be one of
-     * LOGIN, GET, ADD, MODIFY, DELETE
-     * This also sets the Request Method and for the LOGIN request also the uri
-     */
-    get type() { return this.mType; },
-
-    set type(v) {
-        switch (v) {
-            case this.LOGIN:
-                this.method = "POST";
-                this.uri = "https://www.google.com/accounts/ClientLogin";
-                break;
-            case this.GET:
-                this.method = "GET";
-                break;
-            case this.ADD:
-                this.method = "POST";
-                break;
-            case this.MODIFY:
-                this.method = "PUT";
-                break;
-            case this.DELETE:
-                this.method = "DELETE";
-                break;
-            default:
-                throw new Components.Exception("", Components.results.NS_ERROR_ILLEGAL_VALUE);
-                break;
-        }
-        this.mType = v;
-        return v;
-    },
-
-    /**
-     * setUploadData
-     * The HTTP body data for a POST or PUT request.
-     *
-     * @param aContentType The Content type of the Data
-     * @param aData        The Data to upload
-     */
-    setUploadData: function cGR_setUploadData(aContentType, aData) {
-        this.mUploadContent = aContentType;
-        this.mUploadData = aData;
-    },
-
-    /**
-     * addQueryParameter
-     * Adds a query parameter to this request. This will be used in conjunction
-     * with the uri.
-     *
-     * @param aKey      The key of the request parameter.
-     * @param aValue    The value of the request parameter. This parameter will
-     *                  be escaped.
-     */
-    addQueryParameter: function cGR_addQueryParameter(aKey, aValue) {
-        if (aValue == null || aValue == "") {
-            // Silently ignore empty values.
-            return;
-        }
-        this.mQueryParameters.push(aKey + "=" + encodeURIComponent(aValue));
-    },
-
-    /**
-     * commit
-     * Starts the request process. This can be called multiple times if the
-     * request should be repeated
-     *
-     * @param aSession  The session object this request should be made with.
-     *                  This parameter is optional
-     */
-    commit: function cGR_commit(aSession) {
-
-        try {
-            // Set the session to request with
-            if (aSession) {
-                this.mSession = aSession;
-            }
-
-            let uristring = this.uri;
-            if (this.mQueryParameters.length > 0) {
-                uristring += "?" + this.mQueryParameters.join("&");
-            }
-            let uri = Services.io.newURI(uristring, null, null);
-            let channel = Services.io.newChannelFromURI(uri);
-
-            this.prepareChannel(channel);
-
-            channel = channel.QueryInterface(Components.interfaces.nsIHttpChannel);
-            channel.redirectionLimit = 3;
-
-            this.mLoader = cal.createStreamLoader();
-
-            cal.LOG("[calGoogleCalendar] Requesting " + this.method + " " +
-                    channel.URI.spec);
-
-            channel.notificationCallbacks = this;
-
-            cal.sendHttpRequest(this.mLoader, channel, this);
-        } catch (e) {
-            // Let the response function handle the error that happens here
-            this.fail(e.result, e.message);
-        }
-    },
-
-    /**
-     * fail
-     * Call this request's listener with the given code and Message
-     *
-     * @param aCode     The Error code to fail with
-     * @param aMessage  The Error message. If this is null, an error Message
-     *                  from calIGoogleErrors will be used.
-     */
-    fail: function cGR_fail(aCode, aMessage) {
-        this.mLoader = null;
-        this.mStatus = aCode;
-        this.responseListener.onResult(this, aMessage);
-    },
-
-    /**
-     * succeed
-     * Call this request's listener with a Success Code and the given Result.
-     *
-     * @param aResult   The result Text of this request.
-     */
-    succeed: function cGR_succeed(aResult) {
-        // Succeeding is nothing more than failing with the result code set to
-        // NS_OK.
-        this.fail(Components.results.NS_OK, aResult);
-    },
-
-    /**
-     * prepareChannel
-     * Prepares the passed channel to match this objects properties
-     *
-     * @param aChannel    The Channel to be prepared
-     */
-    prepareChannel: function cGR_prepareChannel(aChannel) {
-
-        // No caching
-        aChannel.loadFlags |= Components.interfaces.nsIRequest.LOAD_BYPASS_CACHE;
-
-        // Set upload Data
-        if (this.mUploadData) {
-            let converter = Components.classes["@mozilla.org/intl/scriptableunicodeconverter"].
-                            createInstance(Components.interfaces.nsIScriptableUnicodeConverter);
-            converter.charset = "UTF-8";
-
-            let stream = converter.convertToInputStream(this.mUploadData);
-            aChannel = aChannel.QueryInterface(Components.interfaces.nsIUploadChannel);
-            aChannel.setUploadStream(stream, this.mUploadContent, -1);
-
-            if (this.mType == this.LOGIN) {
-                cal.LOG("[calGoogleCalendar] Setting upload data for login request (hidden)");
-            } else {
-                cal.LOG("[calGoogleCalendar] Setting Upload Data (" +
-                        this.mUploadContent + "):\n" + this.mUploadData);
-            }
-        }
-
-        aChannel  = aChannel.QueryInterface(Components.interfaces.nsIHttpChannel);
-
-        // Depending on the preference, we will use X-HTTP-Method-Override to
-        // get around some proxies. This will default to true.
-        if (Preferences.get("calendar.google.useHTTPMethodOverride", true) &&
-            (this.method == "PUT" || this.method == "DELETE")) {
-
-            aChannel.requestMethod = "POST";
-            aChannel.setRequestHeader("X-HTTP-Method-Override",
-                                      this.method,
-                                      false);
-            if (this.method == "DELETE") {
-                // DELETE has no body, set an empty one so that Google accepts
-                // the request.
-                aChannel.setRequestHeader("Content-Type",
-                                          "application/atom+xml; charset=UTF-8",
-                                          false);
-                aChannel.setRequestHeader("Content-Length", 0, false);
-            }
-        } else {
-            aChannel.requestMethod = this.method;
-        }
-
-        // Add Authorization
-        if (this.mSession.authToken) {
-            aChannel.setRequestHeader("Authorization",
-                                      "GoogleLogin auth="
-                                      +  this.mSession.authToken,
-                                      false);
-        }
-    },
-
-    /**
-     * @see nsIInterfaceRequestor
-     * @see calProviderUtils.jsm
-     */
-    getInterface: cal.InterfaceRequestor_getInterface,
-
-    /**
-     * @see nsIChannelEventSink
-     */
-    asyncOnChannelRedirect: function cGR_onChannelRedirect(aOldChannel,
-                                                           aNewChannel,
-                                                           aFlags,
-                                                           aCallback) {
-        // all we need to do to the new channel is the basic preparation
-        this.prepareChannel(aNewChannel);
-        aCallback.onRedirectVerifyCallback(Components.results.NS_OK);
-    },
-
-    /**
-     * @see nsIStreamLoaderObserver
-     */
-    onStreamComplete: function cGR_onStreamComplete(aLoader,
-                                                    aContext,
-                                                    aStatus,
-                                                    aResultLength,
-                                                    aResult) {
-        if (!aResult || !Components.isSuccessCode(aStatus)) {
-            this.fail(aStatus, aResult);
-            return;
-        }
-
-        let httpChannel = aLoader.request.QueryInterface(Components.interfaces.nsIHttpChannel);
-
-        // Convert the stream, falling back to utf-8 in case its not given.
-        let result = cal.convertByteArray(aResult, aResultLength, httpChannel.contentCharset);
-        if (result === null) {
-            this.fail(Components.results.NS_ERROR_FAILURE,
-                      "Could not convert bytestream to Unicode: " + e);
-            return;
-        }
-
-        // Calculate Google Clock Skew
-        let serverDate = new Date(httpChannel.getResponseHeader("Date"));
-        let curDate = new Date();
-
-        // The utility function getCorrectedDate in calGoogleUtils.js receives
-        // its clock skew seconds from here. The clock skew is updated on each
-        // request and is therefore quite accurate.
-        getCorrectedDate.mClockSkew = curDate.getTime() - serverDate.getTime();
-
-        // Remember when this request happened
-        this.requestDate = cal.jsDateToDateTime(serverDate);
-
-        // Handle all (documented) error codes
-        switch (httpChannel.responseStatus) {
-            case 200: /* No error. */
-            case 201: /* Creation of a resource was successful. */
-                // Everything worked out, we are done
-                this.succeed(result);
-                break;
-
-            case 401: /* Authorization required. */
-            case 403: /* Unsupported standard parameter, or authentication or
-                         Authorization failed. */
-                cal.LOG("[calGoogleCalendar] Login failed for " + this.mSession.userName +
-                        " HTTP Status " + httpChannel.responseStatus);
-
-                // login failed. auth token must be invalid, password too
-
-                if (this.type == this.MODIFY ||
-                    this.type == this.DELETE ||
-                    this.type == this.ADD) {
-                    // Encountering this error on a write request means the
-                    // calendar is readonly
-                    this.fail(Components.interfaces.calIErrors.CAL_IS_READONLY, result);
-                } else if (!this.reauthenticate) {
-                    // If no reauth was requested, then don't invalidate the
-                    // whole session and just bail out
-                    this.fail(kGOOGLE_LOGIN_FAILED, result);
-                } else if (this.type == this.LOGIN) {
-                    // If this was a login request itself, then fail it.
-                    // That will take care of logging in again
-                    this.mSession.invalidate();
-                    this.fail(kGOOGLE_LOGIN_FAILED, result);
-                } else {
-                    // Retry the request. Invalidating the session will trigger
-                    // a new login dialog.
-                    this.mSession.invalidate();
-                    this.mSession.asyncItemRequest(this);
-                }
-
-                break;
-            case 404: /* The resource was not found on the server, which is
-                         also a conflict */
-                //  404 NOT FOUND: Resource (such as a feed or entry) not found.
-                this.fail(kGOOGLE_CONFLICT_DELETED, "");
-                break;
-            case 409: /* Specified version number doesn't match resource's
-                         latest version number. */
-                this.fail(kGOOGLE_CONFLICT_MODIFY, result);
-                break;
-            case 400:
-                //  400 BAD REQUEST: Invalid request URI or header, or
-                //                   unsupported nonstandard parameter.
-
-                // HACK Ugh, this sucks. If we send a lower sequence number, Google
-                // will throw a 400 and not a 409, even though both cases are a conflict.
-                if (result == "Cannot decrease the sequence number of an event") {
-                    this.fail(kGOOGLE_CONFLICT_MODIFY, "SEQUENCE-HACK");
-                    break;
-                }
-
-                // Otherwise fall through
-            default:
-                // The following codes are caught here:
-                //  500 INTERNAL SERVER ERROR: Internal error. This is the
-                //                             default code that is used for
-                //                             all unrecognized errors.
-                //
-
-                // Something else went wrong
-                let error = "A request Error Occurred. Status Code: " +
-                            httpChannel.responseStatus + " " +
-                            httpChannel.responseStatusText + " Body: " +
-                            result;
-
-                this.fail(Components.results.NS_ERROR_NOT_AVAILABLE, error);
-                break;
-        }
-    }
-};
diff --git a/calendar/providers/gdata/components/calGoogleSession.js b/calendar/providers/gdata/components/calGoogleSession.js
deleted file mode 100644
index 15959d4..0000000
--- a/calendar/providers/gdata/components/calGoogleSession.js
+++ /dev/null
@@ -1,577 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-Components.utils.import("resource://calendar/modules/calUtils.jsm");
-Components.utils.import("resource://calendar/modules/calXMLUtils.jsm");
-Components.utils.import("resource://calendar/modules/calProviderUtils.jsm");
-Components.utils.import("resource://gre/modules/Services.jsm");
-Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
-
-// This constant is an arbitrary large number. It is used to tell google to get
-// many events, the exact number is not important.
-const kMANY_EVENTS = 0x7FFFFFFF;
-
-function calGoogleSessionManager() {
-    this.wrappedJSObject = this;
-
-}
-const calGoogleSessionManagerClassID = Components.ID("{6a7ba1f0-f271-49b0-8e93-5ca33651b4af}");
-const calGoogleSessionManagerInterfaces = [Components.interfaces.calIGoogleSessionManager];
-calGoogleSessionManager.prototype = {
-    mSessionMap: {},
-
-    classID: calGoogleSessionManagerClassID,
-    QueryInterface: XPCOMUtils.generateQI(calGoogleSessionManagerInterfaces),
-    classInfo: XPCOMUtils.generateCI({
-        classID: calGoogleSessionManagerClassID,
-        contractID: "@mozilla.org/calendar/providers/gdata/session-manager;1",
-        classDescription: "Google Calendar Session Manager",
-        interfaces: calGoogleSessionManagerInterfaces,
-        flags: Components.interfaces.nsIClassInfo.SINGLETON
-    }),
-
-    /**
-     * getSessionByUsername
-     * Get a Session object for the specified username. If aCreate is false,
-     * null will be returned if the session doesn't exist. Otherwise, the
-     * session will be created.
-     *
-     * @param aUsername The username to get the session for
-     * @param aCreate   If true, the session will be created prior to returning
-     */
-    getSessionByUsername: function cGSM_getSessionByUsername(aUsername, aCreate) {
-        // If the username contains no @, assume @gmail.com
-        // XXX Maybe use accountType=GOOGLE and just pass the raw username?
-        if (aUsername.indexOf('@') == -1) {
-            aUsername += "@gmail.com";
-        }
-
-        // Check if the session exists
-        if (!this.mSessionMap.hasOwnProperty(aUsername)) {
-            if (!aCreate) {
-                return null;
-            }
-            cal.LOG("[calGoogleCalendar] Creating session for: " + aUsername);
-            this.mSessionMap[aUsername] = new calGoogleSession(aUsername);
-        } else {
-            cal.LOG("[calGoogleCalendar] Reusing session for: " + aUsername);
-        }
-
-        // XXX What happens if the username is "toSource" :)
-        return this.mSessionMap[aUsername];
-    }
-};
-
-/**
- * calGoogleSession
- * This Implements a Session object to communicate with google
- *
- * @constructor
- * @class
- */
-function calGoogleSession(aUsername) {
-    this.mItemQueue = new Array();
-    this.mGoogleUser = aUsername;
-    this.wrappedJSObject = this;
-
-    // Register a freebusy provider for this session
-    getFreeBusyService().addProvider(this);
-}
-const calGoogleSessionClassID = Components.ID("{652f6233-e03f-438a-bd3b-39877f68c0f4}");
-const calGoogleSessionInterfaces = [Components.interfaces.calIGoogleSession];
-calGoogleSession.prototype = {
-    classID: calGoogleSessionClassID,
-    QueryInterface: XPCOMUtils.generateQI(calGoogleSessionInterfaces),
-    classInfo: XPCOMUtils.generateCI({
-        classID: calGoogleSessionClassID,
-        contractID: "@mozilla.org/calendar/providers/gdata/session;1",
-        classDescription: "Google Calendar Session",
-        interfaces: calGoogleSessionInterfaces
-    }),
-
-    /* Member Variables */
-    mGoogleUser: null,
-    // This must be |undefined|, we need this variable to be tri-state.
-    mGooglePass: undefined,
-    mGoogleFullName: null,
-    mAuthToken: null,
-    mSessionID: null,
-
-    mLoggingIn: false,
-    mPersistPassword: false,
-    mItemQueue: null,
-
-    mCalendarName: null,
-
-    /**
-     * readonly attribute authToken
-     *
-     * The auth token returned from Google Accounts
-     */
-    get authToken() {
-        return this.mAuthToken;
-    },
-
-    /**
-     * readonly attribute userName
-     *
-     * The username for this session. To get a session with a different
-     * username, use calIGoogleSessionManager.
-     */
-    get userName() {
-        return this.mGoogleUser;
-    },
-
-    /**
-     * attribute persist
-     *
-     * If set, the password will persist across restarts.
-     */
-    get persist() {
-        return this.mPersistPassword;
-    },
-    set persist(v) {
-        return this.mPersistPassword = v;
-    },
-
-    /**
-     * attribute AUTF8String fullName
-     *
-     * The user's full name, usually retrieved from the XML <author> fields.
-     */
-    get fullName() {
-        return this.mGoogleFullName;
-    },
-    set fullName(v) {
-        return this.mGoogleFullName = v;
-    },
-
-    /**
-     * attribute AUTF8String password
-     *
-     * The password used to authenticate. It is only important to implement the
-     * setter here, since the password is only used internally.
-     */
-    get password() {
-        return this.mGooglePass;
-    },
-    set password(v) {
-        return this.mGooglePass = v;
-    },
-
-    /**
-     * invalidate
-     * Resets the Auth token and password.
-     */
-    invalidate: function cGS_invalidate() {
-        this.mAuthToken = null;
-        this.mGooglePass = null;
-        this.persist = false;
-
-        passwordManagerRemove(this.mGoogleUser);
-    },
-
-    getCalendars: function cGS_getCalendars(aListener) {
-        throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
-    },
-
-    /**
-     * failQueue
-     * Fails all requests in this session's queue. Optionally only fail requests
-     * for a certain calendar
-     *
-     * @param aCode     Failure Code
-     * @param aCalendar The calendar to fail for. Can be null.
-     */
-    failQueue: function cGS_failQueue(aCode, aCalendar) {
-        function cGS_failQueue_failInQueue(element, index, arr) {
-            if (!aCalendar || (aCalendar && element.calendar == aCalendar)) {
-                element.fail(aCode, null);
-                return false;
-
-            }
-            return true;
-        }
-
-        this.mItemQueue = this.mItemQueue.filter(cGS_failQueue_failInQueue);
-    },
-
-    /**
-     * loginAndContinue
-     * Prepares a login request, then requests via #asyncRawRequest
-     *
-     *
-     * @param aCalendar    The calendar of the request that initiated the login.
-     */
-    loginAndContinue: function cGS_loginAndContinue(aCalendar) {
-        if (this.mLoggingIn) {
-            cal.LOG("[calGoogleCalendar] loginAndContinue called while logging in");
-            return;
-        }
-        try {
-            cal.LOG("[calGoogleCalendar] Logging in to " + this.mGoogleUser);
-
-            // We need to have a user and should not be logging in
-            ASSERT(!this.mLoggingIn);
-            ASSERT(this.mGoogleUser);
-
-            // Start logging in
-            this.mLoggingIn = true;
-
-            if (this.mGooglePass === undefined) {
-                // This happens only on the first run. Try to get the password
-                // from the password manager.
-                let password = {};
-                passwordManagerGet(this.mGoogleUser, password);
-                if (password.value) {
-                    cal.LOG("Retrieved Password for " + this.mGoogleUser +
-                            " from password manager");
-                    this.mPersistPassword = true;
-                    this.mGooglePass = password.value;
-                } else {
-                    // Could not get the password from the password manager, set
-                    // it to null to make sure the password is prompted for in
-                    // the next block.
-                    this.mGooglePass = null;
-                }
-            }
-
-            // Check if we have a password. If not, authentication may have
-            // failed.
-            if (!this.mGooglePass) {
-                let username = { value: this.mGoogleUser };
-                let password = { value: null };
-                let persist = { value: false };
-
-                // Try getting a new password, potentially switching sesssions.
-                let calendarName = (aCalendar ?
-                                    aCalendar.googleCalendarName :
-                                    this.mGoogleUser);
-
-                if (getCalendarCredentials(calendarName,
-                                           username,
-                                           password,
-                                           persist)) {
-
-                    cal.LOG("[calGoogleCalendar] Got the pw from the calendar credentials: " +
-                            calendarName);
-
-                    // If a different username was entered, switch sessions
-
-                    if (aCalendar && username.value != this.mGoogleUser) {
-                        let newSession = getGoogleSessionManager()
-                                         .getSessionByUsername(username.value,
-                                                               true);
-                        newSession.password = password.value;
-                        newSession.persist = persist.value;
-                        setCalendarPref(aCalendar,
-                                        "googleUser",
-                                        "CHAR",
-                                        username.value);
-
-                        // Set the new session for the calendar
-                        aCalendar.session = newSession;
-                        cal.LOG("[calGoogleCalendar] Setting " + aCalendar.name +
-                                "'s Session to " + newSession.userName);
-
-                        // Move all requests by this calendar to its new session
-                        function cGS_login_moveToSession(element, index, arr) {
-                            if (element.calendar == aCalendar) {
-                                cal.LOG("[calGoogleCalendar] Moving " + element.uri + " to " +
-                                        newSession.userName);
-                                newSession.asyncItemRequest(element);
-                                return false;
-                            }
-                            return true;
-                        }
-                        this.mItemQueue = this.mItemQueue
-                                          .filter(cGS_login_moveToSession);
-
-                        // Do not complete the request here, since it has been
-                        // moved. This is not an error though, so nothing is
-                        // thrown.
-                        return;
-                    }
-
-                    // If we arrive at this point, then the session was not
-                    // changed. Just adapt the password from the dialog and
-                    // continue.
-                    this.mGooglePass = password.value;
-                    this.persist = persist.value;
-                } else {
-                    cal.LOG("[calGoogleCalendar] Could not get any credentials for " +
-                            calendarName + " (" +
-                            this.mGoogleUser + ")");
-
-                    if (aCalendar) {
-                        // First of all, disable the calendar so no further login
-                        // dialogs show up.
-                        aCalendar.setProperty("disabled", true);
-                        aCalendar.setProperty("auto-enabled", true);
-
-                        // Unset the session in the requesting calendar, if the user
-                        // canceled the login dialog that also asks for the
-                        // username, then the session is not valid. This also
-                        // prevents multiple login windows.
-                        aCalendar.session = null;
-                    }
-
-                    // We are done logging in
-                    this.mLoggingIn = false;
-
-                    // The User even canceled the login prompt asking for
-                    // the user. This means we have to fail all requests
-                    // that belong to that calendar and are in the queue. This
-                    // will also include the request that initiated the login
-                    // request, so that dosent need to be handled extra. If no
-                    // calendar was passed, fail all request in that queue
-                    this.failQueue(Components.results.NS_ERROR_NOT_AVAILABLE,
-                                   aCalendar);
-                    return;
-                }
-            }
-
-            // Now we should have a password
-            ASSERT(this.mGooglePass);
-
-            // Get Version info
-            let source = Services.appinfo.vendor + "-" +
-                         Services.appinfo.name + "-" +
-                         Services.appinfo.version;
-
-            // Request Login
-            let request = new calGoogleRequest(this);
-
-            request.type = request.LOGIN;
-            request.calendar = aCalendar;
-            request.responseListener = this;
-
-            request.setUploadData("application/x-www-form-urlencoded",
-                                  "Email=" + encodeURIComponent(this.mGoogleUser) +
-                                  "&Passwd=" + encodeURIComponent(this.mGooglePass) +
-                                  "&accountType=HOSTED_OR_GOOGLE" +
-                                  "&source=" + encodeURIComponent(source) +
-                                  "&service=cl");
-            this.asyncRawRequest(request);
-        } catch (e) {
-            // If something went wrong, reset the login state just in case
-            this.mLoggingIn = false;
-            cal.LOG("[calGoogleCalendar] Error Logging In: " + e);
-
-            // If something went wrong, then this.loginComplete should handle
-            // the error. We don't need to take care of the request that
-            // initiated the login, since it is also in the item queue.
-            this.onResult({ status: e.result}, e.message);
-        }
-    },
-
-    /**
-     * onResult (loginComplete)
-     * Callback function that is called when the login request to Google
-     * Accounts has finished
-     *  - Retrieves the Authentication Token
-     *  - Saves the Password in the Password Manager
-     *  - Processes the Item Queue
-     *
-     * @private
-     * @param aOperation    The calIOperation that initiated the login
-     * @param aData         The (String) Result of the Request
-     *                      (or an Error Message)
-     */
-     onResult: function cGS_onResult(aOperation, aData) {
-        // About mLoggingIn: this should only be set to false when either
-        // something went wrong or mAuthToken is set. This avoids redundant
-        // logins to Google. Hence mLoggingIn is set three times in the course
-        // of this function
-
-        if (!aData || !Components.isSuccessCode(aOperation.status)) {
-            this.mLoggingIn = false;
-            cal.LOG("[calGoogleCalendar] Login failed. Status: " + aOperation.status);
-
-            if (aOperation.status == kGOOGLE_LOGIN_FAILED &&
-                aOperation.reauthenticate) {
-                // If the login failed, then retry the login. This is not an
-                // error that should trigger failing the calICalendar's request.
-                this.loginAndContinue(aOperation.calendar);
-            } else {
-                cal.LOG("[calGoogleCalendar] Failing queue with " + aOperation.status);
-                this.failQueue(aOperation.status);
-            }
-        } else {
-            let start = aData.indexOf("Auth=");
-            if (start == -1) {
-                // The Auth token could not be extracted
-                this.mLoggingIn = false;
-                this.invalidate();
-
-                // Retry login
-                this.loginAndContinue(aOperation.calendar);
-            } else {
-                this.mAuthToken = aData.substring(start + 5, aData.length - 1);
-
-                this.mLoggingIn = false;
-
-                if (this.persist) {
-                    try {
-                        passwordManagerSave(this.mGoogleUser,
-                                            this.mGooglePass);
-                    } catch (e) {
-                        // This error is non-fatal, but would constrict
-                        // functionality
-                        cal.LOG("[calGoogleCalendar] Error adding password to manager");
-                    }
-                }
-
-                // Process Items that were requested while logging in
-                let request;
-                // Extra parentheses to avoid js strict warning.
-                while ((request = this.mItemQueue.shift())) {
-                    cal.LOG("[calGoogleCalendar] Processing Queue Item: " + request.uri);
-                    request.commit(this);
-                }
-            }
-        }
-    },
-
-    /**
-     * asyncItemRequest
-     * get or post an Item from or to Google using the Queue.
-     *
-     * @param aRequest          The Request Object. This is an instance of
-     *                          calGoogleRequest
-     */
-    asyncItemRequest: function cGS_asyncItemRequest(aRequest) {
-
-        if (!this.mLoggingIn && this.mAuthToken) {
-            // We are not currently logging in and we have an auth token, so
-            // directly try the login request
-            this.asyncRawRequest(aRequest);
-        } else {
-            // Push the request in the queue to be executed later
-            this.mItemQueue.push(aRequest);
-
-            cal.LOG("[calGoogleCalendar] Adding item " + aRequest.uri + " to queue");
-
-            // If we are logging in, then we are done since the passed request
-            // will be processed when the login is complete. Otherwise start
-            // logging in.
-            if (!this.mLoggingIn && this.mAuthToken == null) {
-                // We need to do this on a timeout, otherwise the UI thread will
-                // block when the password prompt is shown.
-                setTimeout(function() {
-                    this.loginAndContinue(aRequest.calendar);
-                }, 0, this);
-            }
-        }
-    },
-
-    /**
-     * asyncRawRequest
-     * get or post an Item from or to Google without the Queue.
-     *
-     * @param aRequest          The Request Object. This is an instance of
-     *                          calGoogleRequest
-     */
-    asyncRawRequest: function cGS_asyncRawRequest(aRequest) {
-        // Request is handled by an instance of the calGoogleRequest
-        // We don't need to keep track of these requests, they
-        // pass to a listener or just die
-
-        ASSERT(aRequest);
-        aRequest.commit(this);
-    },
-
-    /**
-     * calIFreeBusyProvider Implementation
-     */
-    getFreeBusyIntervals: function cGS_getFreeBusyIntervals(aCalId,
-                                                            aRangeStart,
-                                                            aRangeEnd,
-                                                            aBusyTypes,
-                                                            aListener) {
-        if (aCalId.indexOf("@") < 0 || aCalId.indexOf(".") < 0) {
-            // No valid email, screw it
-            aListener.onResult(null, null);
-            return null;
-        }
-
-        // Requesting only a DATE returns items based on UTC. Therefore, we make
-        // sure both start and end dates include a time and timezone. This may
-        // not quite be what was requested, but I'd say its a shortcoming of
-        // rfc3339.
-        if (aRangeStart) {
-            aRangeStart = aRangeStart.clone();
-            aRangeStart.isDate = false;
-        }
-        if (aRangeEnd) {
-            aRangeEnd = aRangeEnd.clone();
-            aRangeEnd.isDate = false;
-        }
-
-        let rfcRangeStart = cal.toRFC3339(aRangeStart);
-        let rfcRangeEnd = cal.toRFC3339(aRangeEnd);
-
-        let request = new calGoogleRequest(this);
-
-        request.type = request.GET;
-        request.uri = "https://www.google.com/calendar/feeds/" +
-                      encodeURIComponent(aCalId.replace(/^mailto:/i, "")) +
-                      "/private/free-busy";
-        request.operationListener = aListener;
-        request.itemRangeStart = aRangeStart;
-        request.itemRangeEnd = aRangeEnd;
-        request.reauthenticate = false;
-
-        // Request Parameters
-        request.addQueryParameter("ctz", calendarDefaultTimezone().tzid);
-        request.addQueryParameter("max-results", kMANY_EVENTS);
-        request.addQueryParameter("singleevents", "true");
-        request.addQueryParameter("start-min", rfcRangeStart);
-        request.addQueryParameter("start-max", rfcRangeEnd);
-
-        let session = this;
-        request.responseListener = {
-            onResult: function cGS_getFreeBusyIntervals_onResult(aOperation, aData) {
-                session.getFreeBusyIntervals_response(aOperation,
-                                                      aData,
-                                                      aCalId,
-                                                      aRangeStart,
-                                                      aRangeEnd);
-            }
-        };
-
-        this.asyncItemRequest(request);
-        return request;
-    },
-
-    getFreeBusyIntervals_response: function getFreeBusyIntervals_response(aOperation,
-                                                                          aData,
-                                                                          aCalId,
-                                                                          aRangeStart,
-                                                                          aRangeEnd) {
-        // Prepare Namespaces
-        if (aOperation.status == kGOOGLE_LOGIN_FAILED ||
-            !Components.isSuccessCode(aOperation.status)) {
-            aOperation.operationListener.onResult(aOperation, null);
-            return;
-        }
-
-        // A feed was passed back, parse it.
-        let xml = cal.xml.parseString(aData);
-        let timezoneString = gdataXPathFirst(xml, 'atom:feed/gCal:timezone/@value') || "UTC";
-        let timezone = gdataTimezoneService.getTimezone(timezoneString);
-
-        let intervals = [];
-        const fbtypes = Components.interfaces.calIFreeBusyInterval;
-        for each (let entry in gdataXPath(xml, 'atom:feed/atom:entry')) {
-            let start = cal.fromRFC3339(gdataXPathFirst(entry, 'gd:when/@startTime'), timezone);
-            let end = cal.fromRFC3339(gdataXPathFirst(entry, 'gd:when/@endTime'), timezone);
-            let interval = new cal.FreeBusyInterval(aCalId, fbtypes.BUSY, start, end);
-            LOGinterval(interval);
-            intervals.push(interval);
-        }
-
-        aOperation.operationListener.onResult(aOperation, intervals);
-    }
-};
diff --git a/calendar/providers/gdata/components/calGoogleUtils.js b/calendar/providers/gdata/components/calGoogleUtils.js
deleted file mode 100644
index 24d7744..0000000
--- a/calendar/providers/gdata/components/calGoogleUtils.js
+++ /dev/null
@@ -1,1312 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-Components.utils.import("resource://calendar/modules/calUtils.jsm");
-Components.utils.import("resource://calendar/modules/calXMLUtils.jsm");
-Components.utils.import("resource://calendar/modules/calIteratorUtils.jsm");
-Components.utils.import("resource://calendar/modules/calProviderUtils.jsm");
-Components.utils.import("resource://gre/modules/Preferences.jsm");
-
-const atomNS = "http://www.w3.org/2005/Atom";
-const gdNS = "http://schemas.google.com/g/2005";
-const gcalNS = "http://schemas.google.com/gCal/2005";
-
-function gdataNSResolver(prefix) {
-    const ns = {
-        atom: atomNS,
-        gd: gdNS,
-        gCal: gcalNS
-    };
-
-    return ns[prefix] || atomNS;
-}
-
-function gdataXPath(aNode, aExpr, aType) {
-    return cal.xml.evalXPath(aNode, aExpr, gdataNSResolver, aType);
-}
-function gdataXPathFirst(aNode, aExpr, aType) {
-    // Different than the caldav/ics functions, this one will return an empty string on null
-    return cal.xml.evalXPathFirst(aNode, aExpr, gdataNSResolver, aType) || "";
-}
-
-/**
- * getGoogleSessionManager
- * Shortcut to the google session manager
- */
-function getGoogleSessionManager() {
-    if (this.mObject === undefined) {
-        this.mObject =
-            Components.classes["@mozilla.org/calendar/providers/gdata/session-manager;1"]
-                      .createInstance(Components.interfaces.calIGoogleSessionManager);
-    }
-    return this.mObject;
-}
-
-/**
- * setCalendarPref
- * Helper to set an independant Calendar Preference, since I cannot use the
- * calendar manager because of early initialization Problems.
- *
- * @param aCalendar     The Calendar to set the pref for
- * @param aPrefName     The Preference name
- * @param aPrefType     The type of the preference ("BOOL", "INT", "CHAR")
- * @param aPrefValue    The Preference value
- *
- * @return              The value of aPrefValue
- *
- * @require aCalendar.googleCalendarName
- */
-function setCalendarPref(aCalendar, aPrefName, aPrefType, aPrefValue) {
-
-    Preferences.set("calendar.google.calPrefs." + aCalendar.googleCalendarName + "." +
-                    aPrefName, aPrefValue, aPrefType);
-
-    return aPrefValue;
-}
-
-/**
- * getCalendarPref
- * Helper to get an independant Calendar Preference, since I cannot use the
- * calendar manager because of early initialization Problems.
- *
- * @param aCalendar     The calendar to set the pref for
- * @param aPrefName     The preference name
- *
- * @return              The preference value
- *
- * @require aCalendar.googleCalendarName
- */
-function getCalendarPref(aCalendar, aPrefName) {
-    return Preferences.get("calendar.google.calPrefs." +
-                           aCalendar.googleCalendarName + "."  + aPrefName);
-}
-
-/**
- * getFormattedString
- * Returns the string from the properties file, formatted with args
- *
- * @param aBundleName   The .properties file to access
- * @param aStringName   The property to access
- * @param aFormatArgs   An array of arguments to format the string
- * @param aComponent    Optionally, the stringbundle component name
- * @return              The formatted string
- */
-function getFormattedString(aBundleName, aStringName, aFormatArgs, aComponent) {
-    return calGetString(aBundleName, aStringName, aFormatArgs, aComponent || "gdata-provider");
-}
-
-/**
- * getCalendarCredentials
- * Tries to get the username/password combination of a specific calendar name
- * from the password manager or asks the user.
- *
- * @param   in  aCalendarName   The calendar name to look up. Can be null.
- * @param   out aUsername       The username that belongs to the calendar.
- * @param   out aPassword       The password that belongs to the calendar.
- * @param   out aSavePassword   Should the password be saved?
- * @return  Could a password be retrieved?
- */
-function getCalendarCredentials(aCalendarName,
-                                aUsername,
-                                aPassword,
-                                aSavePassword) {
-    return cal.auth.getCredentials(getFormattedString("gdata", "loginDialogTitle"),
-                                   aCalendarName,
-                                   aUsername,
-                                   aPassword,
-                                   aSavePassword);
-}
-
-/**
- * Gets the date and time that Google's http server last sent us. Note the
- * passed argument is modified. This might not be the exact server time (i.e it
- * may be off by network latency), but it does give a good guess when syncing.
- *
- * @param aDate     The date to modify
- */
-function getCorrectedDate(aDate) {
-
-    if (!getCorrectedDate.mClockSkew) {
-        return aDate;
-    }
-
-    aDate.second += getCorrectedDate.mClockSkew;
-    return aDate;
-}
-
-/**
- * The timezone service to translate Google timezones.
- */
-var gdataTimezoneService = {
-    ctz: cal.getTimezoneService(),
-
-    get floating() {
-        return this.ctz.floating;
-    },
-
-    get UTC() {
-        return this.ctz.UTC;
-    },
-
-    get version() {
-        return this.ctz.version;
-    },
-
-    get defaultTimezone() {
-        return this.ctz.defaultTimezone;
-    },
-
-    getTimezone: function gTS_getTimezone(aTzid) {
-        if (aTzid == "Etc/GMT") {
-            // Most timezones are covered by the timezone service, there is one
-            // exception I've found out about. GMT without DST is pretty close
-            // to UTC, lets take it.
-            return UTC();
-        }
-
-        let baseTZ = this.ctz.getTimezone(aTzid);
-        ASSERT(baseTZ, "Unknown Timezone requested: " + aTzid);
-        return baseTZ;
-    }
-};
-
-/**
- * passwordManagerSave
- * Helper to insert an entry to the password manager.
- *
- * @param aUserName     The username to search
- * @param aPassword     The corresponding password
- */
-function passwordManagerSave(aUsername, aPassword) {
-    cal.auth.passwordManagerSave(aUsername, aPassword, aUsername, "Google Calendar");
-}
-
-/**
- * passwordManagerGet
- * Helper to retrieve an entry from the password manager
- *
- * @param in  aUsername     The username to search
- * @param out aPassword     The corresponding password
- * @return                  Does an entry exist in the password manager
- */
-function passwordManagerGet(aUsername, aPassword) {
-    return cal.auth.passwordManagerGet(aUsername, aPassword, aUsername, "Google Calendar");
-}
-
-/**
- * passwordManagerRemove
- * Helper to remove an entry from the password manager
- *
- * @param aUsername     The username to remove.
- * @return              Could the user be removed?
- */
-function passwordManagerRemove(aUsername) {
-    return cal.auth.passwordManagerRemove(aUsername, aUsername, "Google Calendar");
-}
-
-/**
- * If the operation has signaled that a conflict occurred, then prompt the user
- * to overwrite. If the user chooses to overwrite, restart the request with the
- * right parameters so the request succeeds.
- *
- * @param aOperation        The operation to check
- * @param aItem             The updated item from the response
- * @return                  False if further processing should be cancelled
- */
-function resolveConflicts(aOperation, aItem) {
-    if (aItem && (aOperation.status == kGOOGLE_CONFLICT_DELETED ||
-                  aOperation.status == kGOOGLE_CONFLICT_MODIFY)) {
-        if (aItem == "SEQUENCE-HACK") {
-            // Working around a Google issue here, see what happens on a 400
-            // code in calGoogleRequest.js. This will cause a new request
-            // without the sequence number. In return, we get a new item with
-            // the correct sequence number.
-            let newItem =  aOperation.newItem.clone();
-            let session = aOperation.calendar.session;
-            newItem.deleteProperty("SEQUENCE");
-            let xmlEntry = ItemToXMLEntry(newItem, aOperation.calendar,
-                                          session.userName, session.fullName);
-
-            aOperation.newItem = newItem;
-            aOperation.setUploadData("application/atom+xml; charset=UTF-8", cal.xml.serializeDOM(xmlEntry));
-            session.asyncItemRequest(aOperation);
-            return false;
-        } else if (aOperation.status == kGOOGLE_CONFLICT_DELETED &&
-                   aOperation.type == aOperation.DELETE) {
-            // Deleted on the server and deleted locally. Great!
-            return true;
-        } else {
-            // If a conflict occurred, then prompt
-            let method = (aOperation.type == aOperation.DELETE ? "delete" : "modify")
-            let inputItem = aOperation.oldItem || aOperation.newItem;
-            let overwrite = cal.promptOverwrite(method, inputItem);
-            if (overwrite) {
-                if (aOperation.status == kGOOGLE_CONFLICT_DELETED &&
-                    aOperation.type == aOperation.MODIFY) {
-                    // The item was deleted on the server, but modified locally.
-                    // Add it again
-                    aOperation.type = aOperation.ADD;
-                    aOperation.uri = aOperation.calendar.fullUri.spec;
-                    aOperation.calendar.session.asyncItemRequest(aOperation);
-                    return false;
-                } else if (aOperation.status == kGOOGLE_CONFLICT_MODIFY &&
-                           aOperation.type == aOperation.MODIFY) {
-                    // The item was modified in both places, repeat the current
-                    // request with the edit uri of the updated event
-                    aOperation.uri = getItemEditURI(aItem);
-                    aOperation.calendar.session.asyncItemRequest(aOperation);
-                    return false;
-                } else if (aOperation.status == kGOOGLE_CONFLICT_MODIFY &&
-                           aOperation.type == aOperation.DELETE) {
-                    // Modified on the server, deleted locally. Just repeat the
-                    // delete request with the updated edit uri.
-                    aOperation.uri = getItemEditURI(aItem);
-                    aOperation.calendar.session.asyncItemRequest(aOperation);
-                    return false;
-                }
-            }
-        }
-        // Otherwise, we can just continue using the item that was parsed, it
-        // is the newest version on the server.
-    }
-    return true;
-}
-
-/**
- * Helper function to convert raw data directly into a calIItemBase. If the
- * passed operation signals an error, then throw an exception
- *
- * @param aOperation        The operation to check for errors
- * @param aData             The result from the response
- * @param aGoogleCalendar   The calIGoogleCalendar to operate on
- * @param aReferenceItem    The reference item to apply the information to
- * @return                  The parsed item
- * @throws                  An exception on a parsing or request error
- */
-function DataToItem(aOperation, aData, aGoogleCalendar, aReferenceItem) {
-    if (aOperation.status == kGOOGLE_CONFLICT_DELETED ||
-        aOperation.status == kGOOGLE_CONFLICT_MODIFY ||
-        Components.isSuccessCode(aOperation.status)) {
-
-        let item;
-        if (aData == "SEQUENCE-HACK") {
-            // Working around a Google issue here, see what happens on a 400
-            // code in calGoogleRequest.js. This will be processed in
-            // resolveConflicts().
-            return "SEQUENCE-HACK";
-        }
-
-        if (aData && aData.length) {
-            let xml = cal.xml.parseString(aData);
-            cal.LOG("[calGoogleCalendar] Parsing entry:\n" + aData + "\n");
-
-            // Get the local timezone from the preferences
-            let timezone = calendarDefaultTimezone();
-
-            // Parse the Item with the given timezone
-            item = XMLEntryToItem(xml.documentElement, timezone,
-                                  aGoogleCalendar,
-                                  aReferenceItem);
-        } else {
-            cal.LOG("[calGoogleCalendar] No content, using reference item instead ");
-            // No data happens for example on delete. Just assume the reference
-            // item.
-            item = aReferenceItem.clone();
-        }
-
-        LOGitem(item);
-        item.calendar = aGoogleCalendar.superCalendar;
-        return item;
-    } else {
-        throw new Components.Exception(aData, aOperation.status);
-    }
-}
-
-/**
- * ItemToXMLEntry
- * Converts a calIEvent to a string of xml data.
- *
- * @param aItem         The item to convert
- * @param aCalendar     The calendar to use, this must be a calIGoogleCalendar
- * @param aAuthorEmail  The email of the author of the event
- * @param aAuthorName   The full name of the author of the event
- * @return              The xml data of the item
- */
-function ItemToXMLEntry(aItem, aCalendar, aAuthorEmail, aAuthorName) {
-    let selfIsOrganizer = (!aItem.organizer ||
-                            aItem.organizer.id == "mailto:" + aCalendar.googleCalendarName);
-
-    function addExtendedProperty(aName, aValue) {
-        if (!selfIsOrganizer || !aValue) {
-            // We can't set extended properties if we are not the organizer,
-            // discard. Also, if the value is null/false, we can delete the
-            // extended property by not adding it.
-            return;
-        }
-        let gdExtendedProp = document.createElementNS(gdNS, "extendedProperty");
-        gdExtendedProp.setAttribute("name", aName);
-        gdExtendedProp.setAttribute("value", aValue || "");
-        entry.appendChild(gdExtendedProp);
-    }
-
-    if (!aItem) {
-        throw new Components.Exception("", Components.results.NS_ERROR_INVALID_ARG);
-    }
-
-    const kEVENT_SCHEMA = "http://schemas.google.com/g/2005#event.";
-
-    // Document creation
-    let document = cal.xml.parseString('<entry xmlns="' + atomNS + '" xmlns:gd="' + gdNS + '" xmlns:gCal="' + gcalNS + '"/>');
-    let entry = document.documentElement;
-
-    // Helper functions
-    function elemNS(ns, name) document.createElementNS(ns, name);
-    function addElemNS(ns, name, parent) (parent || entry).appendChild(elemNS(ns, name));
-
-    // Basic elements
-    let kindElement = addElemNS(atomNS, "category");
-    kindElement.setAttribute("scheme", "http://schemas.google.com/g/2005#kind");
-    kindElement.setAttribute("term", "http://schemas.google.com/g/2005#event");
-
-    let titleElement = addElemNS(atomNS, "title");
-    titleElement.setAttribute("type", "text");
-    titleElement.textContent = aItem.title;
-
-    // atom:content
-    let contentElement = addElemNS(atomNS, "content");
-    contentElement.setAttribute("type", "text");
-    contentElement.textContent = aItem.getProperty("DESCRIPTION") || "";
-
-    // atom:author
-    let authorElement = addElemNS(atomNS, "author");
-    addElemNS(atomNS, "name", authorElement).textContent = aAuthorName || aAuthorEmail;
-    addElemNS(atomNS, "email", authorElement).textContent = aAuthorEmail;
-
-    // gd:transparency
-    let transpElement = addElemNS(gdNS, "transparency");
-    let transpValue = aItem.getProperty("TRANSP") || "opaque";
-    transpElement.setAttribute("value", kEVENT_SCHEMA + transpValue.toLowerCase());
-
-    // gd:eventStatus
-    let status = aItem.status || "confirmed";
-    if (status == "CANCELLED") {
-        // If the status is canceled, then the event will be deleted. Since the
-        // user didn't choose to delete the event, we will protect him and not
-        // allow this status to be set
-        throw new Components.Exception("",
-                                       Components.results.NS_ERROR_LOSS_OF_SIGNIFICANT_DATA);
-    } else if (status == "NONE") {
-        status = "CONFIRMED";
-    }
-    addElemNS(gdNS, "eventStatus").setAttribute("value", kEVENT_SCHEMA + status.toLowerCase());
-
-    // gd:where
-    addElemNS(gdNS, "where").setAttribute("valueString", aItem.getProperty("LOCATION") || "");
-
-    // gd:who
-    if (Preferences.get("calendar.google.enableAttendees", false)) {
-        // XXX Only parse attendees if they are enabled, due to bug 407961
-
-        let attendees = aItem.getAttendees({});
-        if (aItem.organizer) {
-            // Taking care of the organizer is the same as taking care of any other
-            // attendee. Add the organizer to the local attendees list.
-            attendees.push(aItem.organizer);
-        }
-
-        const attendeeStatusMap = {
-            "REQ-PARTICIPANT": "required",
-            "OPT-PARTICIPANT": "optional",
-            "NON-PARTICIPANT": null,
-            "CHAIR": null,
-
-            "NEEDS-ACTION": "invited",
-            "ACCEPTED": "accepted",
-            "DECLINED": "declined",
-            "TENTATIVE": "tentative",
-            "DELEGATED": "tentative"
-        };
-
-        for each (let attendee in attendees) {
-            if (attendee.userType && attendee.userType != "INDIVIDUAL") {
-                // We can only take care of individuals.
-                continue;
-            }
-
-            let xmlAttendee = addElemNS(gdNS, "who");
-
-            // Strip "mailto:" part
-            xmlAttendee.setAttribute("email", attendee.id.replace(/^mailto:/, ""));
-
-            if (attendee.isOrganizer) {
-                xmlAttendee.setAttribute("rel", kEVENT_SCHEMA + "organizer");
-            } else {
-                xmlAttendee.setAttribute("rel", kEVENT_SCHEMA + "attendee");
-            }
-
-            if (attendee.commonName) {
-                xmlAttendee.setAttribute("valueString", attendee.commonName);
-            }
-
-            if (attendeeStatusMap[attendee.role]) {
-                let attendeeTypeElement = addElemNS(gdNS, "attendeeType", xmlAttendee);
-                let attendeeTypeValue = kEVENT_SCHEMA + attendeeStatusMap[attendee.role];
-                attendeeTypeElement.setAttribute("value", attendeeTypeValue);
-            }
-
-            if (attendeeStatusMap[attendee.participationStatus]) {
-                let attendeeStatusElement = addElemNS(gdNS, "attendeeStatus", xmlAttendee);
-                let attendeeStatusValue = kEVENT_SCHEMA + attendeeStatusMap[attendee.participationStatus];
-                attendeeStatusElement.setAttribute("value", attendeeStatusValue);
-            }
-        }
-    }
-
-    // Don't notify attendees by default. Use a preference in case the user
-    // wants this to be turned on.
-    let notify = Preferences.get("calendar.google.sendEventNotifications", false);
-    addElemNS(gcalNS, "sendEventNotifications").setAttribute("value", notify ? "true" : "false");
-
-    // gd:when
-    let duration = aItem.endDate.subtractDate(aItem.startDate);
-    let whenElement;
-    if (!aItem.recurrenceInfo) {
-        // gd:when isn't allowed for recurring items where gd:recurrence is set
-        whenElement = addElemNS(gdNS, "when");
-        whenElement.setAttribute("startTime", cal.toRFC3339(aItem.startDate));
-        whenElement.setAttribute("endTime", cal.toRFC3339(aItem.endDate));
-    }
-
-    // gd:reminder
-    let alarms = aItem.getAlarms({});
-    let actionMap = {
-        DISPLAY: "alert",
-        EMAIL: "email",
-        SMS: "sms"
-    };
-    if (selfIsOrganizer) {
-        for (let i = 0; i < 5 && i < alarms.length; i++) {
-            let alarm = alarms[i];
-            let gdReminder;
-            if (aItem.recurrenceInfo) {
-                // On recurring items, set the reminder directly in the <entry> tag.
-                gdReminder = addElemNS(gdNS, "reminder");
-            } else {
-                // Otherwise, its a child of the gd:when element
-                gdReminder = addElemNS(gdNS, "reminder", whenElement);
-            }
-            if (alarm.related == alarm.ALARM_RELATED_ABSOLUTE) {
-                // Setting an absolute date can be done directly. Google will take
-                // care of calculating the offset.
-                gdReminder.setAttribute("absoluteTime", cal.toRFC3339(alarm.alarmDate));
-            } else {
-                let alarmOffset = alarm.offset;
-                if (alarm.related == alarm.ALARM_RELATED_END) {
-                    // Google always uses an alarm offset related to the start time
-                    // for relative alarms.
-                    alarmOffset = alarmOffset.clone();
-                    alarmOffset.addDuration(duration);
-                }
-
-                gdReminder.setAttribute("minutes", -alarmOffset.inSeconds / 60);
-                gdReminder.setAttribute("method", actionMap[alarm.action] || "alert");
-            }
-        }
-    } else if (alarms.length) {
-        // We need to reset this so the item gets returned correctly.
-        aItem.clearAlarms();
-    }
-
-    // gd:extendedProperty (alarmLastAck)
-    addExtendedProperty("X-MOZ-LASTACK", cal.toRFC3339(aItem.alarmLastAck));
-
-    // XXX While Google now supports multiple alarms and alarm values, we still
-    // need to fix bug 353492 first so we can better take care of finding out
-    // what alarm is used for snoozing.
-
-    // gd:extendedProperty (snooze time)
-    let itemSnoozeTime = aItem.getProperty("X-MOZ-SNOOZE-TIME");
-    let icalSnoozeTime = null;
-    if (itemSnoozeTime) {
-        // The propery is saved as a string, translate back to calIDateTime.
-        icalSnoozeTime = cal.createDateTime();
-        icalSnoozeTime.icalString = itemSnoozeTime;
-    }
-    addExtendedProperty("X-MOZ-SNOOZE-TIME", cal.toRFC3339(icalSnoozeTime));
-
-    // gd:extendedProperty (snooze recurring alarms)
-    let snoozeValue = "";
-    if (aItem.recurrenceInfo) {
-        // This is an evil workaround since we don't have a really good system
-        // to save the snooze time for recurring alarms or even retrieve them
-        // from the event. This should change when we have multiple alarms
-        // support.
-        let snoozeObj = {};
-        let enumerator = aItem.propertyEnumerator;
-        while (enumerator.hasMoreElements()) {
-            let prop = enumerator.getNext().QueryInterface(Components.interfaces.nsIProperty);
-            if (prop.name.substr(0, 18) == "X-MOZ-SNOOZE-TIME-") {
-                // We have a snooze time for a recurring event, add it to our object
-                snoozeObj[prop.name.substr(18)] = prop.value;
-            }
-        }
-        snoozeValue = JSON.stringify(snoozeObj);
-    }
-    // Now save the snooze object in source format as an extended property. Do
-    // so always, since its currently impossible to unset extended properties.
-    addExtendedProperty("X-GOOGLE-SNOOZE-RECUR", snoozeValue);
-
-    // gd:visibility
-    let privacy = aItem.privacy || "default";
-    addElemNS(gdNS, "visibility").setAttribute("value", kEVENT_SCHEMA + privacy.toLowerCase());
-
-    // categories
-    // Google does not support categories natively, but allows us to store data
-    // as an "extendedProperty", so we do here
-    addExtendedProperty("X-MOZ-CATEGORIES",
-                        categoriesArrayToString(aItem.getCategories({})));
-
-    // gd:recurrence
-    if (aItem.recurrenceInfo) {
-        try {
-            const kNEWLINE = "\r\n";
-            let icalString;
-            let recurrenceItems = aItem.recurrenceInfo.getRecurrenceItems({});
-
-            // Dates of the master event
-            let startTZID = aItem.startDate.timezone.tzid;
-            let endTZID = aItem.endDate.timezone.tzid;
-            icalString = "DTSTART;TZID=" + startTZID
-                         + ":" + aItem.startDate.icalString + kNEWLINE
-                         + "DTEND;TZID=" + endTZID
-                         + ":"  + aItem.endDate.icalString + kNEWLINE;
-
-            // Add all recurrence items to the ical string
-            for each (let ritem in recurrenceItems) {
-                let prop = ritem.icalProperty;
-                let wrappedRItem = cal.wrapInstance(wrappedRItem, Components.interfaces.calIRecurrenceDate);
-                if (wrappedRItem) {
-                    // EXDATES require special casing, since they might contain
-                    // a TZID. To avoid the need for conversion of TZID strings,
-                    // convert to UTC before serialization.
-                    prop.valueAsDatetime = wrappedRItem.date.getInTimezone(cal.UTC());
-                }
-                icalString += prop.icalString;
-            }
-
-            // Put the ical string in a <gd:recurrence> tag
-            addElemNS(gdNS, "recurrence").textContent = icalString + kNEWLINE;
-        } catch (e) {
-            cal.ERROR("[calGoogleCalendar] Error: " + e);
-        }
-    }
-
-    // gd:originalEvent
-    if (aItem.recurrenceId) {
-        let originalEvent = addElemNS(gdNS, "originalEvent");
-        originalEvent.setAttribute("id", aItem.parentItem.id);
-
-        let origWhen = addElemNS(gdNS, "when", originalEvent)
-        origWhen.setAttribute("startTime", cal.toRFC3339(aItem.recurrenceId.getInTimezone(cal.UTC())));
-    }
-
-    // While it may sometimes not work out, we can always try to set the uid and
-    // sequence properties
-    let sequence = aItem.getProperty("SEQUENCE");
-    if (sequence) {
-        addElemNS(gcalNS, "sequence").setAttribute("value", sequence);
-    }
-    addElemNS(gcalNS, "uid").setAttribute("value", aItem.id || "");
-
-    // XXX Google currently has no priority support. See
-    // http://code.google.com/p/google-gdata/issues/detail?id=52
-    // for details.
-
-    return document;
-}
-
-/**
- * relevantFieldsMatch
- * Tests if all google supported fields match
- *
- * @param a The reference item
- * @param b The comparing item
- * @return  true if all relevant fields match, otherwise false
- */
-function relevantFieldsMatch(a, b) {
-
-    // flat values
-    if (a.id != b.id ||
-        a.title != b.title ||
-        a.status != b.status ||
-        a.privacy != b.privacy) {
-        return false;
-    }
-
-    function compareNotNull(prop) {
-        let ap = a[prop];
-        let bp = b[prop];
-        return (ap && !bp || !ap && bp ||
-                (typeof(ap) == 'object' && ap && bp &&
-                 ap.compare && ap.compare(bp)));
-    }
-
-    // Object flat values
-    if (compareNotNull("recurrenceInfo") ||
-        compareNotNull("alarmLastAck") ||
-        /* Compare startDate and endDate */
-        compareNotNull("startDate") ||
-        compareNotNull("endDate") ||
-        (a.startDate.isDate != b.startDate.isDate) ||
-        (a.endDate.isDate != b.endDate.isDate)) {
-        return false;
-    }
-
-    // Properties
-    const kPROPERTIES = ["DESCRIPTION", "TRANSP", "X-GOOGLE-EDITURL",
-                         "LOCATION", "X-MOZ-SNOOZE-TIME"];
-
-    for each (let p in kPROPERTIES) {
-        // null and an empty string should be handled as non-relevant
-        if ((a.getProperty(p) || "") != (b.getProperty(p) || "")) {
-            return false;
-        }
-    }
-
-    // categories
-    let aCat = a.getCategories({});
-    let bCat = b.getCategories({});
-    if ((aCat.length != bCat.length) ||
-        aCat.some(function notIn(cat) { return (bCat.indexOf(cat) == -1); })) {
-        return false;
-    }
-
-    // attendees and organzier
-    let aa = a.getAttendees({});
-    let ab = b.getAttendees({});
-    if (aa.length != ab.length) {
-        return false;
-    }
-
-    if ((a.organizer && !b.organizer) ||
-        (!a.organizer && b.organizer) ||
-        (a.organizer && b.organizer && a.organizer.id != b.organizer.id)) {
-        return false;
-    }
-
-    // go through attendees in a, check if its id is in b
-    for each (let attendee in aa) {
-        let ba = b.getAttendeeById(attendee.id);
-        if (!ba ||
-            ba.participationStatus != attendee.participationStatus ||
-            ba.commonName != attendee.commonName ||
-            ba.isOrganizer != attendee.isOrganizer ||
-            ba.role != attendee.role) {
-            return false;
-        }
-    }
-
-    // Alarms
-    aa = a.getAlarms({});
-    ab = b.getAlarms({});
-
-    if (aa.length != ab.length) {
-        return false;
-    }
-
-    let alarmMap = {};
-    for each (let alarm in aa) {
-        alarmMap[alarm.icalString] = true;
-    }
-    let found = 0;
-    for each (let alarm in ab) {
-        if (alarm.icalString in alarmMap) {
-            found++;
-        }
-    }
-
-    if (found != ab.length) {
-        return false;
-    }
-
-    // Recurrence Items
-    if (a.recurrenceInfo) {
-        let ra = a.recurrenceInfo.getRecurrenceItems({});
-        let rb = b.recurrenceInfo.getRecurrenceItems({});
-
-        // If we have more or less, it definitly changed.
-        if (ra.length != rb.length) {
-            return false;
-        }
-
-        // I assume that if the recurrence pattern has not changed, the order
-        // of the recurrence items should not change. Anything more will be
-        // very expensive.
-        for (let i = 0; i < ra.length; i++) {
-            if (ra[i].icalProperty.icalString !=
-                rb[i].icalProperty.icalString) {
-                return false;
-            }
-        }
-    }
-
-    return true;
-}
-
-/**
- * getItemEditURI
- * Helper to get the item's edit URI
- *
- * @param aItem         The item to get it from
- * @return              The edit URI
- */
-function getItemEditURI(aItem) {
-
-    ASSERT(aItem);
-    let edituri = aItem.getProperty("X-GOOGLE-EDITURL");
-    if (!edituri) {
-        // If the item has no edit uri, it is read-only
-        throw new Components.Exception("The item is readonly", Components.interfaces.calIErrors.CAL_IS_READONLY);
-    }
-    return edituri;
-}
-
-function getIdFromEntry(aXMLEntry) {
-    let id = gdataXPathFirst(aXMLEntry, 'gCal:uid/@value');
-    return id.replace(/@google.com/,"");
-}
-
-function getRecurrenceIdFromEntry(aXMLEntry, aTimezone) {
-    let rId = gdataXPathFirst(aXMLEntry, 'gd:originalEvent/gd:when/@startTime');
-    return (rId ? cal.fromRFC3339(rId.toString(), aTimezone) : null);
-}
-
-/**
- * XMLEntryToItem
- * Converts a string of xml data to a calIEvent.
- *
- * @param aXMLEntry         The xml data of the item
- * @param aTimezone         The timezone the event is most likely in
- * @param aCalendar         The calendar this item will belong to. This needs to
- *                              be a calIGoogleCalendar instance.
- * @param aReferenceItem    The item to apply the information from the xml to.
- *                              If null, a new item will be used.
- * @return                  The calIEvent with the item data.
- */
-function XMLEntryToItem(aXMLEntry, aTimezone, aCalendar, aReferenceItem) {
-
-    function getExtendedProperty(x) gdataXPathFirst(aXMLEntry, 'gd:extendedProperty[@name="' + x + '"]/@value');
-
-    if (!aXMLEntry) {
-        throw new Components.Exception("", Components.results.NS_ERROR_FAILURE);
-    } else if (typeof aXMLEntry == "string") {
-        aXMLEntry = cal.xml.parseString(aXMLEntry);
-    }
-
-    let item = (aReferenceItem ? aReferenceItem.clone() : cal.createEvent());
-
-    try {
-        // id
-        item.id = getIdFromEntry(aXMLEntry);
-
-        // sequence
-        item.setProperty("SEQUENCE", gdataXPathFirst(aXMLEntry, 'gCal:sequence/@value') || 0);
-
-        // link (edit url)
-        // Since Google doesn't set the edit url to be https if the request is
-        // https, we need to work around this here.
-        let editUrl = gdataXPathFirst(aXMLEntry, 'atom:link[@rel="edit"]/@href');
-        if (aCalendar.uri.schemeIs("https")) {
-            editUrl = editUrl.replace(/^http:/, "https:");
-        }
-        item.setProperty("X-GOOGLE-EDITURL", editUrl);
-
-        // link (alternative representation, html)
-        let htmlUrl = gdataXPathFirst(aXMLEntry, 'atom:link[@rel="alternate"]/@href');
-        if (aCalendar.uri.schemeIs("https")) {
-            htmlUrl = htmlUrl.replace(/^http:/, "https:");
-        }
-        item.setProperty("URL", htmlUrl);
-
-        // title
-        item.title = gdataXPathFirst(aXMLEntry, 'atom:title[@type="text"]/text()');
-
-        // content
-        item.setProperty("DESCRIPTION", gdataXPathFirst(aXMLEntry, 'atom:content[@type="text"]/text()'));
-
-        // gd:transparency
-        item.setProperty("TRANSP", gdataXPathFirst(aXMLEntry, 'gd:transparency/@value').substring(39).toUpperCase());
-
-        // gd:eventStatus
-        item.status = gdataXPathFirst(aXMLEntry, 'gd:eventStatus/@value').substring(39).toUpperCase();
-
-        // gd:reminder (preparation)
-        // If a reference item was passed, it may already contain alarms. Since
-        // we have no alarm id or such and the alarms are contained in every
-        // feed, we can go ahead and clear the alarms here.
-        item.clearAlarms();
-
-        /**
-         * Helper function to parse all reminders in a tagset.
-         *
-         * @param reminderTags      The tagset to parse.
-         */
-        function parseReminders(reminderTags) {
-            let organizerEmail = gdataXPathFirst(aXMLEntry, 'gd:who[@rel="http://schemas.google.com/g/2005#event.organizer"]/@email');
-            if (organizerEmail != aCalendar.googleCalendarName) {
-                // We are not the organizer, so its not smart to set alarms on
-                // this event.
-                return;
-            }
-            const actionMap = {
-                email: "EMAIL",
-                alert: "DISPLAY",
-                sms: "SMS"
-            };
-            for each (let reminderTag in reminderTags) {
-                let alarm = cal.createAlarm();
-                alarm.action = actionMap[reminderTag.getAttribute("method")] || "DISPLAY";
-
-                let absoluteTime = reminderTag.getAttribute("absoluteTime");
-                if (absoluteTime) {
-                    alarm.related = Components.interfaces.calIAlarm.ALARM_RELATED_ABSOLUTE;
-                    alarm.alarmDate = cal.fromRFC3339(absoluteTime, aTimezone);
-                } else {
-                    alarm.related = Components.interfaces.calIAlarm.ALARM_RELATED_START;
-                    let alarmOffset = cal.createDuration();
-                    let days = reminderTag.getAttribute("days");
-                    let hours = reminderTag.getAttribute("hours");
-                    let minutes = reminderTag.getAttribute("minutes");
-
-                    if (days) {
-                        alarmOffset.days = -days;
-                    } else if (hours) {
-                        alarmOffset.hours = -hours;
-                    } else if (minutes) {
-                        alarmOffset.minutes = -minutes;
-                    } else {
-                        // Invalid alarm, skip it
-                        continue;
-                    }
-                    alarmOffset.normalize();
-                    alarm.offset = alarmOffset;
-                }
-                item.addAlarm(alarm);
-            }
-        }
-
-        // gd:when
-        let recurrenceInfo = gdataXPathFirst(aXMLEntry, 'gd:recurrence/text()');
-        if (!recurrenceInfo || recurrenceInfo.length == 0) {
-            // If no recurrence information is given, then there will only be
-            // one gd:when tag. Otherwise, we will be parsing the startDate from
-            // the recurrence information.
-            item.startDate = cal.fromRFC3339(gdataXPathFirst(aXMLEntry, 'gd:when/@startTime'), aTimezone);
-            item.endDate = cal.fromRFC3339(gdataXPathFirst(aXMLEntry, 'gd:when/@endTime'), aTimezone);
-
-            if (!item.endDate) {
-                // We have a zero-duration event
-                item.endDate = item.startDate.clone();
-            }
-
-            // gd:reminder
-            parseReminders(gdataXPath(aXMLEntry, 'gd:when/gd:reminder'));
-        } else {
-            if (!item.recurrenceInfo) {
-                item.recurrenceInfo = cal.createRecurrenceInfo(item);
-            } else {
-                item.recurrenceInfo.clearRecurrenceItems();
-            }
-
-            // We don't really care about google's timezone info for
-            // now. This may change when bug 314339 is fixed. Split out
-            // the timezone information so we only have the first bit
-            let vevent = recurrenceInfo;
-            let splitpos = recurrenceInfo.indexOf("BEGIN:VTIMEZONE");
-            if (splitpos > -1) {
-                // Sometimes (i.e if only DATE values are specified), no
-                // timezone info is contained. Only remove it if it shows up.
-                vevent = recurrenceInfo.substring(0, splitpos);
-            }
-
-            vevent = "BEGIN:VEVENT\n" + vevent + "END:VEVENT";
-            let icsService = cal.getIcsService();
-
-            let rootComp = icsService.parseICS(vevent, gdataTimezoneService);
-            let i = 0;
-            let hasRecurringRules = false;
-            for (let prop in cal.ical.propertyIterator(rootComp)) {
-               switch (prop.propertyName) {
-                    case "EXDATE":
-                        let recItem = Components.classes["@mozilla.org/calendar/recurrence-date;1"]
-                                      .createInstance(Components.interfaces.calIRecurrenceDate);
-                        try {
-                            recItem.icalProperty = prop;
-                            item.recurrenceInfo.appendRecurrenceItem(recItem);
-                            hasRecurringRules = true;
-                        } catch (e) {
-                            Components.utils.reportError(e);
-                        }
-                        break;
-                    case "RRULE":
-                        let recRule = cal.createRecurrenceRule();
-                        try {
-                            recRule.icalProperty = prop;
-                            item.recurrenceInfo.appendRecurrenceItem(recRule);
-                            hasRecurringRules = true;
-                        } catch (e) {
-                            Components.utils.reportError(e);
-                        }
-                        break;
-                    case "DTSTART":
-                        item.startDate = prop.valueAsDatetime;
-                        break;
-                    case "DTEND":
-                        item.endDate = prop.valueAsDatetime;
-                        break;
-                }
-            }
-
-            if (!hasRecurringRules) {
-                // Sometimes Google gives us events that have <gd:recurrence>
-                // but contain no recurrence rules. Treat the event as a normal
-                // event. See gdata issue 353.
-                item.recurrenceInfo = null;
-            }
-
-            // gd:reminder (for recurring events)
-            // This element is supplied as a direct child to the <entry> element
-            // for recurring items.
-            parseReminders(gdataXPath(aXMLEntry, 'gd:reminder'));
-        }
-
-        // gd:recurrenceException
-        let exceptions = gdataXPath(aXMLEntry, 'gd:recurrenceException[@specialized="true"]/gd:entryLink/atom:entry');
-        for each (let exception in exceptions) {
-            // We only want specialized exceptions, mainly becuase I haven't
-            // quite found out if a non-specialized exception also corresponds
-            // to a normal exception as libical knows it.
-            let excItem = XMLEntryToItem(exception, aTimezone, aCalendar);
-
-            // Google uses the status field to reflect negative exceptions.
-            if (excItem.status == "CANCELED") {
-                item.recurrenceInfo.removeOccurrenceAt(excItem.recurrenceId);
-            } else {
-                excItem.calendar = aCalendar.superCalendar;
-                item.recurrenceInfo.modifyException(excItem, true);
-            }
-        }
-
-        // gd:extendedProperty (alarmLastAck)
-        item.alarmLastAck = cal.fromRFC3339(getExtendedProperty("X-MOZ-LASTACK"), aTimezone);
-
-        // gd:extendedProperty (snooze time)
-        let dtSnoozeTime = cal.fromRFC3339(getExtendedProperty("X-MOZ-SNOOZE-TIME"), aTimezone);
-        let snoozeProperty = (dtSnoozeTime ? dtSnoozeTime.icalString : null);
-        item.setProperty("X-MOZ-SNOOZE-TIME", snoozeProperty);
-
-        // gd:extendedProperty (snooze recurring alarms)
-        if (item.recurrenceInfo) {
-            // Transform back the string into our snooze properties
-            let snoozeObj;
-            try {
-                let snoozeString = getExtendedProperty("X-GOOGLE-SNOOZE-RECUR");
-                snoozeObj = JSON.parse(snoozeString);
-            } catch (e) {
-                // Just swallow parsing errors, not so important.
-            }
-
-            if (snoozeObj) {
-                for (let rid in snoozeObj) {
-                    item.setProperty("X-MOZ-SNOOZE-TIME-" + rid,
-                                     snoozeObj[rid]);
-                }
-            }
-        }
-
-        // gd:where
-        item.setProperty("LOCATION", gdataXPathFirst(aXMLEntry, 'gd:where/@valueString'));
-
-        // gd:who
-        if (Preferences.get("calendar.google.enableAttendees", false)) {
-            // XXX Only parse attendees if they are enabled, due to bug 407961
-
-            // This object can easily translate Google's values to our values.
-            const attendeeStatusMap = {
-                // role
-                "event.optional": "OPT-PARTICIPANT",
-                "event.required": "REQ-PARTICIPANT",
-
-                // Participation Statii
-                "event.accepted": "ACCEPTED",
-                "event.declined": "DECLINED",
-                "event.invited": "NEEDS-ACTION",
-                "event.tentative": "TENTATIVE"
-            };
-
-            // Clear all attendees in case a reference item was passed
-            item.removeAllAttendees();
-
-            // Iterate all attendee tags.
-            for each (let who in gdataXPath(aXMLEntry, 'gd:who')) {
-                let attendee = cal.createAttendee();
-                let rel = who.getAttribute("rel").substring(33);
-                let type = gdataXPathFirst(who, 'gd:attendeeType/@value').substring(33);
-                let status = gdataXPathFirst(who, 'gd:attendeeStatus/@value').substring(33);
-
-                attendee.id = "mailto:" + who.getAttribute("email")
-                attendee.commonName = who.getAttribute("valueString");
-                attendee.rsvp = "FALSE";
-                attendee.userType = "INDIVIDUAL";
-                attendee.isOrganizer = (rel == "event.organizer");
-                attendee.participationStatus = attendeeStatusMap[status];
-                attendee.role = attendeeStatusMap[type]
-                attendee.makeImmutable();
-
-                if (attendee.isOrganizer) {
-                    item.organizer = attendee;
-                } else {
-                    item.addAttendee(attendee);
-                }
-            }
-        }
-
-        // gd:originalEvent
-        item.recurrenceId = getRecurrenceIdFromEntry(aXMLEntry, aTimezone);
-
-        // gd:visibility
-        item.privacy = gdataXPathFirst(aXMLEntry, "gd:visibility/@value").substring(39).toUpperCase();
-
-        // category
-        // Google does not support categories natively, but allows us to store
-        // data as an "extendedProperty", and here it's going to be retrieved
-        // again
-        let categories = cal.categoriesStringToArray(getExtendedProperty("X-MOZ-CATEGORIES"));
-        item.setCategories(categories.length, categories);
-
-        // published
-        let createdText = gdataXPathFirst(aXMLEntry, 'atom:published/text()');
-        item.setProperty("CREATED", cal.fromRFC3339(createdText, aTimezone).getInTimezone(cal.UTC()));
-
-        // updated (This must be set last!)
-        let lastmodText = gdataXPathFirst(aXMLEntry, 'atom:updated/text()');
-        item.setProperty("LAST-MODIFIED", cal.fromRFC3339(lastmodText, aTimezone).getInTimezone(cal.UTC()));
-
-        // XXX Google currently has no priority support. See
-        // http://code.google.com/p/google-gdata/issues/detail?id=52
-        // for details.
-    } catch (e) {
-        cal.ERROR("Error parsing XML stream" + e);
-        throw e;
-    }
-    return item;
-}
-
-/**
- * Expand an item to occurrences, if the operation's item filter requests it.
- * Otherwise returns the item in an array.
- *
- * @param aItem         The item to expand
- * @param aOperation    The calIGoogleRequest that contains the filter and
- *                        ranges.
- * @return              The (possibly expanded) items in an array.
- */
-function expandItems(aItem, aOperation) {
-    let expandedItems;
-    if (aOperation.itemFilter &
-        Components.interfaces.calICalendar.ITEM_FILTER_CLASS_OCCURRENCES) {
-        expandedItems = aItem.getOccurrencesBetween(aOperation.itemRangeStart,
-                                                    aOperation.itemRangeEnd,
-                                                    {});
-        cal.LOG("[calGoogleCalendar] Expanded item " + aItem.title + " to " +
-                expandedItems.length + " items");
-    }
-    return expandedItems || [aItem];
-}
-
-/**
- * Returns true if the exception passed is one that should cause the cache
- * layer to retry the operation. This is usually a network error or other
- * temporary error
- *
- * @param e     The exception to check
- */
-function isCacheException(e) {
-    // Stolen from nserror.h
-    const NS_ERROR_MODULE_NETWORK = 6;
-    function NS_ERROR_GET_MODULE(code) {
-        return (((code >> 16) - 0x45) & 0x1fff);
-    }
-
-    if (NS_ERROR_GET_MODULE(e.result) == NS_ERROR_MODULE_NETWORK &&
-        !Components.isSuccessCode(e.result)) {
-        // This is a network error, which most likely means we should
-        // retry it some time.
-        return true;
-    }
-
-    // Other potential errors we want to retry with
-    switch (e.result) {
-        case Components.results.NS_ERROR_NOT_AVAILABLE:
-            return true;
-        default:
-            return false;
-    }
-}
-
-/**
- * Helper prototype to set a certain variable to the first item passed via get
- * listener. Cleans up code.
- */
-function syncSetter(aObj) {
-    this.mObj = aObj
-}
-syncSetter.prototype = {
-
-    onGetResult: function syncSetter_onGetResult(aCal,
-                                                 aStatus,
-                                                 aIID,
-                                                 aDetail,
-                                                 aCount,
-                                                 aItems) {
-        this.mObj.value = aItems[0];
-    },
-
-    onOperationComplete: function syncSetter_onOperationComplete(aCal,
-                                                                 aStatus,
-                                                                 aOpType,
-                                                                 aId,
-                                                                 aDetail) {
-
-        if (!Components.isSuccessCode(aStatus)) {
-            this.mObj.value = null;
-        }
-    }
-};
-
-/**
- * Helper function to create a timer in a context where window.setTimeout is not
- * available
- *
- * @param aFunc     The function to call when the timer fires
- * @param aTimeout  The timeout in milliseconds.
- * @param aThis     (optional) The |this| object to call the function with.
- */
-function setTimeout(aFunc, aTimeout, aThis) {
-    let timerCallback = {
-        notify: function setTimeout_notify() {
-            aFunc.call(aThis);
-        }
-    };
-    let timer = Components.classes["@mozilla.org/timer;1"]
-                          .createInstance(Components.interfaces.nsITimer);
-    timer.initWithCallback(timerCallback, aTimeout, timer.TYPE_ONE_SHOT);
-}
-
-/**
- * LOGitem
- * Custom logging functions
- */
-function LOGitem(item) {
-    if (!item) {
-        return;
-    }
-
-    let attendees = item.getAttendees({});
-    let attendeeString = "";
-    for each (let a in attendees) {
-        attendeeString += "\n" + LOGattendee(a);
-    }
-
-    let rstr = "\n";
-    if (item.recurrenceInfo) {
-        let ritems = item.recurrenceInfo.getRecurrenceItems({});
-        for each (let ritem in ritems) {
-            rstr += "\t\t" + ritem.icalProperty.icalString;
-        }
-
-        rstr += "\tExceptions:\n";
-        let exids = item.recurrenceInfo.getExceptionIds({});
-        for each (let exc in exids) {
-            rstr += "\t\t" + exc + "\n";
-        }
-    }
-
-    let astr = "\n";
-    let alarms = item.getAlarms({});
-    for each (let alarm in alarms) {
-        astr += "\t\t" + LOGalarm(alarm) + "\n";
-    }
-
-    cal.LOG("[calGoogleCalendar] Logging calIEvent:" +
-        "\n\tid:" + item.id +
-        "\n\tediturl:" + item.getProperty("X-GOOGLE-EDITURL") +
-        "\n\tcreated:" + item.getProperty("CREATED") +
-        "\n\tupdated:" + item.getProperty("LAST-MODIFIED") +
-        "\n\ttitle:" + item.title +
-        "\n\tcontent:" + item.getProperty("DESCRIPTION") +
-        "\n\ttransparency:" + item.getProperty("TRANSP") +
-        "\n\tstatus:" + item.status +
-        "\n\tstartTime:" + item.startDate.toString() +
-        "\n\tendTime:" + item.endDate.toString() +
-        "\n\tlocation:" + item.getProperty("LOCATION") +
-        "\n\tprivacy:" + item.privacy +
-        "\n\tsequence:" + item.getProperty("SEQUENCE") +
-        "\n\talarmLastAck:" + item.alarmLastAck +
-        "\n\tsnoozeTime:" + item.getProperty("X-MOZ-SNOOZE-TIME") +
-        "\n\tisOccurrence: " + (item.recurrenceId != null) +
-        "\n\tOrganizer: " + LOGattendee(item.organizer) +
-        "\n\tAttendees: " + attendeeString +
-        "\n\trecurrence: " + (rstr.length > 1 ? "yes: " + rstr : "no") +
-        "\n\talarms: " + (astr.length > 1 ? "yes: " + astr : "no"));
-}
-
-function LOGattendee(aAttendee, asString) {
-    return aAttendee &&
-        ("\n\t\tID: " + aAttendee.id +
-         "\n\t\t\tName: " + aAttendee.commonName +
-         "\n\t\t\tRsvp: " + aAttendee.rsvp +
-         "\n\t\t\tIs Organizer: " +  (aAttendee.isOrganizer ? "yes" : "no") +
-         "\n\t\t\tRole: " + aAttendee.role +
-         "\n\t\t\tStatus: " + aAttendee.participationStatus);
-}
-
-function LOGalarm(aAlarm) {
-    if (!aAlarm) {
-        return "";
-    }
-
-    let enumerator = aAlarm.propertyEnumerator;
-    let xpropstr = "";
-    while (enumerator.hasMoreElements()) {
-        let el = enumerator.getNext();
-        xpropstr += "\n\t\t\t" + el.key + ":" + el.value;
-    }
-
-    return ("\n\t\tAction: " +  aAlarm.action +
-            "\n\t\tOffset: " + (aAlarm.offset && aAlarm.offset.toString()) +
-            "\n\t\talarmDate: " + (aAlarm.alarmDate && aAlarm.alarmDate.toString()) +
-            "\n\t\trelated: " + aAlarm.related +
-            "\n\t\trepeat: " + aAlarm.repeat +
-            "\n\t\trepeatOffset: " + (aAlarm.repeatOffset && aAlarm.repeatOffset.toString()) +
-            "\n\t\trepeatDate: " + (aAlarm.repeatDate && aAlarm.repeatDate.toString()) +
-            "\n\t\tdescription: " + aAlarm.description +
-            "\n\t\tsummary: " + aAlarm.summary +
-            "\n\t\tproperties: " + (xpropstr.length > 0 ? "yes:" + xpropstr : "no"));
-}
-
-function LOGinterval(aInterval) {
-    const fbtypes = Components.interfaces.calIFreeBusyInterval;
-    if (aInterval.freeBusyType == fbtypes.FREE) {
-        type = "FREE";
-    } else if (aInterval.freeBusyType == fbtypes.BUSY) {
-        type = "BUSY";
-    } else {
-        type = aInterval.freeBusyType + "(UNKNOWN)";
-    }
-
-    cal.LOG("[calGoogleCalendar] Interval from " +
-            aInterval.interval.start + " to " + aInterval.interval.end +
-            " is " + type);
-}
diff --git a/calendar/providers/gdata/components/moz.build b/calendar/providers/gdata/components/moz.build
deleted file mode 100644
index dd79ec6..0000000
--- a/calendar/providers/gdata/components/moz.build
+++ /dev/null
@@ -1,10 +0,0 @@
-# vim: set filetype=python:
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-EXTRA_COMPONENTS += [
-    'calGoogleCalendarModule.js',
-    'calGoogleCalendarModule.manifest',
-]
-
diff --git a/calendar/providers/gdata/content/browserRequest.css b/calendar/providers/gdata/content/browserRequest.css
new file mode 100644
index 0000000..7f1dacb
--- /dev/null
+++ b/calendar/providers/gdata/content/browserRequest.css
@@ -0,0 +1,59 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#security-button {
+  width: 20px;
+  margin-top: -1px;
+  margin-right: 5px;
+  background-repeat: no-repeat;
+}
+
+#security-button[level="high"],
+#security-button[level="low"] {
+  background-image: url("chrome://messenger/skin/icons/secure.png");
+}
+
+#security-button[level="broken"] {
+  background-image: url("chrome://messenger/skin/icons/insecure.png");
+}
+
+#security-button[loading="true"] {
+  background-image: url("chrome://messenger/skin/icons/loading.png");
+  background-position: 4px 3px;
+}
+
+@media (min-resolution: 2ddpx) {
+  #security-button[loading="true"] {
+    background-image: url("chrome://messenger/skin/icons/loading@2x.png");
+  }
+}
+
+/*
+#header {
+  overflow: hidden;
+  padding: 5px;
+  border-bottom: 1px solid black;
+  font-weight: bold;
+  font-size: 1.2em;
+}
+*/
+
+#header {
+    border-bottom: 1px solid rgb(105, 105, 105);
+    overflow: hidden;
+}
+
+#addressbox {
+    font-weight: bold;
+    font-size: normal;
+    -moz-appearance: textfield;
+    overflow: hidden;
+    margin: 5px 5px;
+    font-weight: normal;
+}
+
+#headerMessage {
+  margin-top: 3px;
+  margin-bottom: 3px;
+}
diff --git a/calendar/providers/gdata/content/browserRequest.js b/calendar/providers/gdata/content/browserRequest.js
new file mode 100644
index 0000000..18782b9
--- /dev/null
+++ b/calendar/providers/gdata/content/browserRequest.js
@@ -0,0 +1,113 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+const wpl = Components.interfaces.nsIWebProgressListener;
+
+var reporterListener = {
+  _isBusy: false,
+  get securityButton() {
+    delete this.securityButton;
+    return this.securityButton = document.getElementById("security-button");
+  },
+
+  QueryInterface: function(aIID) {
+    if (aIID.equals(Components.interfaces.nsIWebProgressListener)   ||
+        aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
+        aIID.equals(Components.interfaces.nsISupports))
+      return this;
+    throw Components.results.NS_NOINTERFACE;
+  },
+
+  onStateChange: function(/*in nsIWebProgress*/ aWebProgress,
+                     /*in nsIRequest*/ aRequest,
+                     /*in unsigned long*/ aStateFlags,
+                     /*in nsresult*/ aStatus) {
+  },
+
+  onProgressChange: function(/*in nsIWebProgress*/ aWebProgress,
+                        /*in nsIRequest*/ aRequest,
+                        /*in long*/ aCurSelfProgress,
+                        /*in long */aMaxSelfProgress,
+                        /*in long */aCurTotalProgress,
+                        /*in long */aMaxTotalProgress) {
+  },
+
+  onLocationChange: function(/*in nsIWebProgress*/ aWebProgress,
+                        /*in nsIRequest*/ aRequest,
+                        /*in nsIURI*/ aLocation) {
+    document.getElementById("headerMessage").textContent = aLocation.spec;
+  },
+
+  onStatusChange: function(/*in nsIWebProgress*/ aWebProgress,
+                      /*in nsIRequest*/ aRequest,
+                      /*in nsresult*/ aStatus,
+                      /*in wstring*/ aMessage) {
+  },
+
+  onSecurityChange: function(/*in nsIWebProgress*/ aWebProgress,
+                        /*in nsIRequest*/ aRequest,
+                        /*in unsigned long*/ aState) {
+    const wpl_security_bits = wpl.STATE_IS_SECURE |
+                              wpl.STATE_IS_BROKEN |
+                              wpl.STATE_IS_INSECURE |
+                              wpl.STATE_SECURE_HIGH |
+                              wpl.STATE_SECURE_MED |
+                              wpl.STATE_SECURE_LOW;
+    var browser = document.getElementById("requestFrame");
+    var level;
+
+    switch (aState & wpl_security_bits) {
+      case wpl.STATE_IS_SECURE | wpl.STATE_SECURE_HIGH:
+        level = "high";
+        break;
+      case wpl.STATE_IS_SECURE | wpl.STATE_SECURE_MED:
+      case wpl.STATE_IS_SECURE | wpl.STATE_SECURE_LOW:
+        level = "low";
+        break;
+      case wpl.STATE_IS_BROKEN:
+        level = "broken";
+        break;
+    }
+    if (level) {
+      this.securityButton.setAttribute("level", level);
+      this.securityButton.hidden = false;
+    } else {
+      this.securityButton.hidden = true;
+      this.securityButton.removeAttribute("level");
+    }
+    this.securityButton.setAttribute("tooltiptext",
+                                     browser.securityUI.tooltipText);
+  }
+}
+
+function cancelRequest()
+{
+  reportUserClosed();
+  window.close();
+}
+
+function reportUserClosed()
+{
+  let request = window.arguments[0].wrappedJSObject;
+  request.cancelled();
+}
+
+function loadRequestedUrl()
+{
+  let request = window.arguments[0].wrappedJSObject;
+  document.getElementById("headerMessage").textContent = request.promptText;
+  let account = request.account;
+  if (request.iconURI != "")
+    document.getElementById("headerImage").src = request.iconURI;
+
+  var browser = document.getElementById("requestFrame");
+  browser.addProgressListener(reporterListener,
+                              Components.interfaces.nsIWebProgress.NOTIFY_ALL);
+  var url = request.url;
+  if (url != "") {
+    browser.setAttribute("src", url);
+    document.getElementById("headerMessage").textContent = url;
+  }
+  request.loaded(window, browser.webProgress);
+}
diff --git a/calendar/providers/gdata/content/browserRequest.xul b/calendar/providers/gdata/content/browserRequest.xul
new file mode 100644
index 0000000..c182625
--- /dev/null
+++ b/calendar/providers/gdata/content/browserRequest.xul
@@ -0,0 +1,34 @@
+<?xml version="1.0"?>
+<!--# This Source Code Form is subject to the terms of the Mozilla Public
+    # License, v. 2.0. If a copy of the MPL was not distributed with this file,
+    # You can obtain one at http://mozilla.org/MPL/2.0/.
+ -->
+
+<?xml-stylesheet href="chrome://global/skin/" type="text/css"?>
+<?xml-stylesheet href="chrome://gdata-provider/skin/browserRequest.css" type="text/css"?>
+
+<!DOCTYPE window>
+<window id="browserRequest"
+        xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+        buttons=","
+        onload="loadRequestedUrl()"
+        onclose="reportUserClosed()"
+        title=""
+        width="800"
+        height="500"
+        orient="vertical">
+
+  <script type="application/javascript" src="chrome://gdata-provider/content/browserRequest.js"/>
+
+  <keyset id="mainKeyset">
+    <key id="key_close" key="w" modifiers="accel" oncommand="cancelRequest()"/>
+    <key id="key_close2"  keycode="VK_ESCAPE" oncommand="cancelRequest()"/>
+  </keyset>
+  <hbox id="header">
+  <hbox id="addressbox" flex="1" disabled="true">
+    <image id="security-button" src="chrome://messenger/skin/icons/mailicon32.png"/>
+    <description id="headerMessage"/>
+  </hbox>
+  </hbox>
+  <browser type="content" disablehistory="true" src="about:blank" id="requestFrame" flex="1"/>
+</window>
diff --git a/calendar/providers/gdata/content/calendarCreation.xul b/calendar/providers/gdata/content/calendarCreation.xul
deleted file mode 100644
index 6a9d85e..0000000
--- a/calendar/providers/gdata/content/calendarCreation.xul
+++ /dev/null
@@ -1,12 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
-
-<!DOCTYPE overlay SYSTEM "chrome://gdata-provider/locale/gdata.dtd">
-<overlay id="calendarCreation"
-         xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
-    <radiogroup id="calendar-format">
-        <radio value="gdata" label="&gdata-provider.label;"/>
-    </radiogroup>
-</overlay>
diff --git a/calendar/providers/gdata/content/gdata-bindings.css b/calendar/providers/gdata/content/gdata-bindings.css
new file mode 100644
index 0000000..874cf8d
--- /dev/null
+++ b/calendar/providers/gdata/content/gdata-bindings.css
@@ -0,0 +1,22 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+calendar-list-tree[type="gdata"] {
+  -moz-binding: url(chrome://gdata-provider/content/gdata-list-tree.xml#gdata-list-tree);
+}
+
+calendar-list-tree > tree > treechildren::-moz-tree-image(checkbox-treecol, disabled) {
+    list-style-image: none !important;
+}
+
+calendar-list-tree > tree > treechildren::-moz-tree-cell(color-treecol, disabled) {
+    background-color: transparent !important;
+}
+
+calendar-list-tree > tree > treechildren::-moz-tree-image(status-treecol, readonly) {
+    list-style-image: none;
+}
+calendar-list-tree > tree > treechildren::-moz-tree-cell-text(readonly) {
+    opacity: 0.4;
+}
diff --git a/calendar/providers/gdata/content/gdata-calendar-creation.js b/calendar/providers/gdata/content/gdata-calendar-creation.js
new file mode 100644
index 0000000..633bbec
--- /dev/null
+++ b/calendar/providers/gdata/content/gdata-calendar-creation.js
@@ -0,0 +1,246 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+Components.utils.import("resource://gdata-provider/modules/shim/Loader.jsm").shimIt(this);
+Components.utils.import("resource://gdata-provider/modules/shim/Calendar.jsm");
+Components.utils.import("resource://gdata-provider/modules/gdataSession.jsm");
+Components.utils.import("resource://gdata-provider/modules/gdataUtils.jsm");
+
+CuImport("resource://gre/modules/Promise.jsm", this);
+
+(function() {
+    function pageorder(anchor /*, ...pages */) {
+        let pages = Array.slice(arguments, 1);
+        let wizard = document.documentElement;
+        let page = wizard.getPageById(anchor);
+        for each (let id in pages) {
+            page.next = id;
+            page = wizard.getPageById(id);
+        }
+    }
+
+    function trycatch(func) {
+        return function() {
+            try {
+                return func.apply(this, arguments);
+            } catch (e) {
+                Components.utils.reportError(e);
+                throw e;
+            }
+        };
+    }
+
+    let previousUriValue = null;
+    function selectProvider(type) {
+        let isGdata = (type == "gdata");
+        let curi = document.getElementById("calendar-uri");
+        let wizard = document.documentElement;
+
+        curi.parentNode.style.visibility = (isGdata ? "hidden" : "visible");
+        document.getElementById("cache").parentNode.style.visibility = (isGdata ? "hidden" : "visible");
+
+        // Move the next step descrition to the right place
+        let locationRows = document.querySelector("#calendar-wizard > [pageid='locationPage'] > grid > rows");
+        let nextStepDescr = document.getElementById("gdata-nextstep-description");
+        locationRows.appendChild(nextStepDescr);
+
+        if (isGdata) {
+            pageorder("locationPage", "gdata-session", "gdata-calendars", "finishPage");
+            previousUriValue = curi.value;
+            curi.value = "googleapi://unknown";
+            nextStepDescr.removeAttribute("hidden");
+        } else {
+            nextStepDescr.setAttribute("hidden", "true");
+            pageorder("locationPage", "customizePage", "finishPage");
+            if (previousUriValue !== null) {
+                curi.value = previousUriValue;
+                previousUriValue = null;
+            }
+        }
+
+        checkRequired();
+    }
+    this.gdataSelectProvider = selectProvider;
+
+    if (typeof tmpCalendarCreation == "undefined") {
+        monkeyPatch(window, "onSelectProvider", function(protofunc, type) {
+            selectProvider(type);
+            return protofunc(type);
+        });
+    } else {
+        // The exchange provider overwrites the select handler, which causes
+        // our provider to fail. The exchange provider overwrites the select
+        // handler, which causes our provider to fail. Given the exchange
+        // provider is currently not maintained and we want them to work
+        // together, here is a workaround.
+        monkeyPatch(tmpCalendarCreation, "doRadioExchangeCalendar", function(protofunc, target) {
+            // We need to run our function first, otherwise resetting the
+            // pageorder will overwrite what the exchange provider does.
+            selectProvider(target.value);
+            let rv = protofunc(target);
+
+            // But then again, when switching to the gdata provider, the
+            // exchange provider overwrites the uri we set.
+            if (target.value == "gdata") {
+                let curi = document.getElementById("calendar-uri");
+                curi.value = "googleapi://unknown";
+                checkRequired();
+            }
+            return rv;
+        });
+    }
+
+    monkeyPatch(window, "prepareCreateCalendar", function(protofunc) {
+        let type = document.getElementById('calendar-format').selectedItem.value;
+        return (type == "gdata" ? true : protofunc());
+    });
+
+    monkeyPatch(window, "checkRequired", function(protofunc) {
+        let wizard = document.documentElement;
+        let currentPageId = wizard.currentPage && wizard.currentPage.pageid;
+
+        if (currentPageId == "gdata-session") {
+            let sessionGroup = document.getElementById("gdata-session-group");
+            let sessionName = document.getElementById("gdata-session-name");
+            let sessionNameIsValid = document.getAnonymousElementByAttribute(sessionName, "anonid", "input").validity.valid;
+            // TODO for some reason the validity doesn't work on windows. Here is a hack:
+            sessionNameIsValid = !!sessionName.value.match(/^[^\/]+@[^\/]+\.[^\/]+$/);
+            wizard.canAdvance = sessionGroup.value || (sessionName.value && sessionNameIsValid);
+        } else if (currentPageId == "gdata-calendars") {
+            let calendarList = document.getElementById("calendar-list");
+            let calendars = calendarList.selectedCalendars.filter(function(x) !x.getProperty("disabled") && !x.readOnly);
+            wizard.canAdvance = !!calendars.length;
+        } else {
+            protofunc();
+        }
+    });
+
+    this.gdataSessionShow = trycatch(function() {
+        let sessionMgr = getGoogleSessionManager();
+        let sessionContainer = document.getElementById("gdata-session-group");
+        let newSessionItem = document.getElementById("session-new");
+        let calendars = cal.getCalendarManager().getCalendars({});
+        let sessions = new Set([ sessionMgr.getSessionByCalendar(calendar, true)
+                                 for each (calendar in calendars) ]);
+
+        while (sessionContainer.firstChild.id != "session-new") {
+            sessionContainer.removeChild(sessionContainer.firstChild);
+        }
+
+        // forEach is needed for backwards compatibility.
+        sessions.forEach(function(session) {
+            if (!session) {
+                return;
+            }
+
+            let radio = document.createElement("radio");
+            radio.setAttribute("value", session.id);
+            radio.setAttribute("label", session.id);
+            sessionContainer.insertBefore(radio, newSessionItem);
+            radio.gdataSession = session;
+        });
+
+        sessionContainer.value = sessionContainer.firstChild.value;
+        if (sessionContainer.value == "") {
+            let sessionName = document.getElementById("gdata-session-name");
+            sessionName.focus();
+        }
+    });
+
+    this.gdataCalendarsShow = trycatch(function() {
+        let calMgr = cal.getCalendarManager();
+        let sessionMgr = getGoogleSessionManager();
+        let sessionContainer = document.getElementById("gdata-session-group");
+        let calendarListWidget = document.getElementById("calendar-list");
+        calendarListWidget.clear();
+
+        let session = sessionContainer.selectedItem.gdataSession;
+        if (!session) {
+            let newSessionItem = document.getElementById("gdata-session-name");
+            session = sessionMgr.getSessionById(newSessionItem.value, true);
+        }
+
+        PromiseAll([session.getTasksList(), session.getCalendarList()])
+               .then(function([tasksLists, calendarList]) {
+            let existing = new Set();
+            let sessionPrefix = "googleapi://" + session.id;
+            for each (let calendar in calMgr.getCalendars({})) {
+                let spec = calendar.uri.spec;
+                if (calendar.type == "gdata" && spec.substr(0, sessionPrefix.length) == sessionPrefix) {
+                    let match;
+                    if ((match = spec.match(/calendar=([^&]*)/))) {
+                        existing.add(decodeURIComponent(match[0]));
+                    }
+                    if ((match = spec.match(/tasks=([^&]*)/))) {
+                        existing.add(decodeURIComponent(match[0]));
+                    }
+                }
+            }
+
+            let taskcals = tasksLists.map(function(tasklist) {
+                let uri = "googleapi://" + session.id + "/?tasks=" + encodeURIComponent(tasklist.id);
+                let calendar = calMgr.createCalendar("gdata", Services.io.newURI(uri, null, null));
+                calendar.id = cal.getUUID();
+                calendar.setProperty("color", cal.hashColor(tasklist.title));
+                calendar.name = tasklist.title;
+                if (existing.has("tasks=" + tasklist.id)) {
+                    calendar.readOnly = true;
+                }
+                return calendar;
+            });
+            let calcals = calendarList.map(function(calendarEntry) {
+                let uri = "googleapi://" + session.id + "/?calendar=" + encodeURIComponent(calendarEntry.id);
+                let calendar = calMgr.createCalendar("gdata", Services.io.newURI(uri, null, null));
+                calendar.name = calendarEntry.summary;
+                calendar.id = cal.getUUID();
+                calendar.setProperty("color", calendarEntry.backgroundColor);
+                if (existing.has("calendar=" + calendarEntry.id)) {
+                    calendar.readOnly = true;
+                }
+                return calendar;
+            });
+
+            let calendars = [calendarListWidget.mockCalendarHeader]
+                            .concat(calcals)
+                            .concat([calendarListWidget.mockTaskHeader])
+                            .concat(taskcals);
+
+            calendarListWidget.calendars = calendars;
+        }.bind(this), function(e) {
+            Components.utils.reportError(e);
+        }.bind(this));
+    });
+
+    this.gdataCalendarsAdvance = trycatch(function() {
+        let calendarList = document.getElementById("calendar-list");
+        let calendars = calendarList.selectedCalendars.filter(function(x) !x.getProperty("disabled") && !x.readOnly);
+        let calMgr = cal.getCalendarManager();
+
+        if (Services.vc.compare(Services.appinfo.platformVersion, "9.0") < 0) {
+            // This version didn't allow creating calendars with an id set, we
+            // will have to hack it in.
+            calendars.forEach(gdataRegisterCalendar);
+        } else {
+            calendars.forEach(calMgr.registerCalendar, calMgr);
+        }
+        return true;
+    });
+
+    this.gdataFocusNewSession = trycatch(function() {
+        let sessionContainer = document.getElementById("gdata-session-group");
+        sessionContainer.value = "";
+    });
+
+    document.addEventListener("DOMContentLoaded", function() {
+        // Older versions of Lightning don't set the onselect attribute at all.
+        let calendarFormat = document.getElementById("calendar-format");
+        if (!calendarFormat.hasAttribute("onselect")) {
+            calendarFormat.setAttribute("onselect", "gdataSelectProvider(this.value)");
+        }
+
+        if (!("updateStyleSheetForViews" in window)) {
+            window.updateStyleSheetForViews = function() {};
+        }
+    });
+}).call(window);
diff --git a/calendar/providers/gdata/content/gdata-calendar-creation.xul b/calendar/providers/gdata/content/gdata-calendar-creation.xul
new file mode 100644
index 0000000..87271b8
--- /dev/null
+++ b/calendar/providers/gdata/content/gdata-calendar-creation.xul
@@ -0,0 +1,52 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this
+   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+
+<!DOCTYPE overlay [
+  <!ENTITY % gdata SYSTEM "chrome://gdata-provider/locale/gdata.dtd"> %gdata;
+  <!ENTITY % calendarCreation SYSTEM "chrome://calendar/locale/calendarCreation.dtd" > %calendarCreation;
+]>
+
+<?xml-stylesheet href="chrome://calendar/skin/calendar-management.css" type="text/css"?>
+<?xml-stylesheet href="chrome://calendar/content/widgets/calendar-widget-bindings.css" type="text/css"?>
+<?xml-stylesheet href="chrome://gdata-provider/skin/gdata-bindings.css" type="text/css"?>
+
+<overlay id="gdataCalendarCreation"
+         xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
+  <script type="application/javascript" src="chrome://gdata-provider/content/gdata-calendar-creation.js"/>
+  <radiogroup id="calendar-format">
+    <radio value="gdata" label="&gdata-provider.label;"/>
+  </radiogroup>
+
+  <wizard id="calendar-wizard">
+    <description id="gdata-nextstep-description" hidden="true">&gdata.wizard.nextstep.description;</description>
+
+    <wizardpage id="gdata-session"
+                pageid="gdata-session"
+                onpageshow="gdataSessionShow(); checkRequired()"
+                description="&wizard.description;">
+       <description>&gdata.wizard.session.description;</description>
+       <radiogroup id="gdata-session-group" onselect="checkRequired()">
+         <hbox id="session-new">
+           <radio value=""/>
+           <textbox id="gdata-session-name"
+                    type="email"
+                    onfocus="gdataFocusNewSession()"
+                    oninput="gdataFocusNewSession(); checkRequired();"
+                    flex="1"/>
+         </hbox>
+       </radiogroup>
+    </wizardpage>
+    <wizardpage id="gdata-calendars"
+                pageid="gdata-calendars"
+                onpageshow="gdataCalendarsShow(); checkRequired()"
+                onpageadvanced="return gdataCalendarsAdvance()"
+                description="&wizard.description;">
+      <description>&gdata.wizard.calendars.description;</description>
+      <calendar-list-tree type="gdata" id="calendar-list" flex="1"
+                          onselect="checkRequired();" hideheader="true"
+                          onclick="checkRequired()"/>
+    </wizardpage>
+  </wizard>
+</overlay>
diff --git a/calendar/providers/gdata/content/gdata-calendar-event-dialog.js b/calendar/providers/gdata/content/gdata-calendar-event-dialog.js
new file mode 100644
index 0000000..d9c41a5
--- /dev/null
+++ b/calendar/providers/gdata/content/gdata-calendar-event-dialog.js
@@ -0,0 +1,206 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+Components.utils.import("resource://gdata-provider/modules/gdataUtils.jsm");
+
+(function() {
+
+    // Older versions of Lightning don't have this variable.
+    if (!("gOldEndTimezone" in window)) {
+        window.gOldEndTimezone = null;
+    }
+
+    monkeyPatch(window, "updateCalendar", function(protofunc /*, ...args */) {
+        let rv = protofunc.apply(this, Array.slice(arguments, 1));
+        let calendar = getCurrentCalendar();
+        let isGoogleCalendar = (calendar.type == "gdata");
+        let isTask = cal.isToDo(window.calendarItem);
+        let isEvent = cal.isEvent(window.calendarItem);
+        let isGoogleTask = isGoogleCalendar && isTask;
+        let isGoogleEvent = isGoogleCalendar && isEvent;
+
+        let hideForTaskIds = [
+            "event-grid-location-row",
+
+            "event-grid-startdate-row",
+            "timezone-endtime",
+            "link-image-bottom",
+
+            "event-grid-attendee-row",
+            "event-grid-attendee-row-2",
+
+            "todo-status-none-menuitem",
+            "todo-status-inprogress-menuitem",
+            "todo-status-canceled-menuitem",
+
+            "percent-complete-textbox",
+            "percent-complete-label",
+
+            "event-grid-recurrence-row",
+            "event-grid-recurrence-separator",
+
+            "event-grid-alarm-row",
+            "event-grid-alarm-separator",
+
+            "status-privacy",
+            "status-priority"
+        ];
+
+        let disableForTaskIds = [
+            "options-attachments-menu",
+            "options-attendess-menuitem",
+            "options-privacy-menu",
+            "options-priority-menu",
+            "options-freebusy-menu",
+            "button-attendees",
+            "button-privacy",
+            "button-url"
+        ];
+
+        for each (let id in hideForTaskIds) {
+            let node = document.getElementById(id);
+            if (node) {
+                node.hidden = isGoogleTask;
+            }
+        }
+
+        for each (let id in disableForTaskIds) {
+            let node = document.getElementById(id);
+            if (node) {
+                node.disabled = isGoogleTask;
+            }
+        }
+
+        let duedate = document.getElementById("todo-duedate");
+        let duetime = document.getAnonymousElementByAttribute(duedate, "anonid", "time-picker");
+        duetime.style.display = isGoogleTask ? "none" : "";
+
+        if (gEndTime) {
+            if (isGoogleTask) {
+                let floating = cal.floating();
+                if (gEndTimezone != floating) {
+                  gOldEndTimezone = gEndTimezone;
+                }
+                gEndTimezone = cal.floating();
+                gEndTime = gEndTime.getInTimezone(gEndTimezone);
+                gEndTime.isDate = true;
+            } else {
+                if (gOldEndTimezone) {
+                    gEndTimezone = gOldEndTimezone;
+                }
+                gEndTime.isDate = false;
+                gEndTime = gEndTime.getInTimezone(gEndTimezone);
+            }
+            updateDateTime();
+        }
+
+        let elements = document.getElementsByAttribute("provider", "gdata");
+        for each (let elem in Array.slice(elements)) {
+            elem.style.display = isGoogleCalendar ? "" : "none";
+        }
+
+        let reminderList = document.getElementById("item-alarm");
+        let hasDefaultReminders = isGoogleEvent && calendar.getProperty("settings.defaultReminders");
+        if (isGoogleCalendar && !hasDefaultReminders && reminderList.value == "default") {
+            reminderList.value = "none";
+        }
+
+        document.getElementById("gdata-reminder-default-menuitem").style.display = hasDefaultReminders ? "" : "none";
+
+        // Older versions of Lightning don't update the category menulist.
+        if (!document.getElementById("item-categories-panel")) {
+            let categoriesLabel = document.getElementById("event-grid-category-color-row").firstChild;
+            let calendarLabel = document.getElementById("item-categories").nextSibling;
+            if (!categoriesLabel.origLabel) categoriesLabel.origLabel = categoriesLabel.value;
+
+            setBooleanAttribute("item-categories", "hidden", isGoogleTask);
+            setBooleanAttribute(calendarLabel, "hidden", isGoogleTask);
+
+            if (isGoogleTask) {
+                categoriesLabel.value = calendarLabel.value;
+            } else {
+                categoriesLabel.value = categoriesLabel.origLabel;
+            }
+        }
+        return rv;
+    });
+
+    monkeyPatch(window, "updateCategoryMenulist", function(protofunc /*, ...args */) {
+        let args = Array.slice(arguments, 1);
+        let rv;
+        let calendar = getCurrentCalendar();
+        if (calendar.type == "gdata" && cal.isToDo(window.calendarItem)) {
+            let unwrappedCal = calendar.getProperty("cache.uncachedCalendar").wrappedJSObject;
+            unwrappedCal.mProperties['capabilities.categories.maxCount'] = 0;
+            rv = protofunc.apply(this, args);
+            delete unwrappedCal.mProperties['capabilities.categories.maxCount'];
+        } else {
+            rv = protofunc.apply(this, args);
+        }
+        return rv;
+    });
+
+    monkeyPatch(window, "updateReminderDetails", function(protofunc /*, ...args */) {
+        let rv = protofunc.apply(this, Array.slice(arguments, 1));
+        let reminderList = document.getElementById("item-alarm");
+
+        if (reminderList.value == "default") {
+            removeChildren("reminder-icon-box");
+        }
+
+        return rv;
+    });
+
+    monkeyPatch(window, "saveReminder", function(protofunc, item /*, ...args */) {
+        let calendar = getCurrentCalendar();
+        let reminderList = document.getElementById("item-alarm");
+        if (calendar.type == "gdata" && reminderList.value == "default") {
+            item.clearAlarms();
+            let unwrappedCal = item.calendar.getProperty("cache.uncachedCalendar").wrappedJSObject;
+            unwrappedCal.defaultReminders.forEach(item.addAlarm, item);
+            return null;
+        } else {
+            return protofunc.apply(this, Array.slice(arguments, 1));
+        }
+    })
+
+    monkeyPatch(window, "loadReminders", function(protofunc, reminders /*, ...args */) {
+        let reminderList = document.getElementById("item-alarm");
+
+        // Set up the default reminders item
+        let defaultItem = document.getElementById("gdata-reminder-default-menuitem");
+        let calendar = getCurrentCalendar().getProperty("cache.uncachedCalendar");
+        let unwrappedCal = calendar && calendar.wrappedJSObject;
+        let defaultReminders = unwrappedCal.defaultReminders ? unwrappedCal.defaultReminders.concat([]) : [];
+        defaultItem.reminders = defaultReminders;
+
+        let rv = null;
+        let usesDefault = reminders.length && reminders.every(function(x) x.hasProperty("X-DEFAULT-ALARM"));
+        if (calendar.type == "gdata" && (window.mode == "new" || usesDefault)) {
+            // If all reminders are default reminders, then select the menuitem.
+            reminderList.value = "default";
+
+            // remember the selected index
+            gLastAlarmSelection = reminderList.selectedIndex;
+        } else {
+            rv = protofunc.apply(this, Array.slice(arguments, 1));
+        }
+        return rv;
+    });
+
+    monkeyPatch(window, "editReminder", function(protofunc /*, ...args */) {
+        let rv = protofunc.apply(this, Array.slice(arguments, 1));
+
+        // Now that the custom reminders were changed, we need to remove the
+        // default alarm status, otherwise the wrong alarm will be set.
+        let customItem = document.getElementById("reminder-custom-menuitem");
+        if (customItem.reminders) {
+            for each (let reminder in customItem.reminders) {
+                reminder.deleteProperty("X-DEFAULT-ALARM");
+            }
+        }
+
+        return rv;
+    });
+})();
diff --git a/calendar/providers/gdata/content/gdata-calendar-event-dialog.xul b/calendar/providers/gdata/content/gdata-calendar-event-dialog.xul
index e728308..639e75e 100644
--- a/calendar/providers/gdata/content/gdata-calendar-event-dialog.xul
+++ b/calendar/providers/gdata/content/gdata-calendar-event-dialog.xul
@@ -7,6 +7,7 @@
 
 <overlay id="gdata-calendar-event-dialog"
          xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
+  <script type="application/javascript" src="chrome://gdata-provider/content/gdata-calendar-event-dialog.js"/>
 
   <!-- Privacy items -->
   <menupopup id="options-privacy-menupopup">
@@ -37,4 +38,12 @@
           privacy="DEFAULT"
           provider="gdata"/>
   </statusbarpanel>
+
+  <menupopup id="item-alarm-menupopup">
+    <menuitem id="gdata-reminder-default-menuitem"
+              insertbefore="reminder-none-separator"
+              label="&gdata.reminder.default;"
+              provider="gdata"
+              value="default"/>
+  </menupopup>
 </overlay>
diff --git a/calendar/providers/gdata/content/gdata-calendar-properties.js b/calendar/providers/gdata/content/gdata-calendar-properties.js
new file mode 100644
index 0000000..34734e3
--- /dev/null
+++ b/calendar/providers/gdata/content/gdata-calendar-properties.js
@@ -0,0 +1,33 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+(function() {
+    Components.utils.import("resource://gdata-provider/modules/gdataUtils.jsm");
+    monkeyPatch(window, "onLoad", function(protofunc) {
+        let rv = protofunc.apply(this, Array.slice(arguments, 1));
+        if (gCalendar.type == "gdata") {
+            let accessRole = gCalendar.getProperty("settings.accessRole");
+            let isReader = (accessRole == "freeBusyReader" || accessRole == "reader");
+            let isEventsCalendar = gCalendar.getProperty("capabilities.events.supported");
+            let isDisabled = gCalendar.getProperty("disabled");
+
+            // Disable setting read-only if the calendar is readonly anyway
+            document.getElementById("read-only").disabled = isDisabled || (isEventsCalendar && isReader);
+
+            // Don't allow setting refresh interval to 30 minutes or less
+            let refInterval = document.getElementById("calendar-refreshInterval-menupopup");
+            Array.slice(refInterval.childNodes).filter(function(n) {
+                let nv = parseInt(n.getAttribute("value"), 10);
+                return nv < 30 && nv != 0;
+            }).forEach(function(n) refInterval.removeChild(n));
+
+            // Old Lightning doesn't hide the cache label
+            let oldCacheLabel = document.getElementById("cache");
+            if (oldCacheLabel) {
+                oldCacheLabel.setAttribute("hidden", "true");
+            }
+        }
+        return rv;
+    });
+})();
diff --git a/calendar/providers/gdata/content/gdata-calendar-properties.xul b/calendar/providers/gdata/content/gdata-calendar-properties.xul
new file mode 100644
index 0000000..4683a2c
--- /dev/null
+++ b/calendar/providers/gdata/content/gdata-calendar-properties.xul
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this
+   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+
+<overlay id="gdata-calendar-event-dialog"
+         xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
+  <script type="application/javascript" src="chrome://gdata-provider/content/gdata-calendar-properties.js"/>
+</overlay>
diff --git a/calendar/providers/gdata/content/gdata-event-dialog-reminder.js b/calendar/providers/gdata/content/gdata-event-dialog-reminder.js
new file mode 100644
index 0000000..8f889d1
--- /dev/null
+++ b/calendar/providers/gdata/content/gdata-event-dialog-reminder.js
@@ -0,0 +1,72 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+(function() {
+    const FOUR_WEEKS_BEFORE = -2419200;
+    Components.utils.import("resource://gdata-provider/modules/gdataUtils.jsm");
+
+    // NOTE: This function exits early if its not a gdata calendar
+    let item = window.arguments[0].item;
+    let calendar = window.arguments[0].calendar;
+    if (calendar.type != "gdata") {
+        return;
+    }
+
+    let label = getProviderString("reminderOutOfRange");
+    let notification = createXULElement("notification");
+    notification.setAttribute("label", label);
+    notification.setAttribute("type", "critical");
+    notification.setAttribute("hideclose", "true");
+
+    function checkReminderRange(reminder) {
+        let offset = cal.alarms.calculateAlarmOffset(item, reminder);
+        let seconds = offset.inSeconds;
+        return (seconds < 1 && seconds >= FOUR_WEEKS_BEFORE);
+    }
+
+    function checkAllReminders() {
+        let listbox = document.getElementById("reminder-listbox");
+        let notificationbox = document.getElementById("reminder-notifications");
+
+        let validated = true;
+        for each (let node in Array.slice(listbox.childNodes)) {
+            validated = validated && checkReminderRange(node.reminder);
+            if (!validated) {
+                break;
+            }
+        }
+
+        let acceptButton = document.documentElement.getButton("accept");
+        acceptButton.disabled = !validated;
+
+        if (validated) {
+            try {
+                notificationbox.removeNotification(notification);
+            } catch (e) {
+                // Ok to swallow if it hasn't been added yet.
+            }
+        } else {
+            notificationbox.appendChild(notification);
+        }
+    }
+
+    monkeyPatch(window, "updateReminder", function(protofunc, event) {
+        let rv = protofunc.apply(this, Array.slice(arguments, 1));
+        if (event.explicitOriginalTarget.localName == "listitem" ||
+            event.explicitOriginalTarget.id == "reminder-remove-button" ||
+            !document.commandDispatcher.focusedElement) {
+            // Same hack from the original dialog
+            return;
+        }
+
+        checkAllReminders();
+        return rv;
+    });
+
+    monkeyPatch(window, "loadReminders", function(protofunc /*, ...args */) {
+        let rv = protofunc.apply(this, Array.slice(arguments, 1));
+        checkAllReminders();
+        return rv;
+    });
+})();
diff --git a/calendar/providers/gdata/content/gdata-event-dialog-reminder.xul b/calendar/providers/gdata/content/gdata-event-dialog-reminder.xul
index 9332073..ce75f12 100644
--- a/calendar/providers/gdata/content/gdata-event-dialog-reminder.xul
+++ b/calendar/providers/gdata/content/gdata-event-dialog-reminder.xul
@@ -9,6 +9,7 @@
 
 <overlay id="gdata-event-dialog-reminder-overlay"
          xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
+  <script type="application/javascript" src="chrome://gdata-provider/content/gdata-event-dialog-reminder.js"/>
   <menupopup id="reminder-actions-menupopup">
     <menuitem id="reminder-action-SMS"
               class="reminder-icon menuitem-iconic"
diff --git a/calendar/providers/gdata/content/gdata-list-tree.xml b/calendar/providers/gdata/content/gdata-list-tree.xml
new file mode 100644
index 0000000..f6533a6
--- /dev/null
+++ b/calendar/providers/gdata/content/gdata-list-tree.xml
@@ -0,0 +1,233 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this
+   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+
+<!DOCTYPE overlay SYSTEM "chrome://calendar/locale/calendar.dtd">
+
+<bindings id="gdata-list-tree-bindings"
+          xmlns="http://www.mozilla.org/xbl"
+          xmlns:xbl="http://www.mozilla.org/xbl"
+          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
+
+  <binding id="gdata-list-tree" extends="chrome://calendar/content/widgets/calendar-list-tree.xml#calendar-list-tree">
+    <content>
+      <xul:tree anonid="tree"
+                xbl:inherits="hidecolumnpicker"
+                hidecolumnpicker="true"
+                seltype="single"
+                flex="1">
+        <xul:treecols anonid="treecols"
+                      xbl:inherits="hideheader"
+                      hideheader="true">
+          <xul:treecol anonid="checkbox-treecol"
+                       xbl:inherits="cycler,hideheader"
+                       cycler="true"
+                       hideheader="true"
+                       width="17"/>
+          <xul:treecol anonid="color-treecol"
+                       xbl:inherits="cycler,hideheader"
+                       hideheader="true"
+                       width="16"/>
+          <xul:treecol anonid="calendarname-treecol"
+                       xbl:inherits="cycler,hideheader"
+                       primary="true"
+                       hideheader="true"
+                       label="&calendar.unifinder.tree.calendarname.label;"
+                       flex="1"/>
+          <xul:treecol anonid="status-treecol"
+                       xbl:inherits="cycler,hideheader"
+                       hideheader="true"
+                       width="18"/>
+          <children includes="treecol"/>
+          <xul:treecol anonid="scrollbar-spacer"
+                       xbl:inherits="cycler,hideheader"
+                       fixed="true"
+                       hideheader="true">
+            <!-- This is a very elegant workaround to make sure the last column
+                 is not covered by the scrollbar in case of an overflow. This
+                 treecol needs to be here last -->
+            <xul:slider anonid="scrollbar-slider" orient="vertical"/>
+          </xul:treecol>
+        </xul:treecols>
+        <xul:treechildren anonid="treechildren"
+                          xbl:inherits="tooltip=childtooltip,context=childcontext"
+                          tooltip="_child"
+                          context="_child"
+                          ondragstart="onDragStart(event);"
+                          onoverflow="displayScrollbarSpacer(true)"
+                          onunderflow="displayScrollbarSpacer(false)">
+          <children includes="tooltip|menupopup"/>
+        </xul:treechildren>
+      </xul:tree>
+    </content>
+    <implementation>
+      <constructor><![CDATA[
+        this.tree.view = this;
+      ]]></constructor>
+      <property name="mockCalendarHeader" readonly="true">
+        <getter><![CDATA[
+          let calmgr = cal.getCalendarManager();
+          let uri = "dummy://calendar";
+          let mem = calmgr.createCalendar("memory", Services.io.newURI(uri, null, null));
+          mem.setProperty("disabled", true);
+          mem.name = "Calendars";
+          mem.id = cal.getUUID();
+          return mem;
+        ]]></getter>
+      </property>
+      <property name="mockTaskHeader" readonly="true">
+        <getter><![CDATA[
+          let calmgr = cal.getCalendarManager();
+          let uri = "dummy://tasks";
+          let mem = calmgr.createCalendar("memory", Services.io.newURI(uri, null, null));
+          mem.setProperty("disabled", true);
+          mem.name = "Task Lists";
+          mem.id = cal.getUUID();
+          return mem;
+        ]]></getter>
+      </property>
+      <field name="mCalendarHeaderIndex">0</field>
+      <field name="mTasksHeaderIndex">0</field>
+
+      <field name="QueryInterface">XPCOMUtils.generateQI([Components.interfaces.nsITreeView])</field>
+
+      <property name="calendars">
+        <getter><![CDATA[
+          return this.mCalendarList;
+        ]]></getter>
+        <setter><![CDATA[
+            for (let i = 0; i < val.length; i++) {
+                let calendar = val[i];
+                let spec = calendar.uri.spec;
+                if (calendar.type == "memory") {
+                    if (spec == "dummy://calendar") {
+                        this.mCalendarHeaderIndex = i;
+                    } else if (spec == "dummy://tasks") {
+                        this.mTasksHeaderIndex = i;
+                    }
+                }
+                this.addCalendar(calendar);
+            }
+            return this.mCalendarList;
+        ]]></setter>
+      </property>
+
+      <method name="removeCalendar">
+        <parameter name="aCalendar"/>
+        <body><![CDATA[
+          let index = this.findIndexById(aCalendar.id);
+          if (index < this.mCalendarHeaderIndex) {
+            this.mCalendarHeaderIndex--;
+          }
+          if (index < this.mTasksHeaderIndex) {
+            this.mTasksHeaderIndex--;
+          }
+          return this.__proto__.__proto__.removeCalendar.call(this, aCalendar);
+        ]]></body>
+      </method>
+
+      <method name="clear">
+        <body><![CDATA[
+          let calendars = this.mCalendarList.concat([]);
+          calendars.forEach(this.removeCalendar, this);
+        ]]></body>
+      </method>
+
+      <method name="getRowProperties">
+        <parameter name="aRow"/>
+        <parameter name="aProps"/>
+        <body><![CDATA[
+          let props = this.__proto__.__proto__.getRowProperties.call(this, aRow, aProps);
+          let calendar = this.getCalendar(aRow);
+
+          if (calendar.readOnly) {
+              if (aProps) {
+                  // Compatibility with old tree props code
+                  aProps.AppendElement(cal.getAtomFromService("checked"));
+              } else {
+                  props += " checked";
+              }
+          }
+
+          return props;
+        ]]></body>
+      </method>
+
+      <method name="isContainerEmpty">
+        <parameter name="aRow"/>
+        <body><![CDATA[
+         return ((aRow == this.mCalendarHeaderIndex &&
+                  aRow + 1 == this.mTasksHeaderIndex) ||
+                 (aRow == this.mTasksHeaderIndex &&
+                  aRow == this.mCalendarList.lengh));
+        ]]></body>
+      </method>
+
+      <method name="isContainer">
+        <parameter name="aRow"/>
+        <body><![CDATA[
+          let calendar = this.getCalendar(aRow);
+          return (calendar.type == "memory" && calendar.uri.schemeIs("dummy"));
+        ]]></body>
+      </method>
+
+      <method name="isContainerOpen">
+        <parameter name="aRow"/>
+        <body><![CDATA[
+          return true;
+        ]]></body>
+      </method>
+
+      <method name="getParentIndex">
+        <parameter name="aRow"/>
+        <body><![CDATA[
+          let calendar = this.getCalendar(aRow);
+          if (calendar.uri.path.contains("?calendar")) {
+              return this.mCalendarHeaderIndex;
+          } else if (calendar.uri.path.contains("?tasks")) {
+              return this.mTasksHeaderIndex;
+          } else {
+              return -1;
+          }
+        ]]></body>
+      </method>
+
+      <method name="hasNextSibling">
+        <parameter name="aRow"/>
+        <parameter name="aAfterIndex"/>
+        <body><![CDATA[
+          if (aRow == this.mCalendarHeaderIndex) {
+              return aAfterIndex < this.mTasksHeaderIndex;
+          } else if (aRow == this.mTasksHeaderIndex) {
+              return false;
+          } else {
+              return aAfterIndex != this.mCalendarHeaderIndex - 1 &&
+                     aAfterIndex != this.mTasksHeaderIndex - 1;
+          }
+        ]]></body>
+      </method>
+      <method name="cycleCell">
+        <parameter name="aRow"/>
+        <parameter name="aCol"/>
+        <body><![CDATA[
+          let calendar = this.getCalendar(aRow);
+          let composite = this.compositeCalendar;
+          if (composite.getCalendarById(calendar.id)) {
+              composite.removeCalendar(calendar);
+          } else {
+              composite.addCalendar(calendar);
+          }
+          this.treebox.invalidateRow(aRow);
+        ]]></body>
+      </method>
+
+      <method name="getLevel">
+        <parameter name="aRow"/>
+        <body><![CDATA[
+          return this.isContainer(aRow) ? 0 : 1;
+        ]]></body>
+      </method>
+    </implementation>
+  </binding>
+</bindings>
diff --git a/calendar/providers/gdata/content/gdata-migration.js b/calendar/providers/gdata/content/gdata-migration.js
index 3380861..df4cfe9 100644
--- a/calendar/providers/gdata/content/gdata-migration.js
+++ b/calendar/providers/gdata/content/gdata-migration.js
@@ -2,8 +2,10 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-Components.utils.import("resource://calendar/modules/calUtils.jsm");
-Components.utils.import("resource://gre/modules/Preferences.jsm");
+Components.utils.import("resource://gdata-provider/modules/shim/Loader.jsm").shimIt(this);
+
+CuImport("resource://calendar/modules/calUtils.jsm", this);
+CuImport("resource://gre/modules/Preferences.jsm", this);
 
 /**
  * Migrate the calendar selected in the wizard from ics to gdata.
diff --git a/calendar/providers/gdata/defaults/preferences.js b/calendar/providers/gdata/defaults/preferences.js
index f544699..e1c514d 100644
--- a/calendar/providers/gdata/defaults/preferences.js
+++ b/calendar/providers/gdata/defaults/preferences.js
@@ -12,6 +12,8 @@ pref("extensions.{a62ef8ec-5fdc-40c2-873c-223b8a6925cc}.name",
 pref("calendar.google.useHTTPMethodOverride", true);
 pref("calendar.google.alarmClosest", true);
 pref("calendar.google.migrate", true);
+pref("calendar.google.maxResultsPerRequest", 1000);
+pref("calendar.google.idleTime", 300);
 
 /**
  * Invitations and notifications.
diff --git a/calendar/providers/gdata/install.rdf b/calendar/providers/gdata/install.rdf
index cca969d..370f4d2 100644
--- a/calendar/providers/gdata/install.rdf
+++ b/calendar/providers/gdata/install.rdf
@@ -15,10 +15,19 @@
     <!-- Target Application this extension can install into,
          with minimum and maximum supported versions. -->
     <em:targetApplication>
+      <!-- Postbox -->
+      <Description>
+        <em:id>postbox@postbox-inc.com</em:id>
+        <em:minVersion>3.0.0b1</em:minVersion>
+        <em:maxVersion>3.0.*</em:maxVersion>
+      </Description>
+    </em:targetApplication>
+
+    <em:targetApplication>
       <Description>
         <!-- Thunderbird -->
         <em:id>{3550f703-e582-4d05-9a08-453d09bdfdc6}</em:id>
-        <em:minVersion>17.0a1</em:minVersion>
+        <em:minVersion>24.0</em:minVersion>
         <em:maxVersion>@THUNDERBIRD_VERSION@</em:maxVersion>
       </Description>
     </em:targetApplication>
@@ -26,7 +35,7 @@
       <Description>
         <!-- SeaMonkey -->
         <em:id>{92650c4d-4b8e-4d2a-b7eb-24ecf4f6b63a}</em:id>
-        <em:minVersion>2.14a1</em:minVersion>
+        <em:minVersion>2.21</em:minVersion>
         <em:maxVersion>@SEAMONKEY_VERSION@</em:maxVersion>
       </Description>
     </em:targetApplication>
diff --git a/calendar/providers/gdata/jar.mn b/calendar/providers/gdata/jar.mn
index 2ed3412..f8626e1 100644
--- a/calendar/providers/gdata/jar.mn
+++ b/calendar/providers/gdata/jar.mn
@@ -6,15 +6,26 @@
 
 gdata-provider.jar:
 % content gdata-provider %content/
-% overlay chrome://calendar/content/calendarCreation.xul chrome://gdata-provider/content/calendarCreation.xul
+% resource gdata-provider .
+% overlay chrome://calendar/content/calendarCreation.xul chrome://gdata-provider/content/gdata-calendar-creation.xul
 % overlay chrome://messenger/content/messenger.xul chrome://gdata-provider/content/gdata-migration-overlay.xul  application={3550f703-e582-4d05-9a08-453d09bdfdc6}
 % overlay chrome://calendar/content/calendar-event-dialog.xul chrome://gdata-provider/content/gdata-calendar-event-dialog.xul
 % overlay chrome://calendar/content/calendar-event-dialog-reminder.xul chrome://gdata-provider/content/gdata-event-dialog-reminder.xul
+% overlay chrome://calendar/content/calendar-properties-dialog.xul chrome://gdata-provider/content/gdata-calendar-properties.xul
 % style chrome://calendar/content/calendar-event-dialog.xul chrome://gdata-provider/skin/gdata-event-dialog-reminder.css
 % style chrome://messenger/content/messenger.xul chrome://gdata-provider/skin/gdata-event-dialog-reminder.css   application={3550f703-e582-4d05-9a08-453d09bdfdc6}
-    content/calendarCreation.xul                 (content/calendarCreation.xul)
+% style chrome://messenger/content/messenger.xul chrome://gdata-provider/skin/gdata-event-dialog-reminder.css   application=postbox@postbox-inc.com
+    content/browserRequest.xul                   (content/browserRequest.xul)
+    content/browserRequest.js                    (content/browserRequest.js)
+    content/gdata-calendar-creation.xul          (content/gdata-calendar-creation.xul)
+    content/gdata-calendar-creation.js           (content/gdata-calendar-creation.js)
     content/gdata-calendar-event-dialog.xul      (content/gdata-calendar-event-dialog.xul)
+    content/gdata-calendar-event-dialog.js       (content/gdata-calendar-event-dialog.js)
+    content/gdata-calendar-properties.xul        (content/gdata-calendar-properties.xul)
+    content/gdata-calendar-properties.js         (content/gdata-calendar-properties.js)
     content/gdata-event-dialog-reminder.xul      (content/gdata-event-dialog-reminder.xul)
+    content/gdata-event-dialog-reminder.js       (content/gdata-event-dialog-reminder.js)
+    content/gdata-list-tree.xml                  (content/gdata-list-tree.xml)
     content/gdata-migration.js                   (content/gdata-migration.js)
     content/gdata-migration-overlay.xul          (content/gdata-migration-overlay.xul)
     content/gdata-migration-wizard.xul           (content/gdata-migration-wizard.xul)
@@ -22,3 +33,5 @@ gdata-provider.jar:
 % skin gdata-provider classic/1.0 %skin/
     skin/reminder-action-sms.png                 (content/reminder-action-sms.png)
     skin/gdata-event-dialog-reminder.css         (content/gdata-event-dialog-reminder.css)
+    skin/gdata-bindings.css                      (content/gdata-bindings.css)
+    skin/browserRequest.css                      (content/browserRequest.css)
diff --git a/calendar/providers/gdata/makeversion.py b/calendar/providers/gdata/makeversion.py
index c64b89f..f7b66a4 100644
--- a/calendar/providers/gdata/makeversion.py
+++ b/calendar/providers/gdata/makeversion.py
@@ -6,7 +6,20 @@ import sys
 import re
 
 # Converts a Lightning version to a matching gdata version:
-#  Lightning 1.2 -> gdata-provider 0.11
-#  Lightning 1.3a1 -> gdata-provider 0.12pre
-v = re.search(r"(\d+\.\d+)([a-z]\d+)?", sys.argv[1])
-print "{0:.2f}".format((float(v.group(1)) - 0.1)/10) + (v.lastindex == 2 and "pre" or "")
+#  Lightning 3.1 -> gdata-provider 1.0
+#  Lightning 3.2b2 -> gdata-provider 1.1b2
+#  Lightning 3.3a1 -> gdata-provider 1.2a1
+def makeversion(x):
+    v = re.search(r"(\d+\.\d+)([a-z]\d+)?", x)
+    parts = v.group(1).split('.')
+    major = int(parts[0]) - 2
+    minor = int(parts[1]) - 1
+    if minor < 0:
+        minor = 10 + minor
+        major = major - 1
+    parts[0] = str(major)
+    parts[1] = str(minor)
+    return '.'.join(parts) + (v.group(2) or "")
+
+if __name__ == '__main__':
+    print(makeversion(sys.argv[1]))
diff --git a/calendar/providers/gdata/modules/OAuth2.jsm b/calendar/providers/gdata/modules/OAuth2.jsm
new file mode 100644
index 0000000..a604a5f
--- /dev/null
+++ b/calendar/providers/gdata/modules/OAuth2.jsm
@@ -0,0 +1,273 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/**
+ * Provides OAuth 2.0 authentication
+ */
+var EXPORTED_SYMBOLS = ["OAuth2"];
+
+const {classes: Cc, interfaces: Ci, results: Cr, utils: Cu} = Components;
+
+Cu.import("resource:///modules/Services.jsm");
+Cu.import("resource:///modules/XPCOMUtils.jsm");
+Cu.import("resource:///modules/gloda/log4moz.js");
+
+let httpRequest = (function() {
+  let scope = {};
+  try {
+    // Thunderbird 25+
+    Cu.import("resource://gre/modules/Http.jsm", scope);
+  } catch (e) {
+    try {
+      // Thunderbird 24
+      Cu.import("resource:///modules/http.jsm", scope);
+    } catch (e) {
+      // Thunderbird 7
+      Cu.import("resource://gdata-provider/modules/shim/Http.jsm", scope);
+    }
+  }
+
+  if ("httpRequest" in scope) {
+    // Thunderbird 25+ and Thunderbird 7
+    return scope.httpRequest;
+  } else {
+    // Thunderbird 24
+    return function(uri, options) {
+        return scope.doXHRequest(uri, null, options.postData, options.onLoad,
+                                 options.onError, undefined);
+    };
+  }
+})();
+
+function parseURLData(aData) {
+  let result = {};
+  aData.split(/[?#]/, 2)[1].split("&").forEach(function (aParam) {
+    let [key, value] = aParam.split("=");
+    result[key] = value;
+  });
+  return result;
+}
+
+function OAuth2(aBaseURI, aScope, aAppKey, aAppSecret) {
+    this.authURI = aBaseURI + "oauth2/auth";
+    this.tokenURI = aBaseURI + "oauth2/token";
+    this.consumerKey = aAppKey;
+    this.consumerSecret = aAppSecret;
+    this.scope = aScope;
+    this.extraAuthParams = [];
+
+    this.log = Log4Moz.getConfiguredLogger("TBOAuth");
+}
+
+OAuth2.CODE_AUTHORIZATION = "authorization_code";
+OAuth2.CODE_REFRESH = "refresh_token";
+
+OAuth2.prototype = {
+
+    responseType: "code",
+    consumerKey: null,
+    consumerSecret: null,
+    completionURI: "http://localhost",
+    requestWindowURI: "chrome://messenger/content/browserRequest.xul",
+    requestWindowFeatures: "chrome,private,centerscreen,width=980,height=600",
+    requestWindowTitle: "",
+    scope: null,
+
+    accessToken: null,
+    refreshToken: null,
+    tokenExpires: 0,
+    connecting: false,
+
+    connect: function connect(aSuccess, aFailure, aWithUI, aRefresh) {
+        if (this.connecting) {
+            return;
+        }
+
+        this.connectSuccessCallback = aSuccess;
+        this.connectFailureCallback = aFailure;
+
+        if (!aRefresh && this.accessToken) {
+            aSuccess();
+        } else if (this.refreshToken) {
+            this.connecting = true;
+            this.requestAccessToken(this.refreshToken, OAuth2.CODE_REFRESH);
+        } else {
+            if (!aWithUI) {
+                aFailure('{ "error": "auth_noui" }');
+                return;
+            }
+            this.connecting = true;
+            this.requestAuthorization();
+        }
+    },
+
+    requestAuthorization: function requestAuthorization() {
+        let params = [
+            ["response_type", this.responseType],
+            ["client_id", this.consumerKey],
+            ["redirect_uri", this.completionURI],
+        ];
+        // The scope can be optional.
+        if (this.scope) {
+            params.push(["scope", this.scope]);
+        }
+
+        // Add extra parameters, if they exist
+        Array.prototype.push.apply(params, this.extraAuthParams);
+
+        // Now map the parameters to a string
+        params = params.map(function([k,v]) k + "=" + encodeURIComponent(v)).join("&");
+
+        this._browserRequest = {
+            account: this,
+            url: this.authURI + "?" + params,
+            _active: true,
+            iconURI: "",
+            cancelled: function() {
+                if (!this._active) {
+                    return;
+                }
+
+                this.account.finishAuthorizationRequest();
+                this.account.onAuthorizationFailed(Components.results.NS_ERROR_ABORT, '{ "error": "cancelled"}');
+            },
+
+            loaded: function (aWindow, aWebProgress) {
+                if (!this._active) {
+                    return;
+                }
+
+                this._listener = {
+                    window: aWindow,
+                    webProgress: aWebProgress,
+                    _parent: this.account,
+
+                    QueryInterface: XPCOMUtils.generateQI([Ci.nsIWebProgressListener,
+                                                           Ci.nsISupportsWeakReference]),
+
+                    _cleanUp: function() {
+                      this.webProgress.removeProgressListener(this);
+                      this.window.close();
+                      delete this.window;
+                    },
+
+                    _checkForRedirect: function(aURL) {
+                      if (aURL.indexOf(this._parent.completionURI) != 0)
+                        return;
+
+                      this._parent.finishAuthorizationRequest();
+                      this._parent.onAuthorizationReceived(aURL);
+                    },
+
+                    onStateChange: function(aWebProgress, aRequest, aStateFlags, aStatus) {
+                      const wpl = Ci.nsIWebProgressListener;
+                      if (aStateFlags & (wpl.STATE_STOP)) {
+                        try {
+                            let httpchannel = aRequest.QueryInterface(Components.interfaces.nsIHttpChannel);
+
+                            let responseCategory = Math.floor(httpchannel.responseStatus / 100);
+
+                            if (responseCategory != 2 && responseCategory != 3) {
+                                this._parent.finishAuthorizationRequest();
+                                this._parent.onAuthorizationFailed(null, '{ "error": "http_' + httpchannel.responseStatus + '" }');
+                            }
+                        } catch (e if e.result == Components.results.NS_ERROR_NO_INTERFACE) {
+                            // Catch the case where its not a http channel
+                        }
+                      }
+
+                      if (aStateFlags & (wpl.STATE_START | wpl.STATE_IS_NETWORK))
+                        this._checkForRedirect(aRequest.name);
+                    },
+                    onLocationChange: function(aWebProgress, aRequest, aLocation) {
+                      this._checkForRedirect(aLocation.spec);
+                    },
+                    onProgressChange: function() {},
+                    onStatusChange: function() {},
+                    onSecurityChange: function() {},
+                };
+                aWebProgress.addProgressListener(this._listener,
+                                                 Ci.nsIWebProgress.NOTIFY_ALL);
+                aWindow.document.title = this.account.requestWindowTitle;
+            }
+        };
+
+        this.wrappedJSObject = this._browserRequest;
+        Services.ww.openWindow(null, this.requestWindowURI, null, this.requestWindowFeatures, this);
+    },
+    finishAuthorizationRequest: function() {
+        if (!("_browserRequest" in this)) {
+            return;
+        }
+
+        this._browserRequest._active = false;
+        if ("_listener" in this._browserRequest) {
+            this._browserRequest._listener._cleanUp();
+        }
+        delete this._browserRequest;
+    },
+
+    onAuthorizationReceived: function(aData) {
+        this.log.info("authorization received" + aData);
+        let results = parseURLData(aData);
+        if (this.responseType == "code") {
+            this.requestAccessToken(results.code, OAuth2.CODE_AUTHORIZATION);
+        } else if (this.responseType == "token") {
+            this.onAccessTokenReceived(JSON.stringify(results));
+        }
+    },
+
+    onAuthorizationFailed: function(aError, aData) {
+        this.connecting = false;
+        this.connectFailureCallback(aData);
+    },
+
+    requestAccessToken: function requestAccessToken(aCode, aType) {
+        let params = [
+            ["client_id", this.consumerKey],
+            ["client_secret", this.consumerSecret],
+            ["grant_type", aType],
+        ];
+
+        if (aType == OAuth2.CODE_AUTHORIZATION) {
+            params.push(["code", aCode]);
+            params.push(["redirect_uri", this.completionURI]);
+        } else if (aType == OAuth2.CODE_REFRESH) {
+            params.push(["refresh_token", aCode]);
+        }
+
+        let options = {
+          postData: params,
+          onLoad: this.onAccessTokenReceived.bind(this),
+          onError: this.onAccessTokenFailed.bind(this)
+        }
+        httpRequest(this.tokenURI, options);
+    },
+
+    onAccessTokenFailed: function onAccessTokenFailed(aError, aData) {
+        if (aError != "offline") {
+            this.refreshToken = null;
+        }
+        this.connecting = false;
+        this.connectFailureCallback(aData);
+    },
+
+    onAccessTokenReceived: function onRequestTokenReceived(aData) {
+        let result = JSON.parse(aData);
+
+        this.accessToken = result.access_token;
+        if ("refresh_token" in result) {
+            this.refreshToken = result.refresh_token;
+        }
+        if ("expires_in" in result) {
+            this.tokenExpires = (new Date()).getTime() + (result.expires_in * 1000);
+        } else {
+            this.tokenExpires = Number.MAX_VALUE;
+        }
+        this.tokenType = result.token_type;
+
+        this.connecting = false;
+        this.connectSuccessCallback();
+    }
+};
diff --git a/calendar/providers/gdata/modules/gdataLogging.jsm b/calendar/providers/gdata/modules/gdataLogging.jsm
new file mode 100644
index 0000000..cbe4d3d
--- /dev/null
+++ b/calendar/providers/gdata/modules/gdataLogging.jsm
@@ -0,0 +1,130 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+var EXPORTED_SYMBOLS = ["LOGitem", "LOGverbose", "LOGinterval", "stringException"];
+
+Components.utils.import("resource://gdata-provider/modules/shim/Loader.jsm").shimIt(this);
+
+CuImport("resource://calendar/modules/calUtils.jsm", this);
+CuImport("resource://gre/modules/Preferences.jsm", this);
+
+function LOGverbose(aStr) {
+    if (Preferences.get("calendar.debug.log.verbose", false)) {
+        cal.LOG(aStr);
+    }
+}
+
+function stringException(e) {
+    if ("fileName" in e && "lineNumber" in e) {
+        return " (" + e.fileName + ":" + e.lineNumber + "):" + e;
+    } else {
+        return e.toString();
+    }
+}
+
+/**
+ * LOGitem
+ * Custom logging functions
+ */
+function LOGitem(item) {
+    if (!item) {
+        return;
+    }
+
+    let attendees = item.getAttendees({});
+    let attendeeString = "";
+    for each (let a in attendees) {
+        attendeeString += "\n" + LOGattendee(a);
+    }
+
+    let rstr = "\n";
+    if (item.recurrenceInfo) {
+        let ritems = item.recurrenceInfo.getRecurrenceItems({});
+        for each (let ritem in ritems) {
+            rstr += "\t\t" + ritem.icalProperty.icalString;
+        }
+
+        rstr += "\tExceptions:\n";
+        let exids = item.recurrenceInfo.getExceptionIds({});
+        for each (let exc in exids) {
+            rstr += "\t\t" + exc + "\n";
+        }
+    }
+
+    let astr = "\n";
+    let alarms = item.getAlarms({});
+    for each (let alarm in alarms) {
+        astr += "\t\t" + LOGalarm(alarm) + "\n";
+    }
+
+    LOGverbose("[calGoogleCalendar] Logging calIEvent:" +
+        "\n\tid:" + item.id +
+        "\n\tcreated:" + item.getProperty("CREATED") +
+        "\n\tupdated:" + item.getProperty("LAST-MODIFIED") +
+        "\n\ttitle:" + item.title +
+        "\n\tdescription:" + item.getProperty("DESCRIPTION") +
+        "\n\ttransparency:" + item.getProperty("TRANSP") +
+        "\n\tstatus:" + item.status +
+        "\n\tstartTime:" + (item.startDate && item.startDate.toString()) +
+        "\n\tendTime:" + (item.endDate && item.endDate.toString()) +
+        "\n\tlocation:" + item.getProperty("LOCATION") +
+        "\n\tprivacy:" + item.privacy +
+        "\n\tsequence:" + item.getProperty("SEQUENCE") +
+        "\n\talarmLastAck:" + item.alarmLastAck +
+        "\n\tsnoozeTime:" + item.getProperty("X-MOZ-SNOOZE-TIME") +
+        "\n\tisOccurrence: " + (item.recurrenceId != null) +
+        "\n\tOrganizer: " + LOGattendee(item.organizer) +
+        "\n\tAttendees: " + attendeeString +
+        "\n\trecurrence: " + (rstr.length > 1 ? "yes: " + rstr : "no") +
+        "\n\talarms: " + (astr.length > 1 ? "yes: " + astr : "no"));
+}
+
+function LOGattendee(aAttendee, asString) {
+    return aAttendee &&
+        ("\n\t\tID: " + aAttendee.id +
+         "\n\t\t\tName: " + aAttendee.commonName +
+         "\n\t\t\tRsvp: " + aAttendee.rsvp +
+         "\n\t\t\tIs Organizer: " + (aAttendee.isOrganizer ? "yes" : "no") +
+         "\n\t\t\tRole: " + aAttendee.role +
+         "\n\t\t\tStatus: " + aAttendee.participationStatus);
+}
+
+function LOGalarm(aAlarm) {
+    if (!aAlarm) {
+        return "";
+    }
+
+    let enumerator = aAlarm.propertyEnumerator;
+    let xpropstr = "";
+    while (enumerator && enumerator.hasMoreElements()) {
+        let el = enumerator.getNext();
+        xpropstr += "\n\t\t\t" + el.key + ":" + el.value;
+    }
+
+    return ("\n\t\tAction: " + aAlarm.action +
+            "\n\t\tOffset: " + (aAlarm.offset && aAlarm.offset.toString()) +
+            "\n\t\talarmDate: " + (aAlarm.alarmDate && aAlarm.alarmDate.toString()) +
+            "\n\t\trelated: " + aAlarm.related +
+            "\n\t\trepeat: " + aAlarm.repeat +
+            "\n\t\trepeatOffset: " + (aAlarm.repeatOffset && aAlarm.repeatOffset.toString()) +
+            "\n\t\trepeatDate: " + (aAlarm.repeatDate && aAlarm.repeatDate.toString()) +
+            "\n\t\tdescription: " + aAlarm.description +
+            "\n\t\tsummary: " + aAlarm.summary +
+            "\n\t\tproperties: " + (xpropstr.length > 0 ? "yes:" + xpropstr : "no"));
+}
+
+function LOGinterval(aInterval) {
+    const fbtypes = Components.interfaces.calIFreeBusyInterval;
+    if (aInterval.freeBusyType == fbtypes.FREE) {
+        type = "FREE";
+    } else if (aInterval.freeBusyType == fbtypes.BUSY) {
+        type = "BUSY";
+    } else {
+        type = aInterval.freeBusyType + "(UNKNOWN)";
+    }
+
+    cal.LOG("[calGoogleCalendar] Interval from " +
+            aInterval.interval.start + " to " + aInterval.interval.end +
+            " is " + type);
+}
diff --git a/calendar/providers/gdata/modules/gdataRequest.jsm b/calendar/providers/gdata/modules/gdataRequest.jsm
new file mode 100644
index 0000000..1d00e40
--- /dev/null
+++ b/calendar/providers/gdata/modules/gdataRequest.jsm
@@ -0,0 +1,513 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+Components.utils.import("resource://gdata-provider/modules/shim/Loader.jsm").shimIt(this);
+Components.utils.import("resource://gdata-provider/modules/gdataLogging.jsm");
+
+CuImport("resource://gre/modules/XPCOMUtils.jsm", this);
+CuImport("resource://gre/modules/Services.jsm", this);
+CuImport("resource://gre/modules/Promise.jsm", this);
+CuImport("resource://gre/modules/Preferences.jsm", this);
+
+CuImport("resource://calendar/modules/calUtils.jsm", this);
+
+const cIE = Components.interfaces.calIErrors;
+
+var API_BASE = {
+    EVENTS: "https://www.googleapis.com/calendar/v3/",
+    TASKS: "https://www.googleapis.com/tasks/v1/"
+};
+
+var EXPORTED_SYMBOLS = ["calGoogleRequest", "getCorrectedDate", "API_BASE"];
+
+/**
+ * Gets the date and time that Google's http server last sent us. Note the
+ * passed argument is modified. This might not be the exact server time (i.e it
+ * may be off by network latency), but it does give a good guess when syncing.
+ *
+ * @param aDate     The date to modify.
+ */
+function getCorrectedDate(aDate) {
+    if (getCorrectedDate.mClockSkew) {
+        aDate.second += getCorrectedDate.mClockSkew;
+    }
+    return aDate;
+}
+
+/**
+ * calGoogleRequest
+ * This class represents a HTTP request sent to Google
+ *
+ * @constructor
+ * @class
+ */
+function calGoogleRequest() {
+    this.mQueryParameters = new Map();
+    this.mRequestHeaders = new Map();
+    this.wrappedJSObject = this;
+}
+calGoogleRequest.LOGIN = 0;
+calGoogleRequest.ADD = 1;
+calGoogleRequest.MODIFY = 2;
+calGoogleRequest.DELETE = 3;
+calGoogleRequest.GET = 4;
+
+const GDATA_ERROR_BASE = Components.interfaces.calIErrors.ERROR_BASE + 0x400;
+calGoogleRequest.LOGIN_FAILED = GDATA_ERROR_BASE + 1;
+calGoogleRequest.CONFLICT_DELETED = GDATA_ERROR_BASE + 2;
+calGoogleRequest.CONFLICT_MODIFY = GDATA_ERROR_BASE + 3;
+calGoogleRequest.NOT_MODIFIED = GDATA_ERROR_BASE + 4;
+calGoogleRequest.QUOTA_FAILURE = GDATA_ERROR_BASE + 5;
+calGoogleRequest.TOKEN_FAILURE = GDATA_ERROR_BASE + 6;
+calGoogleRequest.RESOURCE_GONE = GDATA_ERROR_BASE + 7;
+
+calGoogleRequest.prototype = {
+
+    /* Members */
+    mUploadContent: null,
+    mUploadData: null,
+    mSession: null,
+    mQueryParameters: null,
+    mType: null,
+    mLoader: null,
+    mDeferred: null,
+    mStatus: Components.results.NS_OK,
+
+    /* Constants */
+    ADD: 1,
+    MODIFY: 2,
+    DELETE: 3,
+    GET: 4,
+
+    /* Simple Attributes */
+    method: "GET",
+    id: null,
+    uri: null,
+    calendar: null,
+    reauthenticate: true,
+    requestDate: null,
+
+    QueryInterface: XPCOMUtils.generateQI([
+        Components.interfaces.calIOperation,
+        Components.interfaces.nsIStreamLoaderObserver,
+        Components.interfaces.nsIInterfaceRequestor,
+        Components.interfaces.nsIChannelEventSink
+    ]),
+
+    /**
+     * Implement calIOperation
+     */
+    get isPending() {
+        return (this.mLoader && this.mLoader.request != null);
+    },
+
+    get status() {
+        if (this.isPending) {
+            return this.mLoader.request.status;
+        } else {
+            return this.mStatus;
+        }
+    },
+
+    cancel: function cGR_cancel(aStatus) {
+        if (this.isPending) {
+            if (this.mLoader) {
+                this.mLoader.request.cancel(aStatus);
+            }
+            this.mStatus = aStatus;
+        }
+    },
+
+    /**
+     * attribute type
+     * The type of this reqest. Must be one of
+     * GET, ADD, MODIFY, DELETE
+     */
+    get type() this.mType,
+
+    set type(v) {
+        switch (v) {
+            case this.GET: this.method = "GET"; break;
+            case this.ADD: this.method = "POST"; break;
+            case this.MODIFY: this.method = "PUT"; break;
+            case this.DELETE: this.method = "DELETE"; break;
+            default:
+                throw new Components.Exception("", Components.results.NS_ERROR_ILLEGAL_VALUE);
+                break;
+        }
+        return (this.mType = v);
+    },
+
+    /**
+     * setUploadData
+     * The HTTP body data for a POST or PUT request.
+     *
+     * @param aContentType The Content type of the Data.
+     * @param aData        The Data to upload.
+     */
+    setUploadData: function cGR_setUploadData(aContentType, aData) {
+        this.mUploadContent = aContentType;
+        this.mUploadData = aData;
+    },
+
+    addQueryParameter: function cGR_addQueryParameter(aKey, aValue) {
+        if (aValue) {
+            this.mQueryParameters.set(aKey, aValue);
+        } else {
+            this.mQueryParameters.delete(aKey);
+        }
+    },
+
+    addRequestHeader: function cGR_addRequestHeader(aKey, aValue) {
+        if (aValue) {
+            this.mRequestHeaders.set(aKey, aValue);
+        } else {
+            this.mRequestHeaders.delete(aKey);
+        }
+    },
+
+    /**
+     * commit
+     * Starts the request process. This can be called multiple times if the
+     * request should be repeated
+     *
+     * @param aSession  The session object this request should be made with.
+     *                  This parameter is optional.
+     */
+    commit: function cGR_commit(aSession) {
+        if (!this.mDeferred) {
+            this.mDeferred = Promise.defer();
+        }
+        let promise = this.mDeferred.promise;
+
+        try {
+            // Set the session to request with
+            if (aSession) {
+                this.mSession = aSession;
+            }
+
+            // create the channel
+            let uristring = this.uri;
+            if (this.mQueryParameters.size > 0) {
+                let params = [];
+
+                // Using forEach is needed for backwards compatibility
+                this.mQueryParameters.forEach(function(v, k) {
+                    params.push(k + "=" + encodeURIComponent(v));
+                });
+                uristring += "?" + params.join("&");
+            }
+            let uri = Services.io.newURI(uristring, null, null);
+            let channel = Services.io.newChannelFromURI(uri);
+            cal.LOG("[calGoogleRequest] Requesting " + this.method + " " +
+                    channel.URI.spec);
+
+            this.prepareChannel(channel);
+
+            channel = channel.QueryInterface(Components.interfaces.nsIHttpChannel);
+            channel.redirectionLimit = 3;
+
+            this.mLoader = cal.createStreamLoader();
+            channel.notificationCallbacks = this;
+            cal.sendHttpRequest(this.mLoader, channel, this);
+        } catch (e) {
+            // Let the response function handle the error that happens here
+            this.fail(e.result, e.message);
+        }
+        return promise;
+    },
+
+    /**
+     * fail
+     * Call this request's listener with the given code and Message
+     *
+     * @param aCode     The Error code to fail with.
+     * @param aMessage  The Error message. If this is null, an error Message
+     *                  from calGoogleRequest will be used.
+     */
+    fail: function cGR_fail(aCode, aMessage) {
+        let ex = new Components.Exception(aMessage, aCode);
+        this.mLoader = null;
+        this.mStatus = aCode;
+        this.mDeferred.reject(ex);
+        this.mDeferred = null;
+    },
+
+    /**
+     * succeed
+     * Call this request's listener with a Success Code and the given Result.
+     *
+     * @param aResult   The result Text of this request.
+     */
+    succeed: function cGR_succeed(aResult) {
+        this.mLoader = null;
+        this.mStatus = Components.results.NS_OK;
+        this.mDeferred.resolve(aResult);
+        this.mDeferred = null;
+    },
+
+    /**
+     * prepareChannel
+     * Prepares the passed channel to match this objects properties
+     *
+     * @param aChannel    The Channel to be prepared.
+     */
+    prepareChannel: function cGR_prepareChannel(aChannel) {
+        // No caching
+        aChannel.loadFlags |= Components.interfaces.nsIRequest.LOAD_BYPASS_CACHE;
+
+        // Set upload Data
+        if (this.mUploadData) {
+            let converter = Components.classes["@mozilla.org/intl/scriptableunicodeconverter"].
+                            createInstance(Components.interfaces.nsIScriptableUnicodeConverter);
+            converter.charset = "UTF-8";
+
+            let stream = converter.convertToInputStream(this.mUploadData);
+            aChannel = aChannel.QueryInterface(Components.interfaces.nsIUploadChannel);
+            aChannel.setUploadStream(stream, this.mUploadContent, -1);
+
+            cal.LOG("[calGoogleCalendar] Setting Upload Data (" +
+                    this.mUploadContent + "):\n" + this.mUploadData);
+        }
+
+        aChannel = aChannel.QueryInterface(Components.interfaces.nsIHttpChannel);
+
+        // Depending on the preference, we will use X-HTTP-Method-Override to
+        // get around some proxies. This will default to true.
+        if (Preferences.get("calendar.google.useHTTPMethodOverride", true) &&
+            (this.method == "PUT" || this.method == "DELETE")) {
+
+            aChannel.requestMethod = "POST";
+            aChannel.setRequestHeader("X-HTTP-Method-Override",
+                                      this.method,
+                                      false);
+            if (this.method == "DELETE") {
+                // DELETE has no body, set an empty one so that Google accepts
+                // the request.
+                aChannel.setRequestHeader("Content-Type",
+                                          "application/atom+xml; charset=UTF-8",
+                                          false);
+                aChannel.setRequestHeader("Content-Length", 0, false);
+            }
+        } else {
+            aChannel.requestMethod = this.method;
+        }
+
+        if (this.mRequestHeaders.size) {
+            cal.LOG("[calGoogleCalendar] Sending request headers: " + this.mRequestHeaders.toSource());
+        }
+
+        // Using forEach is needed for backwards compatibility
+        this.mRequestHeaders.forEach(function(v, k) {
+            aChannel.setRequestHeader(k, v, false);
+        });
+
+        // Add Authorization
+        let token = this.mSession.accessToken;
+        if (token) {
+            aChannel.setRequestHeader("Authorization",
+                                      "Bearer " + token,
+                                      false);
+        } else {
+            cal.WARN("[calGoogleCalendar] Missing access token for " +
+                     aChannel.URI.spec);
+        }
+    },
+
+    /**
+     * @see nsIInterfaceRequestor
+     * @see calProviderUtils.jsm
+     */
+    getInterface: cal.InterfaceRequestor_getInterface,
+
+    /**
+     * @see nsIChannelEventSink
+     */
+    asyncOnChannelRedirect: function cGR_onChannelRedirect(aOldChannel,
+                                                           aNewChannel,
+                                                           aFlags,
+                                                           aCallback) {
+        // all we need to do to the new channel is the basic preparation
+        this.prepareChannel(aNewChannel);
+        aCallback.onRedirectVerifyCallback(Components.results.NS_OK);
+    },
+
+    /**
+     * @see nsIStreamLoaderObserver
+     */
+    onStreamComplete: function cGR_onStreamComplete(aLoader,
+                                                    aContext,
+                                                    aStatus,
+                                                    aResultLength,
+                                                    aResult) {
+        if (!aResult || !Components.isSuccessCode(aStatus)) {
+            this.fail(aStatus, aResult);
+            return;
+        }
+
+        let httpChannel = aLoader.request.QueryInterface(Components.interfaces.nsIHttpChannel);
+
+        // Convert the stream, falling back to utf-8 in case its not given.
+        let result = cal.convertByteArray(aResult, aResultLength, httpChannel.contentCharset);
+        if (result === null) {
+            this.fail(Components.results.NS_ERROR_FAILURE,
+                      "Could not convert bytestream to Unicode: " + e);
+            return;
+        }
+
+        let objData;
+        try {
+            if (result.length) {
+                objData = JSON.parse(result);
+            } else {
+                objData = { status: "No Content" };
+            }
+        } catch (e) {
+            cal.ERROR("[calGoogleCalendar] Could not parse API response as " +
+                      "JSON: " + result);
+            this.fail(Components.results.NS_ERROR_FAILURE, result);
+        }
+
+        // Calculate Google Clock Skew
+        let serverDate = new Date(httpChannel.getResponseHeader("Date"));
+        let curDate = new Date();
+
+        // The utility function getCorrectedDate in calGoogleUtils.js receives
+        // its clock skew seconds from here. The clock skew is updated on each
+        // request and is therefore quite accurate. As this calculation doesn't
+        // take latency into account it might overlap 1-2 seconds, but better
+        // one event too much than one event too little.
+        getCorrectedDate.mClockSkew = Math.floor((curDate.getTime() - serverDate.getTime()) / 1000);
+        if (getCorrectedDate.mClockSkew != 0) {
+            cal.LOG("[calGoogleRequest] Clock skew is " + getCorrectedDate.mClockSkew + " seconds");
+        }
+
+        // Remember when this request happened
+        this.requestDate = cal.createDateTime();
+        this.requestDate.nativeTime = serverDate.getTime() * 1000;
+
+        cal.LOG("[calGoogleCalendar] Request " + this.method + " " +
+                httpChannel.URI.spec + " responded with HTTP "
+                + httpChannel.responseStatus);
+
+        // Handle all (documented) error codes
+        switch (httpChannel.responseStatus) {
+            case 200: /* No error. */
+            case 201: /* Creation of a resource was successful. */
+            case 204: /* No content */
+                // Everything worked out, we are done
+                if (this.calendar) {
+                    this.calendar.setProperty("currentStatus", 0);
+                }
+                this.succeed(objData);
+                break;
+            case 304: /* Not modified */
+                this.fail(calGoogleRequest.NOT_MODIFIED, objData);
+                break;
+            case 401: /* Authorization required. */
+            case 403: { /* Unsupported standard parameter, or authentication or
+                         Authorization failed. */
+                let reason = objData && objData.error &&
+                             objData.error.errors && objData.error.errors[0] &&
+                             objData.error.errors[0].reason;
+                cal.LOG("[calGoogleCalendar] Login failed for " + this.mSession.id +
+                        " HTTP Status: " + httpChannel.responseStatus +
+                        " Reason: " + (reason || result));
+                switch (reason) {
+                    case "invalid_client":
+                    case "unauthorized_client":
+                        this.mSession.notifyOutdated();
+                        if (this.calendar) {
+                            this.calendar.setProperty("disabled", true);
+                            this.calendar.setProperty("currentStatus", calGoogleRequest.TOKEN_FAILURE);
+                        }
+                        this.fail(calGoogleRequest.TOKEN_FAILURE, reason);
+                        break;
+                    case "variableTermLimitExceeded":
+                    case "userRateLimitExceeded":
+                    case "dailyLimitExceeded":
+                    case "quotaExceeded":
+                        this.mSession.notifyQuotaExceeded();
+                        if (this.calendar) {
+                            this.calendar.setProperty("disabled", true);
+                            this.calendar.setProperty("currentStatus", calGoogleRequest.QUOTA_FAILURE);
+                        }
+                        this.fail(calGoogleRequest.QUOTA_FAILURE, reason);
+                        break;
+                    case "insufficientPermissions":
+                        if (this.type == this.MODIFY || this.type == this.DELETE || this.type == this.ADD) {
+                            this.fail(cIE.MODIFICATION_FAILED, objData);
+                        } else {
+                            this.fail(cIE.READ_FAILED, objData);
+                        }
+                        break;
+                    case "authError":
+                    case "invalidCredentials":
+                        this.mSession.invalidate();
+                        if (this.reauthenticate) {
+                            this.reauthenticate = false;
+                            this.mSession.asyncItemRequest(this).then(function(aOperation, aData) {
+                                this.succeed(aData);
+                            }.bind(this), function(e) {
+                                this.fail(e.result, e.message || e);
+                            }.bind(this));
+                        } else {
+                            this.fail(calGoogleRequest.LOGIN_FAILED, reason);
+                        }
+                        break;
+                    default:
+                        if (this.calendar) {
+                            this.calendar.setProperty("currentStatus", Components.results.NS_ERROR_FAILURE);
+                        }
+                        this.fail(Components.results.NS_ERROR_FAILURE, result);
+                        break;
+                }
+
+                break;
+            }
+            case 404: /* The resource was not found on the server, which is
+                         also a conflict */
+                //  404 NOT FOUND: Resource (such as a feed or entry) not found.
+                // 410 Gone: Happens when deleting an event that has already
+                //           been deleted.
+                this.fail(calGoogleRequest.CONFLICT_DELETED, objData);
+                break;
+            case 410:
+                this.fail(calGoogleRequest.RESOURCE_GONE, objData);
+                break;
+            case 412:
+            case 409: /* Specified version number doesn't match resource's
+                         latest version number. */
+                this.fail(calGoogleRequest.CONFLICT_MODIFY, objData);
+                break;
+            case 400: {
+                // Some bad requests we can handle
+                let error = objData && objData.error &&
+                            objData.error.errors && objData.error.errors[0];
+
+                if (error.message == "Invalid sync token value.") {
+                    this.fail(calGoogleRequest.RESOURCE_GONE, objData);
+                    return;
+                }
+            }
+            // Otherwise fall through
+            default:
+                // The following codes are caught here:
+                //  500 INTERNAL SERVER ERROR: Internal error. This is the
+                //                             default code that is used for
+                //                             all unrecognized errors.
+                //
+
+                // Something else went wrong
+                let msg = "A request Error Occurred. Status Code: " +
+                          httpChannel.responseStatus + " " +
+                          httpChannel.responseStatusText + " Body: " +
+                          result;
+                cal.LOG("[calGoogleCalendar] " + msg);
+
+                this.fail(Components.results.NS_ERROR_NOT_AVAILABLE, msg);
+                break;
+        }
+    }
+};
diff --git a/calendar/providers/gdata/modules/gdataSession.jsm b/calendar/providers/gdata/modules/gdataSession.jsm
new file mode 100644
index 0000000..539815f
--- /dev/null
+++ b/calendar/providers/gdata/modules/gdataSession.jsm
@@ -0,0 +1,498 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+Components.utils.import("resource://gdata-provider/modules/shim/Loader.jsm").shimIt(this);
+Components.utils.import("resource://gdata-provider/modules/OAuth2.jsm");
+Components.utils.import("resource://gdata-provider/modules/gdataUtils.jsm");
+Components.utils.import("resource://gdata-provider/modules/gdataLogging.jsm");
+Components.utils.import("resource://gdata-provider/modules/gdataRequest.jsm");
+
+CuImport("resource://gre/modules/XPCOMUtils.jsm", this);
+CuImport("resource://gre/modules/Preferences.jsm", this);
+CuImport("resource://gre/modules/Services.jsm", this);
+CuImport("resource://gre/modules/Promise.jsm", this);
+CuImport("resource://gre/modules/Task.jsm", this);
+CuImport("resource://gre/modules/Timer.jsm", this);
+
+CuImport("resource:///modules/iteratorUtils.jsm", this);
+
+CuImport("resource://calendar/modules/calUtils.jsm", this);
+CuImport("resource://calendar/modules/calProviderUtils.jsm", this);
+
+const cIFBI = Components.interfaces.calIFreeBusyInterval;
+const nIPM = Components.interfaces.nsIPermissionManager;
+
+const NOTIFY_TIMEOUT = 60 * 1000;
+
+var EXPORTED_SYMBOLS = ["getGoogleSessionManager"];
+
+let gdataSessionMap = new Map();
+var calGoogleSessionManager = {
+    /**
+     * Get a Session object for the specified calendar. If aCreate is false,
+     * null will be returned if the session doesn't exist. Otherwise, the
+     * session will be created.
+     *
+     * @param aCalendar  The calendar to get the session for.
+     * @param aCreate    If true, the session will be created prior to returning.
+     * @return           The initialized session object.
+     */
+    getSessionByCalendar: function(aCalendar, aCreate) {
+        let id = null;
+        let uri = aCalendar.uri;
+        let host = (function() { try { return uri.host; } catch (e) {} })();
+        const protocols = ["http", "https", "webcal", "webcals"];
+
+        if (aCalendar.type != "gdata") {
+            return;
+        }
+
+        if (uri.schemeIs("googleapi")) {
+            let [fullUser, path] = uri.path.substr(2).split("/", 2);
+            id = fullUser || cal.getUUID();
+        } else if (host == "www.google.com" && uri.path.startsWith("/calendar/feeds") && protocols.some(function(s) uri.schemeIs(s))) {
+            let googleCalendarName = aCalendar.getProperty("googleCalendarName");
+            let googleUser = Preferences.get("calendar.google.calPrefs." + googleCalendarName  + ".googleUser");
+            id = googleUser || googleCalendarName || cal.getUUID();
+        }
+
+        return id ? this.getSessionById(id, aCreate) : null;
+    },
+
+    getSessionById: function(aSessionId, aCreate) {
+        // Check if the session exists
+        if (gdataSessionMap.has(aSessionId)) {
+            cal.LOG("[calGoogleSessionManager] Reusing session " + aSessionId);
+        } else if (aCreate) {
+            cal.LOG("[calGoogleSessionManager] Creating session " + aSessionId);
+            gdataSessionMap.set(aSessionId, new calGoogleSession(aSessionId));
+        }
+
+        return gdataSessionMap.get(aSessionId);
+    }
+};
+function getGoogleSessionManager() calGoogleSessionManager;
+
+/**
+ * calGoogleSession
+ * This Implements a Session object to communicate with google
+ *
+ * @constructor
+ * @class
+ * @param aId       The ID for the new session.
+ */
+function calGoogleSession(aId) {
+    this.mId = aId;
+    this.wrappedJSObject = this;
+
+    this.setupOAuth();
+
+    // Register a freebusy provider for this session
+    cal.getFreeBusyService().addProvider(this);
+}
+
+calGoogleSession.prototype = {
+    mId: null,
+    mSessionID: null,
+    mLoginPromise: null,
+
+    get id() this.mId,
+
+    notifyQuotaExceeded: function() {
+        let now = new Date();
+        let tt = (now - this.mLastNotified);
+        if (!this.mLastNotified || (now - this.mLastNotified) > NOTIFY_TIMEOUT) {
+            this.mLastNotified = now;
+            let title = getProviderString("extensions.{a62ef8ec-5fdc-40c2-873c-223b8a6925cc}.name");
+            let quotaString = getProviderString("quotaExceeded", this.id);
+            Services.prompt.alert(cal.getCalendarWindow(), title, quotaString);
+        } else {
+            cal.LOG("[calGoogleCalendar] Throttling quota notification, last was " + (now - this.mLastNotified) + " ms ago");
+        }
+    },
+
+    notifyOutdated: function() {
+        let now = new Date();
+        let tt = (now - this.mLastNotified);
+        if (!this.mLastNotified || (now - this.mLastNotified) > NOTIFY_TIMEOUT) {
+            this.mLastNotified = now;
+            let title = getProviderString("extensions.{a62ef8ec-5fdc-40c2-873c-223b8a6925cc}.name");
+            let outdatedString = getProviderString("providerOutdated");
+            Services.prompt.alert(cal.getCalendarWindow(), title, outdatedString);
+        } else {
+            cal.LOG("[calGoogleCalendar] Throttling outdated notification, last was " + (now - this.mLastNotified) + " ms ago");
+        }
+    },
+
+    setupOAuth: function setupOAuth() {
+        let sessionId = this.mId;
+        let authTitle = cal.calGetString("commonDialogs", "EnterUserPasswordFor",
+                                         [this.id], "global");
+
+        // Set up a new OAuth2 instance for logging in.
+        this.oauth = new OAuth2(OAUTH_BASE_URI, OAUTH_SCOPE, OAUTH_CLIENT_ID, OAUTH_CLIENT_SECRET);
+        this.oauth.extraAuthParams = [
+          ["login_hint", sessionId],
+          // Use application locale for login dialog
+          ["hl", Preferences.get("general.useragent.locale", "en-US")]
+        ];
+        this.oauth.requestWindowURI = "chrome://gdata-provider/content/browserRequest.xul";
+        this.oauth.requestWindowFeatures = "chrome,private,centerscreen,width=430,height=600";
+        this.oauth.requestWindowTitle = authTitle;
+
+        // Overwrite the refreshToken attribute, since we want to save it in
+        // the password manager
+        let pwMgrId = "Google Calendar OAuth Token";
+        Object.defineProperty(this.oauth, "refreshToken", {
+            get: function getRefreshToken() {
+                if (!this.mRefreshToken) {
+                    let pass = { value: null };
+                    try {
+                        cal.auth.passwordManagerGet(sessionId, pass, sessionId, pwMgrId);
+                    } catch (e if e.result == Components.results.NS_ERROR_ABORT) {
+                        // User might have cancelled the master password prompt, thats ok
+                    }
+                    this.mRefreshToken = pass.value;
+                }
+                return this.mRefreshToken;
+            },
+            set: function setRefreshToken(val) {
+                try {
+                    if (!val) {
+                        cal.auth.passwordManagerRemove(sessionId, sessionId, pwMgrId);
+                    } else {
+                        cal.auth.passwordManagerSave(sessionId, val, sessionId, pwMgrId);
+                    }
+                } catch (e if e.result == Components.results.NS_ERROR_ABORT) {
+                    // User might have cancelled the master password prompt, thats ok
+                }
+                return (this.mRefreshToken = val);
+            },
+            enumerable: true
+        });
+
+        // If the user has disabled cookies, we need to add an exception for
+        // Google so authentication works. If the user has explicitly blocked
+        // google.com then we won't overwrite the rule though.
+        if (Preferences.get("network.cookie.cookieBehavior") == 2) {
+            let found = null;
+            for (let perm in fixIterator(Services.perms.enumerator, Components.interfaces.nsIPermission)) {
+                if (perm.type == "cookie" && perm.host == "google.com") {
+                    found = perm;
+                    break;
+                }
+            }
+
+            if (!found || found.capability != nIPM.DENY_ACTION) {
+                Services.perms.remove("google.com", "cookie");
+                let uri = Services.io.newURI("http://google.com", null, null);
+                Services.perms.add(uri, "cookie", nIPM.ALLOW_ACTION, nIPM.EXPIRE_SESSION);
+            }
+        }
+    },
+
+    get accessToken() this.oauth.accessToken,
+    get refreshToken() this.oauth.refreshToken,
+    set refreshToken(val) this.oauth.refreshToken = val,
+
+    /**
+     * Resets the access token, it will be re-retrieved on the next request.
+     */
+    invalidate: function cGS_invalidate() {
+        cal.LOG("[calGoogleSession] Invalidating session, will reauthenticate on next request");
+        this.oauth.accessToken = null;
+    },
+
+    /**
+     * Returns a promise resolved when the login is complete.
+     */
+    login: function() {
+        if (this.mLoginPromise) {
+            return this.mLoginPromise;
+        }
+        let deferred = Promise.defer();
+
+        try {
+            // Start logging in
+            cal.LOG("[calGoogleCalendar] Logging in session " + this.mId);
+            let accessToken = this.accessToken;
+            let refreshToken = this.refreshToken;
+
+            let authSuccess = function() {
+                cal.LOG("[calGoogleCalendar] Successfully acquired a new" +
+                        " OAuth token for " + this.mId);
+                deferred.resolve(this.accessToken);
+            }.bind(this);
+
+            let authFailed = function(aData) {
+                cal.LOG("[calGoogleCalendar] Failed to acquire a new" +
+                        " OAuth token for " + this.mId + " data: " + aData);
+
+                let error = null;
+                if (aData) {
+                    let dataObj;
+                    try { dataObj = JSON.parse(aData); } catch (e) {}
+                    error = dataObj && dataObj.error;
+                }
+
+                if (error == "invalid_client" || error == "unauthorized_client" || error == "http_401") {
+                    this.notifyOutdated();
+                } else {
+                    cal.ERROR("[calGoogleSession] Authentication failure: " + aData);
+                }
+                deferred.reject(new Components.Exception(error));
+            }.bind(this);
+
+            let connect = function() {
+                // Use the async prompter to avoid multiple master password prompts
+                let self = this;
+                let promptlistener = {
+                    onPromptStart: function() {
+                        // Usually this function should be synchronous. The OAuth
+                        // connection itself is asynchronous, but if a master
+                        // password is prompted it will block on that.
+                        this.onPromptAuthAvailable();
+                        return true;
+                    },
+
+                    onPromptAuthAvailable: function() {
+                        self.oauth.connect(authSuccess, authFailed, true, false);
+                    },
+                    onPromptCanceled: authFailed
+                };
+                let asyncprompter = Components.classes["@mozilla.org/messenger/msgAsyncPrompter;1"]
+                                              .getService(Components.interfaces.nsIMsgAsyncPrompter);
+                asyncprompter.queueAsyncAuthPrompt("googleapi://" + this.id, false, promptlistener);
+            }.bind(this);
+
+            if (accessToken) {
+                deferred.resolve(accessToken);
+            } else {
+                cal.LOG("[calGoogleCalendar] No access token for " + this.mId +
+                        ", refreshing token");
+                // bug 901329: If the calendar window isn't loaded yet the
+                // master password prompt will show just the buttons and
+                // possibly hang. If we postpone until the window is loaded,
+                // all is well.
+                function postpone() {
+                    let win = cal.getCalendarWindow();
+                    if (!win || win.document.readyState != "complete") {
+                        setTimeout(postpone, 400);
+                    } else {
+                        connect();
+                    }
+                }
+                setTimeout(postpone, 0);
+            }
+        } catch (e) {
+            // If something went wrong, reset the login state just in case
+            cal.LOG("[calGoogleCalendar] Error Logging In: " + e);
+            deferred.reject(e);
+        }
+        return deferred.promise.then(function(accessToken) {
+            this.mLoginPromise = null;
+            return accessToken;
+        }.bind(this), function(e) {
+            this.mLoginPromise = null;
+            throw e;
+        }.bind(this));
+    },
+
+    /**
+     * asyncItemRequest
+     * get or post an Item from or to Google using the Queue.
+     *
+     * @param aRequest          The Request Object. This is an instance of
+     *                          calGoogleRequest.
+     */
+    asyncItemRequest: function cGS_asyncItemRequest(aRequest) {
+        let tokenExpiresIn = Math.floor((this.oauth.tokenExpires - (new Date()).getTime()) / 1000);
+        if (tokenExpiresIn < 0 && !this.mLoginPromise) {
+            cal.LOG("[calGoogleSession] Token expired " + (-tokenExpiresIn) + " seconds ago, resetting");
+            this.oauth.accessToken = null;
+        }
+
+        if (this.accessToken) {
+            // Already have a token, we can request directly. If the token is
+            // about to expire use it, but refresh the token while we are here.
+            if (tokenExpiresIn < 30 && !this.mLoginPromise) {
+                cal.LOG("[calGoogleSession] Token will expire in " + tokenExpiresIn + " seconds, refreshing");
+                this.mLoginPromise = this.login();
+                this.mLoginPromise.then(function() {
+                    cal.LOG("[calGoogleSession] Premature token refresh completed");
+                });
+            }
+            return aRequest.commit(this);
+        } else if (this.mLoginPromise) {
+            // We are logging in and have no token, queue the request
+            cal.LOG("[calGoogleSession] Adding item " + aRequest.uri + " to queue");
+            return this.mLoginPromise.then(function() {
+                return aRequest.commit(this);
+            }.bind(this), function(e) {
+                // If the user cancelled the login dialog, then disable the
+                // calendar until the next startup or manual enable.
+                if (aRequest.calendar && e.message == "cancelled") {
+                    aRequest.calendar.setProperty("disabled", true);
+                    aRequest.calendar.setProperty("auto-enabled", true);
+                    aRequest.calendar.setProperty("currentStatus",
+                                    Components.results.NS_ERROR_FAILURE);
+                }
+
+                throw e;
+            }.bind(this));
+        } else {
+            // Not logging in and no token, get the login promise and retry.
+            this.mLoginPromise = this.login();
+            return this.asyncItemRequest(aRequest);
+        }
+    },
+
+    asyncPaginatedRequest: function(aRequest, onFirst, onEach, onLast) {
+        return Task.spawn(function() {
+            let data = yield this.asyncItemRequest(aRequest);
+
+            if (onFirst) {
+                yield onFirst(data);
+            }
+
+            if (onEach) {
+                yield onEach(data);
+            }
+
+            if (data.nextPageToken) {
+                aRequest.addQueryParameter("pageToken", data.nextPageToken);
+                throw new Task.Result(yield this.asyncPaginatedRequest(aRequest, null, onEach, onLast));
+            } else if (onLast) {
+                throw new Task.Result(yield onLast(data));
+            }
+        }.bind(this));
+    },
+
+    /**
+     * calIFreeBusyProvider Implementation
+     */
+    getFreeBusyIntervals: function cGS_getFreeBusyIntervals(aCalId,
+                                                            aRangeStart,
+                                                            aRangeEnd,
+                                                            aBusyTypes,
+                                                            aListener) {
+        let completeSync = function(aIntervals) {
+            cal.LOG("[calGoogleCalendar] Freebusy query for " + aCalId +
+                    "suceeded, returning " + aIntervals.length + " intervals");
+            aListener.onResult({ status: Components.results.NS_OK }, aIntervals);
+        }.bind(this);
+
+        let failSync = function(aStatus, aMessage) {
+            cal.LOG("[calGoogleCalendar] Freebusy query for " + aCalId +
+                    " failed (" + aStatus + "): " + aMessage);
+            aListener.onResult({ status: aStatus }, aMessage);
+        }.bind(this);
+
+        if (aCalId.indexOf("@") < 0 || aCalId.indexOf(".") < 0 ||
+            !aCalId.toLowerCase().startsWith("mailto:")) {
+            // No valid email, screw it
+            return failSync(Components.results.NS_ERROR_FAILURE, null);
+        }
+
+        if (aRangeStart) {
+            aRangeStart = aRangeStart.getInTimezone(cal.UTC());
+        }
+        if (aRangeEnd) {
+            aRangeEnd = aRangeEnd.getInTimezone(cal.UTC());
+        }
+
+        let rfcRangeStart = cal.toRFC3339(aRangeStart);
+        let rfcRangeEnd = cal.toRFC3339(aRangeEnd);
+        /* 7 is the length of "mailto:", we've asserted this above */
+        let strippedCalId = aCalId.substr(7);
+
+        let requestData = {
+          timeMin: rfcRangeStart,
+          timeMax: rfcRangeEnd,
+          items: [ { id: strippedCalId } ]
+        };
+
+        let request = new calGoogleRequest();
+        request.type = request.ADD;
+        request.calendar = null;
+        request.uri = API_BASE.EVENTS + "freeBusy";
+        request.reauthenticate = false;
+        request.setUploadData("application/json; charset=UTF-8",
+                              JSON.stringify(requestData));
+
+        // Request Parameters
+        this.asyncItemRequest(request).then(function(aData) {
+            if ("calendars" in aData && strippedCalId in aData.calendars) {
+                let calData = aData.calendars[strippedCalId];
+                let reason = calData.errors && calData.errors[0] && calData.errors[0].reason;
+                if (reason) {
+                    cal.LOG("[calGoogleCalendar] Could not request freebusy for " + strippedCalId + ": " + reason);
+                    failSync(Components.results.NS_ERROR_FAILURE, reason);
+                } else {
+                    let utcZone = cal.UTC();
+                    cal.LOG("[calGoogleCalendar] Found " + calData.busy.length + " busy slots within range for " + strippedCalId);
+                    let busyRanges = calData.busy.map(function(entry) {
+                        let start = cal.fromRFC3339(entry.start, utcZone);
+                        let end = cal.fromRFC3339(entry.end, utcZone);
+                        let interval = new cal.FreeBusyInterval(aCalId, cIFBI.BUSY, start, end);
+                        LOGinterval(interval);
+                        return interval;
+                    });
+                    completeSync(busyRanges);
+                }
+            } else {
+                cal.ERROR("[calGoogleCalendar] Invalid freebusy response: " + aData.toSource());
+                failSync(Components.results.NS_ERROR_FAILURE, (aData && aData.toSource()));
+            }
+        }.bind(this), function(e) {
+            cal.ERROR("[calGoogleCalendar] Failed freebusy request: " + e);
+            return failSync(request.status, null);
+        }.bind(this));
+
+        return request;
+    },
+
+    getCalendarList: function() {
+        let calendarRequest = new calGoogleRequest();
+        calendarRequest.type = calendarRequest.GET;
+        calendarRequest.uri = API_BASE.EVENTS + "users/me/calendarList";
+
+        let items = [];
+        return this.asyncPaginatedRequest(calendarRequest, null, function(data) {
+            Array.prototype.push.apply(items, data.items);
+        }.bind(this), function() {
+            return items;
+        }.bind(this));
+    },
+
+    getTasksList: function() {
+        let tasksRequest = new calGoogleRequest();
+        tasksRequest.type = tasksRequest.GET;
+        tasksRequest.uri = API_BASE.TASKS + "users/@me/lists";
+        let items = [];
+        return this.asyncPaginatedRequest(tasksRequest, null, function(data) {
+            Array.prototype.push.apply(items, data.items);
+        }.bind(this), function() {
+            return items;
+        }.bind(this));
+    }
+};
+
+// Before you spend time trying to find out what this means, please note
+// that doing so and using the information WILL cause Google to revoke
+// this extension's privileges, which means not one Lightning user will
+// be able to connect to Google Calendar using Lightning. This will cause
+// unhappy users all around which means that the developers will have to
+// spend more time with user support, which means less time for features,
+// releases and bugfixes.  For a paid developer this would actually mean
+// financial harm.
+// Do you really want all of this to be your fault? Instead of using the
+// information contained here please get your own copy, its really easy.
+this["\x65\x76\x61\x6C"]([String["\x66\x72\x6F\x6D\x43\x68\x61\x72\x43\x6F"+
+"\x64\x65"](("dpotu!PBVUI`CBTF`VSJ>#iuuqt;00bddpvout/hpphmf/dpn0p0#<dpotu!"+
+"PBVUI`TDPQF>#iuuqt;00xxx/hpphmfbqjt/dpn0bvui0dbmfoebs!iuuqt;00xxx/hpphmfb"+
+"qjt/dpn0bvui0ubtlt#<dpotu!PBVUI`DMJFOU`JE>#758881386533.nrvnr8u9gw9:fdcmf"+
+"h8g:bc5s1eflb:l/bqqt/hpphmfvtfsdpoufou/dpn#<dpotu!PBVUI`DMJFOU`TFDSFU>#uY"+
+"JZpUr:b5JBhJSeys18uYbN#<")["\x63\x68\x61\x72\x43\x6F\x64\x65\x41\x74"](i)-1)
+for(i in (function(){let x=303; while (x--) yield x})())].reverse().join(""));
diff --git a/calendar/providers/gdata/modules/gdataUtils.jsm b/calendar/providers/gdata/modules/gdataUtils.jsm
new file mode 100644
index 0000000..75df15c
--- /dev/null
+++ b/calendar/providers/gdata/modules/gdataUtils.jsm
@@ -0,0 +1,1350 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+Components.utils.import("resource://gdata-provider/modules/shim/Loader.jsm").shimIt(this);
+Components.utils.import("resource://gdata-provider/modules/gdataLogging.jsm");
+Components.utils.import("resource://gdata-provider/modules/gdataRequest.jsm");
+Components.utils.import("resource://gdata-provider/modules/timezoneMap.jsm");
+
+CuImport("resource://gre/modules/Services.jsm", this);
+CuImport("resource://gre/modules/Preferences.jsm", this);
+CuImport("resource://gre/modules/Promise.jsm", this);
+CuImport("resource://gre/modules/Task.jsm", this);
+
+CuImport("resource://calendar/modules/calUtils.jsm", this);
+CuImport("resource://calendar/modules/calIteratorUtils.jsm", this);
+CuImport("resource://calendar/modules/calProviderUtils.jsm", this);
+
+const cIOL = Components.interfaces.calIOperationListener;
+const cIE = Components.interfaces.calIErrors;
+const cIC = Components.interfaces.calICalendar;
+
+const FOUR_WEEKS_IN_MINUTES = 40320;
+
+var EXPORTED_SYMBOLS = [
+    "ItemToJSON", "JSONToItem", "ItemSaver",
+    "checkResolveConflict", "getGoogleId",
+    "getItemMetadata", "saveItemMetadata",
+    "deleteItemMetadata", "migrateItemMetadata",
+    "JSONToAlarm", "getProviderString",
+    "monkeyPatch", "spinEventLoop",
+    /* backwards compatibility: */
+    "promisifyCalendar", "PromiseAll"
+];
+
+/**
+ * Retrives the Google ID associated with this event. This is either a simple
+ * id or the id in combination with the recurrence id.
+ *
+ * @param aItem             The Item to get the id for.
+ * @param aOfflineStorage   The offline storage that holds the metadata for this item.
+ */
+function getGoogleId(aItem, aOfflineStorage) {
+    let meta = getItemMetadata(aOfflineStorage, aItem) ||
+               getItemMetadata(aOfflineStorage, aItem.parentItem);
+    let baseId = meta ? meta.path : aItem.id.replace("@google.com", "");
+    if (aItem.recurrenceId) {
+        let recSuffix = "_" + aItem.recurrenceId.getInTimezone(cal.UTC()).icalString;
+        if (!baseId.endsWith(recSuffix)) {
+            baseId += recSuffix;
+        }
+    }
+    return baseId;
+}
+
+/**
+ * Save metadata for the given hash id.
+ *
+ * @param aOfflineStorage   The offline storage that holds the metadata for this item.
+ * @param aId               The hash id to save metadata with.
+ * @param aMetadata         The metadata object to save.
+ */
+function saveItemMetadata(aOfflineStorage, aId, aMetadata) {
+    // Save metadata using the same format as for the CalDAV provider, this
+    // will make things easier when upgrading to the new item based metadata.
+    let meta = [aMetadata.etag, aMetadata.path, false].join("\u001A");
+    aOfflineStorage.setMetaData(aId, meta);
+}
+
+/**
+ * Migrate item metadata from aOldItem to aNewItem. If aOldItem is a recurring
+ * event and an exception was turned into an EXDATE, the metadata will be
+ * updated accordingly.
+ *
+ * @param aOfflineStorage   The offline storage that holds the metadata for this item.
+ * @param aOldItem          The item to migrate from.
+ * @param aNewItem          The item to migrate to.
+ * @param aMetadata         The metadata for this new item.
+ */
+function migrateItemMetadata(aOfflineStorage, aOldItem, aNewItem, aMetadata) {
+    if (aNewItem.status == "CANCELLED") {
+        deleteItemMetadata(aOfflineStorage, aNewItem);
+    } else {
+        saveItemMetadata(aOfflineStorage, aNewItem.hashId, aMetadata);
+    }
+
+    // If an exception was turned into an EXDATE, we need to clear its metadata
+    if (aOldItem.recurrenceInfo && aNewItem.recurrenceInfo) {
+        let newExIds = new Set(aNewItem.recurrenceInfo.getExceptionIds({}).map(function(x) x.icalString));
+        for each (let exId in aOldItem.recurrenceInfo.getExceptionIds({})) {
+            if (!newExIds.has(exId.icalString)) {
+                let ex = aOldItem.recurrenceInfo.getExceptionFor(exId);
+                deleteItemMetadata(aOfflineStorage, ex);
+            }
+        }
+    }
+}
+
+/**
+ * Delete metadata for the given item.
+ *
+ * @param aOfflineStorage   The offline storage that holds the metadata for this item.
+ * @param aItem             The item to delete metadata for.
+ */
+function deleteItemMetadata(aOfflineStorage, aItem) {
+    aOfflineStorage.deleteMetaData(aItem.hashId);
+    if (aItem.recurrenceInfo) {
+        let recInfo = aItem.recurrenceInfo;
+        for each (let exId in recInfo.getExceptionIds({})) {
+            let occ = recInfo.getExceptionFor(exId);
+            aOfflineStorage.deleteMetaData(occ.hashId);
+        }
+    }
+}
+
+/**
+ * Retrieve the item metadata for the given item
+ *
+ * @param aOfflineStorage   The offline storage that holds the metadata for this item.
+ * @param aItem             The item to retrieve metadat for.
+ */
+function getItemMetadata(aOfflineStorage, aItem) {
+    let data = null;
+    let meta = aOfflineStorage.getMetaData(aItem.hashId);
+    let parts = meta && meta.split("\u001A");
+    if (parts && parts.length == 3) {
+        data = { etag: parts[0], path: parts[1] };
+    } else if (parts && parts.length == 1) {
+        // Temporary migration for alpha versions of this provider.
+        data = { etag: parts[0], path: aItem.getProperty("X-GOOGLE-ID") }
+    }
+    return data;
+}
+
+/**
+ * Covnvert a calIDateTime date to the JSON object expected by Google.
+ *
+ * @param aDate     The date to convert.
+ * @return          The converted JS Object.
+ */
+function dateToJSON(aDate) {
+    let jsonData = {};
+    let tzid = aDate.timezone.tzid;
+    jsonData[aDate.isDate ? "date" : "dateTime"] = cal.toRFC3339(aDate);
+    if (!aDate.isDate && tzid != "floating") {
+        if (tzid in windowsTimezoneMap) {
+            // A Windows timezone, likely an outlook invitation.
+            jsonData.timeZone = windowsTimezoneMap[tzid];
+        } else if (tzid.match(/^[^\/ ]+\/[^\/ ]+$/)) {
+            // An Olson timezone id
+            jsonData.timeZone = aDate.timezone.tzid;
+        } else {
+            // Uhh...something. Google requires a timezone id for recurring
+            // events, we can fake it with Etc/ timezones.
+            let full_tzoffset = aDate.timezoneOffset;
+            let tzoffset_hr = Math.floor(Math.abs(full_tzoffset) / 3600);
+            let sign = (full_tzoffset < 0 ? "-" : "+");
+            if (tzoffset_hr == 0) {
+                jsonData.timezone = "UTC";
+            } else {
+                jsonData.timeZone = "Etc/GMT" + sign + tzoffset_hr;
+            }
+        }
+    }
+    return jsonData;
+}
+
+/**
+ * Convert a JSON date object as received by Google into a calIDateTime.
+ *
+ * @param aEntry                The JSON entry to convert.
+ * @param aDefaultTimezone      The timezone to use if not contained aEntry.
+ * @return                      The converted calIDateTime.
+ */
+function JSONToDate(aEntry, aDefaultTimezone) {
+    if (aEntry) {
+        let tzs = cal.getTimezoneService();
+        let timezone = ("timeZone" in aEntry && tzs.getTimezone(aEntry.timeZone)) || aDefaultTimezone;
+        return cal.fromRFC3339(aEntry.dateTime || aEntry.date, timezone);
+    } else {
+        return null;
+    }
+}
+
+/**
+ * Like cal.toRFC3339, but include milliseconds. Google timestamps require
+ * this.
+ *
+ * @param dt        The calIDateTime to convert.
+ * @return          The RFC3339 string stamp.
+ */
+function toRFC3339Fraction(dt) {
+    let str = cal.toRFC3339(dt);
+    return str ? str.replace(/(Z?)$/, ".000$1") : null;
+}
+
+/**
+ * Converts a calIEvent to a JS Object that can be serialized to JSON.
+ *
+ * @param aItem         The item to convert.
+ * @return              A JS Object representing the item.
+ */
+function EventToJSON(aItem, aOfflineStorage, aIsImport) {
+    function addExtendedProperty(aName, aValue, aPrivate) {
+        if (!aValue) {
+            // We unset an extended prop by not adding it
+            return;
+        }
+
+        if (!("extendedProperties" in itemData)) {
+            itemData.extendedProperties = {};
+        }
+        if (aPrivate) {
+            if (!("private" in itemData.extendedProperties)) {
+                itemData.extendedProperties.private = {};
+            }
+            itemData.extendedProperties.private[aName] = aValue;
+        } else {
+            if (!("shared" in itemData.extendedProperties)) {
+                itemData.extendedProperties.shared = {};
+            }
+            itemData.extendedProperties.shared[aName] = aValue;
+        }
+    }
+    function setIf(data, prop, value) {
+        if (value) data[prop] = value;
+    }
+
+    let itemData = {};
+
+    itemData.start = dateToJSON(aItem.startDate);
+    itemData.end = dateToJSON(aItem.endDate);
+
+    if (aIsImport && aItem.id) {
+        itemData.iCalUID = aItem.id;
+        setIf(itemData, "created", toRFC3339Fraction(aItem.creationDate));
+        setIf(itemData, "updated", toRFC3339Fraction(aItem.lastModifiedTime));
+    }
+
+    setIf(itemData, "summary", aItem.title);
+    setIf(itemData, "description", aItem.getProperty("DESCRIPTION"));
+    setIf(itemData, "location", aItem.getProperty("LOCATION"));
+    setIf(itemData, "transparency", aItem.getProperty("TRANSP") && aItem.getProperty("TRANSP").toLowerCase());
+    setIf(itemData, "visibility", aItem.privacy && aItem.privacy.toLowerCase());
+    setIf(itemData, "sequence", aItem.getProperty("SEQUENCE"));
+
+    // eventStatus
+    let status = aItem.status && aItem.status.toLowerCase();
+    if (status == "cancelled") {
+        // If the status is canceled, then the event will be deleted. Since the
+        // user didn't choose to delete the event, we will protect him and not
+        // allow this status to be set
+        throw new Components.Exception("The status CANCELLED is reserved, delete the event instead!",
+                                       Components.results.NS_ERROR_LOSS_OF_SIGNIFICANT_DATA);
+    } else if (status == "none") {
+        status = null;
+    }
+    setIf(itemData, "status", status);
+
+    // Google does not support categories natively, but allows us to store data
+    // as an "extendedProperty", so we do here
+    let categories = cal.categoriesArrayToString(aItem.getCategories({}));
+    addExtendedProperty("X-MOZ-CATEGORIES", categories);
+
+    // Only parse attendees if they are enabled, due to bug 407961
+    if (Preferences.get("calendar.google.enableAttendees", false)) {
+        const statusMap = {
+            "NEEDS-ACTION": "needsAction",
+            "DECLINED": "declined",
+            "TENTATIVE": "tentative",
+            "ACCEPTED": "accepted"
+        };
+        function createAttendee(attendee) {
+            let attendeeData = {};
+            if (aItem.organizer.id == attendee.id) {
+                needsOrganizer = false;
+            }
+            let lowerId = attendee.id.toLowerCase();
+            if (lowerId.startsWith("mailto:")) {
+                attendeeData.email = attendee.id.replace(/^mailto:/i, "");
+            } else if (lowerId.startsWith("urn:id:")) {
+                attendeeData.id = attendee.id.replace(/^urn:id:/i, "");
+            }
+
+            setIf(attendeeData, "displayName", attendee.commonName);
+            setIf(attendeeData, "optional", attendee.role && attendee.role != "REQ-PARTICIPANT");
+            setIf(attendeeData, "responseStatus", statusMap[attendee.participationStatus]);
+            setIf(attendeeData, "comment", attendee.getProperty("COMMENT"));
+            setIf(attendeeData, "resource", attendee.userType && attendee.userType != "INDIVIDUAL");
+            setIf(attendeeData, "additionalGuests", attendee.getProperty("X-NUM-GUESTS"));
+            return attendeeData;
+        }
+        let needsOrganizer = true;
+        let attendees = aItem.getAttendees({});
+        let attendeeData = [ createAttendee(a) for each (a in attendees) ];
+
+        if (aItem.organizer) {
+            itemData.organizer = createAttendee(aItem.organizer);
+            if (needsOrganizer) {
+                attendeeData.push(itemData.organizer);
+            }
+        }
+
+        if (attendeeData.length) itemData.attendees = attendeeData;
+    }
+
+    // reminder
+    let alarms = aItem.getAlarms({});
+    let actionMap = {
+        DISPLAY: "popup",
+        EMAIL: "email",
+        SMS: "sms"
+    };
+
+    itemData.reminders = { overrides: [], useDefault: false };
+    for (let i = 0; i < 5 && i < alarms.length; i++) {
+        let alarm = alarms[i];
+        let alarmOffset;
+        let alarmData = {};
+
+        if (alarm.getProperty("X-DEFAULT-ALARM")) {
+            // This is a default alarm, it shouldn't be set as an override
+            itemData.reminders.useDefault = true;
+            continue;
+        }
+
+        alarmData.method = actionMap[alarm.action] || "popup";
+
+        if (alarm.related == alarm.ALARM_RELATED_ABSOLUTE) {
+            alarmOffset = aItem.startDate.subtractDate(alarm.alarmDate);
+        } else {
+            if (alarm.related == alarm.ALARM_RELATED_END) {
+                // Google always uses an alarm offset related to the start time
+                // for relative alarms.
+                alarmOffset = alarm.alarmOffset.clone();
+                alarmOffset.addDuration(aItem.endDate.subtractDate(aItem.startDate));
+            } else {
+                alarmOffset = alarm.offset;
+            }
+        }
+        alarmData.minutes = -alarmOffset.inSeconds / 60;
+
+        // Google doesn't allow alarms after the event starts, or more than 4
+        // weeks before the event. Make sure the minutes are within range.
+        alarmData.minutes = Math.min(Math.max(0, alarmData.minutes), FOUR_WEEKS_IN_MINUTES);
+
+        itemData.reminders.overrides.push(alarmData);
+    }
+
+    // gd:extendedProperty (alarmLastAck)
+    addExtendedProperty("X-MOZ-LASTACK", cal.toRFC3339(aItem.alarmLastAck), true);
+
+    // XXX While Google now supports multiple alarms and alarm values, we still
+    // need to fix bug 353492 first so we can better take care of finding out
+    // what alarm is used for snoozing.
+
+    // gd:extendedProperty (snooze time)
+    let itemSnoozeTime = aItem.getProperty("X-MOZ-SNOOZE-TIME");
+    let icalSnoozeTime = null;
+    if (itemSnoozeTime) {
+        // The propery is saved as a string, translate back to calIDateTime.
+        icalSnoozeTime = cal.createDateTime();
+        icalSnoozeTime.icalString = itemSnoozeTime;
+    }
+    addExtendedProperty("X-MOZ-SNOOZE-TIME", cal.toRFC3339(icalSnoozeTime), true);
+
+    // gd:extendedProperty (snooze recurring alarms)
+    let snoozeValue = "";
+    if (aItem.recurrenceInfo) {
+        // This is an evil workaround since we don't have a really good system
+        // to save the snooze time for recurring alarms or even retrieve them
+        // from the event. This should change when we have multiple alarms
+        // support.
+        let snoozeObj = {};
+        let enumerator = aItem.propertyEnumerator;
+        while (enumerator.hasMoreElements()) {
+            let prop = enumerator.getNext().QueryInterface(Components.interfaces.nsIProperty);
+            if (prop.name.substr(0, 18) == "X-MOZ-SNOOZE-TIME-") {
+                // We have a snooze time for a recurring event, add it to our object
+                snoozeObj[prop.name.substr(18)] = prop.value;
+            }
+        }
+        if (Object.keys(snoozeObj).length > 0) {
+            snoozeValue = JSON.stringify(snoozeObj);
+        }
+    }
+    // Now save the snooze object in source format as an extended property. Do
+    // so always, since its currently impossible to unset extended properties.
+    addExtendedProperty("X-GOOGLE-SNOOZE-RECUR", snoozeValue, true);
+
+    // recurrence information
+    if (aItem.recurrenceInfo) {
+        itemData.recurrence = [];
+        let recurrenceItems = aItem.recurrenceInfo.getRecurrenceItems({});
+        for each (let ritem in recurrenceItems) {
+            let prop = ritem.icalProperty;
+            if (ritem instanceof Components.interfaces.calIRecurrenceDate) {
+                // EXDATES require special casing, since they might contain
+                // a TZID. To avoid the need for conversion of TZID strings,
+                // convert to UTC before serialization.
+                prop.valueAsDatetime = ritem.date.getInTimezone(cal.UTC());
+            }
+            itemData.recurrence.push(prop.icalString.trim());
+        }
+    } else if (aItem.recurrenceId) {
+        itemData.originalStartTime = dateToJSON(aItem.recurrenceId);
+        let parentMeta = getItemMetadata(aOfflineStorage, aItem.parentItem);
+        itemData.recurringEventId = parentMeta ? parentMeta.path : aItem.id.replace("@google.com", "");
+    }
+
+    return itemData;
+}
+
+/**
+ * Converts a calITodo to a JS Object that can be serialized to JSON.
+ *
+ * @param aItem         The item to convert.
+ * @return              A JS Object representing the item.
+ */
+function TaskToJSON(aItem, aOfflineStorage, aIsImport) {
+    function setIf(data, prop, value) {
+        if (value) data[prop] = value;
+    }
+
+    let itemData = {};
+
+    setIf(itemData, "id", aItem.id);
+    setIf(itemData, "title", aItem.title);
+    setIf(itemData, "notes", aItem.getProperty("DESCRIPTION"));
+    setIf(itemData, "position", aItem.getProperty("X-SORTKEY"));
+    itemData.status = (aItem.isCompleted ? "completed" : "needsAction");
+
+    if (aItem.dueDate) {
+        let dueDate = aItem.dueDate.getInTimezone(cal.UTC());
+        dueDate.isDate = false;
+        itemData.due = cal.toRFC3339(dueDate);
+    }
+    setIf(itemData, "completed", cal.toRFC3339(aItem.completedDate));
+
+    for each (let relation in aItem.getRelations({})) {
+        if (relation.relId &&
+            (!relation.relType || relation.relType == "PARENT")) {
+            itemData.parent = relation.relId;
+            break;
+        }
+    }
+
+    let attachments = aItem.getAttachments({});
+    if (attachments.length) itemData.links = [];
+    for each (let attach in aItem.getAttachments({})) {
+        let attachData = {};
+        attachData.link = attach.uri.spec;
+        attachData.description = attach.getParameter("FILENAME");
+        attachData.type = attach.getParameter("X-TYPE");
+        itemData.links.push(attachData);
+    }
+
+    return itemData;
+}
+
+/**
+ * Convenience function to convert any item type (task/event) to its JSON
+ * representation
+ *
+ * @param aItem         The item to convert
+ * @return              A JS Object representing the item.
+ */
+function ItemToJSON(aItem, aOfflineStorage, aIsImport) {
+    if (cal.isEvent(aItem)) {
+        return EventToJSON(aItem, aOfflineStorage, aIsImport);
+    } else if (cal.isToDo(aItem)) {
+        return TaskToJSON(aItem, aOfflineStorage, aIsImport);
+    } else {
+        cal.ERROR("[calGoogleCalendar] Invalid item type: " + aItem.icalString);
+        return null;
+    }
+}
+
+/**
+ * Sets up the recurrence info on the item
+ *
+ * @param aItem              The item to setup recurrence for.
+ * @param aRecurrence        The JSON entry describing recurrence.
+ */
+function setupRecurrence(aItem, aRecurrence, aTimezone) {
+    if (!aRecurrence) {
+        return;
+    }
+
+    if (!aItem.recurrenceInfo) {
+        aItem.recurrenceInfo = cal.createRecurrenceInfo(aItem);
+    } else {
+        aItem.recurrenceInfo.clearRecurrenceItems();
+    }
+
+    let rootComp;
+    try {
+        let vevent = "BEGIN:VEVENT\r\n" + aRecurrence.join("\r\n") + "\r\nEND:VEVENT";
+        rootComp = cal.getIcsService().parseICS(vevent, null);
+    } catch (e) {
+        cal.ERROR("[calGoogleCalendar] Unable to parse recurrence item: " + vevent);
+    }
+
+    let hasRecurringRules = false;
+    for (let prop in cal.ical.propertyIterator(rootComp)) {
+       switch (prop.propertyName) {
+            case "RDATE":
+            case "EXDATE":
+                let recItem = Components.classes["@mozilla.org/calendar/recurrence-date;1"]
+                              .createInstance(Components.interfaces.calIRecurrenceDate);
+                try {
+                    recItem.icalProperty = prop;
+                    aItem.recurrenceInfo.appendRecurrenceItem(recItem);
+                    hasRecurringRules = true;
+                } catch (e) {
+                    cal.ERROR("[calGoogleCalendar] Error parsing " +
+                              prop.propertyName + " (" +
+                              prop.icalString + "):" + e);
+                }
+                break;
+            case "RRULE":
+                let recRule = cal.createRecurrenceRule();
+                try {
+                    recRule.icalProperty = prop;
+                    aItem.recurrenceInfo.appendRecurrenceItem(recRule);
+                    hasRecurringRules = true;
+                } catch (e) {
+                    cal.ERROR("[calGoogleCalendar] Error parsing RRULE (" +
+                              prop.icalString + "):" + e);
+                }
+                break;
+        }
+    }
+
+    if (!hasRecurringRules) {
+        // If there were no parsable recurrence items, then clear the
+        // recurrence info.
+        aItem.recurrenceInfo = null;
+    }
+}
+
+/**
+ * Create an alarm from the JSON reminder entry
+ *
+ * @param aEntry            The JSON reminder entry.
+ * @param aDefault          (optional) If true, this is a default alarm.
+ * @return                  The translated calIAlarm.
+ */
+function JSONToAlarm(aEntry, aDefault) {
+    const alarmActionMap = {
+        email: "EMAIL",
+        popup: "DISPLAY",
+        sms: "SMS"
+    };
+    let alarm = cal.createAlarm();
+    let alarmOffset = cal.createDuration();
+    alarm.action = alarmActionMap[aEntry.method] || "DISPLAY";
+    alarm.related = Components.interfaces.calIAlarm.ALARM_RELATED_START;
+    alarmOffset.inSeconds = -aEntry.minutes * 60;
+    alarmOffset.normalize();
+    alarm.offset = alarmOffset;
+
+    if (aDefault) {
+        alarm.setProperty("X-DEFAULT-ALARM", "TRUE");
+    }
+    return alarm;
+}
+
+/**
+ * Converts a JS Object representing the event to a calIEvent.
+ *
+ * @param aEntry            The JS Object representation of the item.
+ * @param aCalendar         The calendar this item will belong to.
+ * @param aTimezone         The Timezone the event is most likely in.
+ * @param aDefaultReminders An array of default reminders, as a JS Object.
+ * @param aMetadata         (optional,out) Item metadata that should be set.
+ * @return                  The calIEvent with the item data.
+ */
+function JSONToEvent(aEntry, aCalendar, aTimezone, aDefaultReminders, aReferenceItem, aMetadata) {
+    aDefaultReminders = aDefaultReminders || [];
+    aMetadata = aMetadata || {};
+    let item = aReferenceItem || cal.createEvent();
+    item.calendar = aCalendar.superCalendar;
+    let privateProps = ("extendedProperties" in aEntry && aEntry.extendedProperties.private) || {};
+    let sharedProps = ("extendedProperties" in aEntry && aEntry.extendedProperties.shared) || {};
+    let accessRole = aCalendar.getProperty("settings.accessRole");
+
+    LOGverbose("[calGoogleCalendar] Parsing entry:\n" +
+               JSON.stringify(aEntry, null, " ") + "\n");
+
+    if (!aEntry || !("kind" in aEntry) || aEntry.kind != "calendar#event") {
+        cal.ERROR("[calGoogleCalendar] Attempt to decode invalid event: " +
+                  (aEntry && JSON.stringify(aEntry, null, " ")));
+        return null;
+    }
+
+    try {
+        item.id = aEntry.iCalUID || ((aEntry.recurringEventId || aEntry.id) + "@google.com");
+        item.recurrenceId = JSONToDate(aEntry.originalStartTime, aTimezone);
+        if (!item.recurrenceId) {
+            // Sometimes recurring event instances don't have recurringEventId
+            // set, but are still instances. work around by detecting the ID.
+            // http://code.google.com/a/google.com/p/apps-api-issues/issues/detail?id=3199
+            let hack = aEntry.id.match(/([^_]*)_(\d{8}(T\d{6}Z)?)/);
+            item.recurrenceId = hack ? cal.createDateTime(hack[2]) : null;
+        }
+        item.status = (aEntry.status ? aEntry.status.toUpperCase() : null);
+        item.title = aEntry.summary;
+        if (accessRole == "freeBusyReader") {
+            item.title = getProviderString("busyTitle", aCalendar.name);
+        }
+        item.privacy = (aEntry.visibility ? aEntry.visibility.toUpperCase() : null);
+
+        item.setProperty("URL", aEntry.htmlLink && aCalendar.uri.schemeIs("https") ? aEntry.htmlLink.replace(/^http:/, "https:") : aEntry.htmlLink);
+        item.setProperty("CREATED", (aEntry.created ? cal.fromRFC3339(aEntry.created, aTimezone).getInTimezone(cal.UTC()) : null));
+        item.setProperty("DESCRIPTION", aEntry.description);
+        item.setProperty("LOCATION", aEntry.location);
+        item.setProperty("TRANSP", (aEntry.transparency ? aEntry.transparency.toUpperCase() : null));
+        item.setProperty("SEQUENCE", aEntry.sequence);
+        aMetadata.etag = aEntry.etag;
+        aMetadata.path = aEntry.id;
+
+        // organizer
+        if (aEntry.organizer) {
+            let organizer = cal.createAttendee();
+            if (aEntry.organizer.email) {
+                organizer.id = "mailto:" + aEntry.organizer.email;
+            } else {
+                organizer.id = "urn:id:" + aEntry.organizer.id;
+            }
+            organizer.commonName = aEntry.organizer.displayName;
+            organizer.isOrganizer = true;
+            item.organizer = organizer;
+
+            if (aEntry.organizer.self && aCalendar.session) {
+                // Remember the display name, we found ourselves!
+                aCalendar.setProperty("organizerCN", aEntry.organizer.displayName);
+            }
+        } else {
+            item.organizer = null;
+        }
+
+        // start and end
+        item.startDate = JSONToDate(aEntry.start, aTimezone);
+        item.endDate = JSONToDate(aEntry.end, aTimezone);
+
+        // recurrence
+        setupRecurrence(item, aEntry.recurrence, aTimezone);
+
+        // attendees
+        item.removeAllAttendees();
+        if (aEntry.attendees) {
+            const statusMap = {
+                needsAction: "NEEDS-ACTION",
+                declined: "DECLINED",
+                tentative: "TENTATIVE",
+                accepted: "ACCEPTED"
+            };
+            for each (let attendeeEntry in aEntry.attendees) {
+                let attendee = cal.createAttendee();
+                if (attendeeEntry.email) {
+                    attendee.id = "mailto:" + attendeeEntry.email;
+                } else {
+                    attendee.id = "urn:id:" + attendeeEntry.id;
+                }
+                attendee.commonName = attendeeEntry.displayName;
+
+                if (attendeeEntry.optional) {
+                    attendee.role = "OPT-PARTICIPANT";
+                } else {
+                    attendee.role = "REQ-PARTICIPANT";
+                }
+
+                attendee.participationStatus = statusMap[attendeeEntry.responseStatus];
+
+                if (attendeeEntry.resource) {
+                    attendee.userType = "RESOURCE";
+                } else {
+                    attendee.userType = "INDIVIDUAL";
+                }
+
+                item.addAttendee(attendee);
+            }
+        }
+
+        // reminders
+        item.clearAlarms();
+
+        if (aEntry.reminders && aEntry.reminders.useDefault) {
+            aDefaultReminders.forEach(item.addAlarm, item);
+        }
+
+        if (aEntry.reminders && aEntry.reminders.overrides) {
+            for each (let reminderEntry in aEntry.reminders.overrides) {
+                item.addAlarm(JSONToAlarm(reminderEntry));
+            }
+        }
+
+        // extendedProperty (alarmLastAck)
+        item.alarmLastAck = cal.fromRFC3339(privateProps["X-MOZ-LASTACK"], aTimezone);
+
+        // extendedProperty (snooze time)
+        let dtSnoozeTime = cal.fromRFC3339(privateProps["X-MOZ-SNOOZE-TIME"], aTimezone);
+        let snoozeProperty = (dtSnoozeTime ? dtSnoozeTime.icalString : null);
+        item.setProperty("X-MOZ-SNOOZE-TIME", snoozeProperty);
+
+        // extendedProperty (snooze recurring alarms)
+        if (item.recurrenceInfo) {
+            // Transform back the string into our snooze properties
+            let snoozeObj;
+            try {
+                let snoozeString = privateProps["X-GOOGLE-SNOOZE-RECUR"];
+                snoozeObj = JSON.parse(snoozeString);
+            } catch (e) {
+                // Just swallow parsing errors, not so important.
+            }
+
+            if (snoozeObj) {
+                for (let rid in snoozeObj) {
+                    item.setProperty("X-MOZ-SNOOZE-TIME-" + rid, snoozeObj[rid]);
+                }
+            }
+        }
+
+        // Google does not support categories natively, but allows us to store
+        // data as an "extendedProperty", and here it's going to be retrieved
+        // again
+        let categories = cal.categoriesStringToArray(sharedProps["X-MOZ-CATEGORIES"]);
+        item.setCategories(categories.length, categories);
+
+        // updated (This must be set last!)
+        if (aEntry.updated) {
+            let updated = cal.fromRFC3339(aEntry.updated, aTimezone).getInTimezone(cal.UTC());
+            item.setProperty("DTSTAMP", updated);
+            item.setProperty("LAST-MODIFIED", updated);
+        }
+    } catch (e) {
+        cal.ERROR(stringException(e));
+        throw e;
+    }
+    return item;
+}
+
+/**
+ * Converts a JS Object representing the task to a calITodo.
+ *
+ * @param aEntry            The JS Object representation of the item.
+ * @param aCalendar         The calendar this item will belong to.
+ * @param aTimezone         The Timezone the task is most likely in.
+ * @param aMetadata         (optional,out) Item metadata that should be set.
+ * @return                  The calITodo with the item data.
+ */
+function JSONToTask(aEntry, aCalendar, aTimezone, aDefaultReminders, aReferenceItem, aMetadata) {
+    aDefaultReminders = aDefaultReminders || [];
+    aMetadata = aMetadata || {};
+    if (!aEntry || !("kind" in aEntry) || aEntry.kind != "tasks#task") {
+        cal.ERROR("[calGoogleCalendar] Attempt to decode invalid task: " +
+                  (aEntry && JSON.stringify(aEntry, null, " ")));
+        return null;
+    }
+    let item = cal.createTodo();
+    item.calendar = aCalendar.superCalendar;
+    try {
+        item.id = aEntry.id;
+        item.title = aEntry.title || "";
+        item.setProperty("DESCRIPTION", aEntry.notes);
+        item.setProperty("X-GOOGLE-SORTKEY", aEntry.position);
+        item.isCompleted = (aEntry.status == "completed");
+
+        aMetadata.etag = aEntry.etag;
+        aMetadata.path = aEntry.id;
+
+        // Google Tasks don't have a due time, but still use 0:00 UTC. They
+        // should really be using floating time.
+        item.dueDate = cal.fromRFC3339(aEntry.due, cal.floating())
+        if (item.dueDate) {
+            item.dueDate.timezone = cal.floating();
+            item.dueDate.isDate = true;
+        }
+        item.completedDate = cal.fromRFC3339(aEntry.completed, aTimezone);
+        if (aEntry.deleted) {
+            item.status = "CANCELLED";
+        } else if (aEntry.status == "needsAction") {
+            item.status = "NEEDS-ACTION";
+        } else {
+            item.status = "COMPLETED";
+        }
+
+        if (aEntry.parent) {
+            let relation = cal.createRelation();
+            relation.relType = "PARENT";
+            relation.relId = aEntry.parent;
+            item.addRelation(relation);
+        }
+
+        if (aEntry.links) {
+            for each (let link in aEntry.links) {
+                let attach = cal.createAttachment();
+                attach.uri = Services.io.newURI(link.link, null, null);
+                attach.setParameter("FILENAME", link.description);
+                attach.setParameter("X-GOOGLE-TYPE", link.type);
+                item.addAttachment(attach);
+            }
+        }
+
+        // updated (This must be set last!)
+        item.setProperty("DTSTAMP", cal.fromRFC3339(aEntry.updated, aTimezone).getInTimezone(cal.UTC()));
+        item.setProperty("LAST-MODIFIED", cal.fromRFC3339(aEntry.updated, aTimezone).getInTimezone(cal.UTC()));
+    } catch (e) {
+        cal.ERROR("[calGoogleCalendar] Error parsing JSON tasks stream: " + stringException(e));
+        throw e;
+    }
+
+    return item;
+}
+
+/**
+ * Convenience function to convert any JSON reply (task/event) to a calendar
+ * item.
+ *
+ * @param aEntry            The JS Object representation of the item.
+ * @param aCalendar         The calendar this item will belong to.
+ * @param aTimezone         The Timezone the task is most likely in.
+ * @param aMetadata         (optional,out) Item metadata that should be set.
+ * @return                  The specialized calIItemBase with the item data.
+ */
+function JSONToItem(aEntry, aCalendar, aTimezone, aDefaultReminders, aReferenceItem, aMetadata) {
+    aDefaultReminders = aDefaultReminders || [];
+    aMetadata = aMetadata || {};
+    if (aEntry.kind == "tasks#task") {
+        return JSONToTask.apply(null, arguments);
+    } else if (aEntry.kind = "calendar#event") {
+        return JSONToEvent.apply(null, arguments);
+    } else {
+        cal.ERROR("[calGoogleCalendar] Invalid item type: " + aData.kind);
+        return null;
+    }
+}
+
+/**
+ * Save items spread over multiple pages to the calendar's offline storage.
+ *
+ * @param aCalendar     The calendar the events belong to.
+ */
+function ItemSaver(aCalendar) {
+    this.calendar = aCalendar;
+    this.offlineStorage = this.calendar.offlineStorage;
+    this.promiseOfflineStorage = promisifyCalendar(this.calendar.offlineStorage);
+    this.missingParents = [];
+    this.masterItems = Object.create(null);
+    this.metaData = Object.create(null);
+}
+ItemSaver.prototype = {
+    masterItems: null,
+    missingParents: null,
+
+    /**
+     * Convenience function to apply a list of items (task/event) in JSON form to
+     * the given calendar.
+     *
+     * @param aData         The JS Object from the list response.
+     * @return              A promise resolved when completed.
+     */
+    parseItemStream: function(aData) {
+        if (aData.kind == "calendar#events") {
+            return this.parseEventStream(aData);
+        } else if (aData.kind == "tasks#tasks") {
+            return this.parseTaskStream(aData);
+        } else {
+            let message = "Invalid Stream type: " + (aData ? aData.kind || aData.toSource() : null);
+            throw new Components.Exception(message, Components.results.NS_ERROR_FAILURE);
+        }
+    },
+
+    /**
+     * Parse the response from Google's list command into tasks and modify the
+     * calendar's offline storage to reflect those changes.
+     *
+     * @param aData         The JS Object from the list response.
+     * @return              A promise resolved when completed.
+     */
+    parseTaskStream: function(aData) {
+        return Task.spawn(function() {
+            if (!aData.items || !aData.items.length) {
+                cal.LOG("[calGoogleCalendar] No tasks have been changed on " + this.calendar.name);
+            } else {
+                cal.LOG("[calGoogleCalendar] Parsing " + aData.items.length + " received tasks");
+                let defaultTimezone = cal.calendarDefaultTimezone();
+
+                let act = new ActivityShell(this.calendar, "Task");
+                let total = aData.items.length;
+                for (let cur = 0; cur < total; cur++) {
+                    let entry = aData.items[cur];
+                    //let metaData = Object.create(null);
+                    let metaData = {};
+                    let item = JSONToTask(entry, this.calendar, defaultTimezone, null, null, metaData);
+                    this.metaData[item.hashId] = metaData;
+
+                    yield this.commitItem(item);
+
+                    if (yield spinEventLoop()) {
+                        act.setProgress(cur, total);
+                    }
+                }
+                act.complete();
+            }
+        }.bind(this));
+    },
+
+    /**
+     * Parse the response from Google's list command into events.
+     *
+     * @param aData         The JS Object from the list response.
+     * @return              A promise resolved when completed.
+     */
+    parseEventStream: function(aData) {
+        return Task.spawn(function() {
+            if (!aData.items || !aData.items.length) {
+                cal.LOG("[calGoogleCalendar] No events have been changed on " + this.calendar.name);
+                return;
+            } else {
+                cal.LOG("[calGoogleCalendar] Parsing " + aData.items.length + " received events");
+            }
+
+            let exceptionItems = [];
+            let defaultReminders = (aData.defaultReminders || []).map(function(x) JSONToAlarm(x, true));
+
+            let tzs = cal.getTimezoneService();
+            let defaultTimezone = (aData.timeZone ? tzs.getTimezone(aData.timeZone) :
+                                    cal.calendarDefaultTimezone());
+
+            // In the first pass, we go through the data and sort into master items and
+            // exception items, as the master item might be after the exception in the
+            // stream.
+
+            let act = new ActivityShell(this.calendar, "Event");
+            let total = aData.items.length;
+            for (let cur = 0; cur < total; cur++) {
+                let entry = aData.items[cur];
+                let metaData = Object.create(null);
+                let item = JSONToEvent(entry, this.calendar, defaultTimezone, defaultReminders, null, metaData);
+                LOGitem(item);
+
+                this.metaData[item.hashId] = metaData;
+
+                if (item.recurrenceId) {
+                    exceptionItems.push(item);
+                } else {
+                    this.masterItems[item.id] = item;
+                    yield this.commitItem(item);
+                }
+
+                if (yield spinEventLoop()) {
+                    act.setProgress(cur, total);
+                }
+            }
+            act.complete();
+
+            // Go through all exceptions and attempt to find the master item in the
+            // item stream. If it can't be found there, the offline storage is asked
+            // for the parent item. If it still can't be found, then we have to do
+            // this at the end.
+            for each (let exc in exceptionItems) {
+                // If we have the master item in our cache then use it. Otherwise
+                // attempt to get it from the offline storage.
+                let item;
+                if (exc.id in this.masterItems) {
+                    item = this.masterItems[exc.id];
+                } else {
+                    item = (yield this.promiseOfflineStorage.getItem(exc.id))[0];
+                }
+
+                // If an item was found, we can process this exception. Otherwise
+                // save it for later, maybe its on the next page of the request.
+                if (item) {
+                    yield this.processException(exc, item);
+                } else {
+                    this.missingParents.push(exc);
+                }
+
+                yield this.commitException(exc);
+            }
+        }.bind(this));
+    },
+
+    /**
+     * Handle the exception for the given item by committing it to the
+     * calendar.
+     *
+     * @param exc       The exception to process.
+     * @param item      The item the exception belongs to.
+     * @return          A promise resolved when the item is added to the
+     *                    calendar.
+     */
+    processException: function(exc, item) {
+        exc.parentItem = item;
+        if (exc.status == "CANCELLED") {
+            // Canceled means the occurrence is an EXDATE.
+            item.recurrenceInfo.removeOccurrenceAt(exc.recurrenceId);
+        } else {
+            // Not canceled means the occurrence was modified.
+            item.recurrenceInfo.modifyException(exc, true);
+        }
+        this.masterItems[item.id] = item;
+        return this.commitItem(item);
+    },
+
+    /**
+     * Handle final tasks for the exception. This means saving the metadat for the exception.
+     *
+     * @param exc       The exception to process.
+     */
+    commitException: function(exc) {
+        // Make sure we also save the etag of the exception for a future request.
+        if (exc.hashId in this.metaData) {
+            saveItemMetadata(this.offlineStorage, exc.hashId, this.metaData[exc.hashId]);
+        }
+    },
+
+    /**
+     * Handle adding the item to the calendar, or removing it if its a cancelled item.
+     *
+     * @param item      The item to process.
+     * @return          A promise resolved when the process is completed.
+     */
+    commitItem: function(item) {
+        return Task.spawn(function() {
+            // This is a normal item. If it was canceled, then it should be
+            // deleted, otherwise it should be either added or modified. The
+            // relaxed mode of the destination calendar takes care of the latter
+            // two cases.
+            if (item.status == "CANCELLED") {
+                yield this.promiseOfflineStorage.deleteItem(item);
+            } else {
+                yield this.promiseOfflineStorage.modifyItem(item, null);
+            }
+
+            if (item.hashId in this.metaData) {
+                // Make sure the metadata is up to date for the next request
+                saveItemMetadata(this.offlineStorage, item.hashId, this.metaData[item.hashId]);
+            }
+        }.bind(this));
+    },
+
+    /**
+     * Handle all remaining exceptions in the item saver. Call this at the end
+     * when all items and exceptions have been loaded to ensure that any
+     * missing master items are searched for or created.
+     *
+     * @return          A promise resolved on completion
+     */
+    processRemainingExceptions: function() {
+        return Task.spawn(function() {
+            for each (let exc in this.missingParents) {
+                let item = (yield this.promiseOfflineStorage.getItem(exc.id))[0];
+                if (item) {
+                    yield this.processException(exc, item);
+                } else if (exc.status != "CANCELLED") {
+                    // If the item could not be found, it could be that the
+                    // user is invited to an instance of a recurring event.
+                    // Unless this is a cancelled exception, create a mock
+                    // parent item with one positive RDATE.
+                    let item = exc.clone();
+                    item.recurrenceId = null;
+                    item.calendar = this.calendar.superCalendar;
+                    item.startDate = exc.recurrenceId.clone();
+                    item.setProperty("X-MOZ-FAKED-MASTER", "1");
+                    if (!item.id) {
+                        // Exceptions often don't have the iCalUID field set,
+                        // we need to fake it from the google id.
+                        let meta = this.metaData[exc.hashId];
+                        item.id = meta.path + "@google.com";
+                    }
+                    item.recurrenceInfo = cal.createRecurrenceInfo(item);
+                    let rdate = Components.classes["@mozilla.org/calendar/recurrence-date;1"]
+                                          .createInstance(Components.interfaces.calIRecurrenceDate);
+                    rdate.date = exc.recurrenceId;
+                    item.recurrenceInfo.appendRecurrenceItem(rdate);
+                    yield this.commitItem(item);
+                }
+            }
+        }.bind(this));
+    }
+};
+
+/**
+ * A wrapper for nsIActivity to handle the synchronization process.
+ *
+ * @param aCalendar     The calendar for this activity.
+ */
+function ActivityShell(aCalendar, aType) {
+    this.calendar = aCalendar;
+    this.type = aType;
+
+    if ('@mozilla.org/activity-process;1' in Components.classes) {
+        this.init();
+    }
+}
+
+ActivityShell.prototype = {
+    act: null,
+    actMgr: null,
+    calendar: null,
+    type: null,
+
+    init: function() {
+        this.actMgr = Components.classes['@mozilla.org/activity-manager;1']
+                                .getService(Components.interfaces.nsIActivityManager);
+        this.act =  Components.classes['@mozilla.org/activity-process;1']
+                              .createInstance(Components.interfaces.nsIActivityProcess);
+        this.act.init(getProviderString("syncStatus", this.calendar.name), this);
+        this.act.iconClass = "syncMail";
+        this.act.contextType = "gdata-calendar";
+        this.act.contextObj = this.calendar;
+        this.act.contextDisplayText = this.calendar.name;
+
+        this.actMgr.addActivity(this.act);
+    },
+
+    setProgress: function(cur, total) {
+        if (!this.act) {
+            return;
+        }
+        if (cur == total) {
+            this.complete();
+        } else {
+            let str = getProviderString("syncProgress" + this.type, this.calendar.name, cur, total);
+            this.act.setProgress(str, cur, total);
+        }
+    },
+
+    complete: function() {
+        if (!this.act) {
+            return;
+        }
+        let total = this.act.totalWorkUnits;
+        this.act.setProgress("", total, total);
+        this.act.state = Components.interfaces.nsIActivityProcess.STATE_COMPLETED;
+        this.actMgr.removeActivity(this.act.id);
+    }
+};
+
+/**
+ * Check if the response is a conflict and handle asking the user what to do
+ * about it. Will resolve if there is no conflict or with new item data.
+ * where status is a conflict status, see the end of this function.
+ *
+ * @param aOperation        The operation to check.
+ * @param aCalendar         The calendar this operation happens in
+ * @param aItem             The item that was passed to the server
+ * @return                  A promise resolved when the conflict has been resolved
+ */
+function checkResolveConflict(aOperation, aCalendar, aItem) {
+    return Task.spawn(function() {
+        cal.LOG("[calGoogleCalendar] A conflict occurred for " + aItem.title);
+
+        let method = (aOperation.type == aOperation.DELETE ? "delete" : "modify")
+        let overwrite = cal.promptOverwrite(method, aItem);
+        if (overwrite) {
+            // The user has decided to overwrite the server version. Send again
+            // overwriting the server version with If-Match: *
+            cal.LOG("[calGoogleCalendar] Resending " + method + " and ignoring ETag");
+            aOperation.addRequestHeader("If-Match", "*");
+            try {
+                throw new Task.Result(yield aCalendar.session.asyncItemRequest(aOperation));
+            } catch (e if e.result == calGoogleRequest.RESOURCE_GONE &&
+                          aOperation.type == aOperation.DELETE) {
+                // The item was deleted on the server and locally, we don't need to
+                // notify the user about this.
+                throw new Task.Result(null);
+            }
+        } else {
+            // The user has decided to throw away changes, use our existing
+            // means to update the item locally.
+            cal.LOG("[calGoogleCalendar] Reload requested, cancelling change of " + aItem.title);
+            aCalendar.superCalendar.refresh();
+            throw Components.Exception(null, cIE.OPERATION_CANCELLED);
+        }
+    });
+}
+
+/**
+ * Get a string from the gdata properties file
+ *
+ * @param aStringName  The name of the string within the properties file
+ * @param ...aParams   Optional parameters to format the string
+ * @return             The localized string value.
+ */
+function getProviderString(aStringName /*...aParams */) {
+    let aParams = Array.slice(arguments, 1);
+    return cal.calGetString("gdata", aStringName, aParams, "gdata-provider");
+}
+
+/**
+ * Monkey patch the function with the name x on obj and overwrite it with func.
+ * The first parameter of this function is the original function that can be
+ * called at any time.
+ *
+ * @param obj           The object the function is on.
+ * @param name          The string name of the function.
+ * @param func          The function to monkey patch with.
+ */
+function monkeyPatch(obj, x, func) {
+    let old = obj[x];
+    obj[x] = function() {
+        let parent = old.bind(obj);
+        let args = Array.slice(arguments);
+        args.unshift(parent);
+        try {
+            return func.apply(obj, args);
+        } catch (e) {
+            Components.utils.reportError(e);
+            throw e;
+        }
+    }
+}
+
+/**
+ * Returns a promise that resolves after pending events have been processed.
+ */
+
+function spinEventLoop() {
+    let diff = (new Date()).getTime() - spinEventLoop.lastSpin;
+    if (diff < Preferences.get("calendar.threading.latency", 250)) {
+        return Promise.resolve(false);
+    }
+    spinEventLoop.lastSpin = new Date();
+
+    return new Promise(function(resolve) {
+      Services.tm.currentThread.dispatch({ run: function() resolve(true) }, 0);
+    });
+}
+spinEventLoop.lastSpin = new Date().getTime();
+
+/**
+ * Shim for Promise.all needed for Gecko 24
+ */
+PromiseAll = function (aValues) {
+  function checkForCompletion(aValue, aIndex) {
+    resolutionValues[aIndex] = aValue;
+    if (--countdown === 0) {
+      deferred.resolve(resolutionValues);
+    }
+  }
+
+  if (aValues == null || !Array.isArray(aValues)) {
+    throw new Error("Promise.all() expects an array.");
+  }
+
+  let values = aValues;
+  let countdown = values.length;
+  let resolutionValues = new Array(countdown);
+
+  if (!countdown) {
+    return Promise.resolve(resolutionValues);
+  }
+
+  let deferred = Promise.defer();
+  for (let i = 0; i < values.length; i++) {
+    let index = i;
+    let value = values[i];
+    let resolver = function(val) checkForCompletion(val, index);
+
+    if (value && typeof(value.then) == "function") {
+      value.then(resolver, deferred.reject);
+    } else {
+      // Given value is not a promise, forward it as a resolution value.
+      resolver(value);
+    }
+  }
+
+  return deferred.promise;
+};
+
+/**
+ * Shim for calAsyncUtils' promsifyCalendar for Lightning 2.6 - 3.5
+ */
+function promisifyCalendar(aCalendar) {
+    function promiseOperationListener(deferred) {
+        return {
+            items: [],
+            itemStatus: Components.results.NS_OK,
+            onGetResult: function(aCalendar, aStatus, aItemType, aDetail,
+                                  aCount, aItems) {
+                this.itemStatus = aStatus;
+                if (Components.isSuccessCode(aStatus)) {
+                    this.items = this.items.concat(aItems);
+                } else {
+                    this.itemSuccess = aStatus;
+                }
+            },
+
+            onOperationComplete: function(aCalendar, aStatus, aOpType, aId, aDetail) {
+                if (!Components.isSuccessCode(aStatus)) {
+                    // This function has failed, reject with the status
+                    deferred.reject(aStatus)
+                } else if (!Components.isSuccessCode(this.itemStatus)) {
+                    // onGetResult has failed, reject with its status
+                    deferred.reject(this.itemStatus);
+                } else if (aOpType == cIOL.GET) {
+                     // Success of a GET operation: resolve with array of
+                     // resulting items.
+                    deferred.resolve(this.items);
+                } else { /* ADD,MODIFY,DELETE: resolve with 1 item */
+                    // Success of an ADD MODIFY or DELETE operation, resolve
+                    // with the one item that was processed.
+                    deferred.resolve(aDetail)
+                }
+            }
+        }
+    }
+
+    const promisifyProxyHandler = {
+        promiseOperation: function(target, name, args) {
+            let deferred = Promise.defer();
+            let listener = promiseOperationListener(deferred);
+            args.push(listener);
+            target[name].apply(target, args);
+            return deferred.promise;
+        },
+        get: function(target, name) {
+            switch (name) {
+                case "adoptItem":
+                case "addItem":
+                case "modifyItem":
+                case "deleteItem":
+                case "getItem":
+                case "getItems":
+                    return function() {
+                        return this.promiseOperation(target, name, Array.slice(arguments));
+                    }.bind(this);
+                case "getAllItems":
+                    return function() {
+                        return this.promiseOperation(target, "getItems", [cIC.ITEM_FILTER_ALL_ITEMS, 0, null, null]);
+                    }.bind(this);
+                default:
+                    return target[name];
+            }
+        }
+    };
+    return {
+        // Backwards compat, we can use |new Proxy(aCalendar, promisifyProxyHandler);| in the future.
+        adoptItem: function(aItem) promisifyProxyHandler.get(aCalendar, "adoptItem").apply(this, arguments),
+        addItem: function(aItem) promisifyProxyHandler.get(aCalendar, "addItem").apply(this, arguments),
+        modifyItem: function(aItem) promisifyProxyHandler.get(aCalendar, "modifyItem").apply(this, arguments),
+        deleteItem: function(aItem) promisifyProxyHandler.get(aCalendar, "deleteItem").apply(this, arguments),
+        getItem: function(aItem) promisifyProxyHandler.get(aCalendar, "getItem").apply(this, arguments),
+        getItems: function(aItems) promisifyProxyHandler.get(aCalendar, "getItems").apply(this, arguments),
+    };
+}
diff --git a/calendar/providers/gdata/modules/shim/Calendar.jsm b/calendar/providers/gdata/modules/shim/Calendar.jsm
new file mode 100644
index 0000000..4a052a9
--- /dev/null
+++ b/calendar/providers/gdata/modules/shim/Calendar.jsm
@@ -0,0 +1,188 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+var EXPORTED_SYMBOLS = ["calendarShim", "gdataRegisterCalendar"];
+
+Components.utils.import("resource://calendar/modules/calUtils.jsm");
+
+const cICL = Components.interfaces.calIChangeLog;
+
+/**
+ * Shim functions that can be injected into an object implementing calICalendar
+ * to make it compatible with older versions of Lightning
+ */
+var calendarShim = {
+    addItemOrUseCache: function(aItem, useCache, aListener) {
+        let newItem = aItem.clone();
+        return this.adoptItemOrUseCache(newItem, useCache, aListener);
+    },
+
+    adoptItemOrUseCache: function(aItem, useCache, aListener) {
+        let self = this;
+        let addOfflineListener = {
+            onGetResult: function() {},
+            onOperationComplete: function(calendar, status, opType, id, detail) {
+                if (Components.isSuccessCode(status)) {
+                    let storage = self.mOfflineStorage.QueryInterface(Components.interfaces.calIOfflineStorage);
+                    storage.addOfflineItem(detail, aListener);
+                } else if (aListener) {
+                    aListener.onOperationComplete(self, status, opType, id, detail);
+                }
+            }
+        };
+
+        let intermediateListener = {
+            onGetResult: function() {},
+            onOperationComplete: function(aCalendar, aStatus, aOp, aId, aInnerItem) {
+                if (useCache) {
+                    if (isUnavailableCode(aStatus)) {
+                        self.mOfflineStorage.adoptItem(aInnerItem, addOfflineListener);
+                    } else {
+                        self.mOfflineStorage.addItem(aInnerItem, aListener);
+                    }
+                } else {
+                    aListener.onOperationComplete.apply(aListener, arguments);
+                }
+            }
+        };
+
+        return this.adoptItem(aItem, intermediateListener);
+    },
+
+    modifyItemOrUseCache: function modifyItemOrUseCache(aNewItem, aOldItem, useCache, aListener) {
+        let self = this;
+        let storage = this.mOfflineStorage.QueryInterface(Components.interfaces.calIOfflineStorage);
+        let modifyOfflineListener = {
+            onGetResult: function(calendar, status, itemType, detail, count, items) {},
+            onOperationComplete: function(calendar, status, opType, id, detail) {
+                storage.modifyOfflineItem(detail, aListener);
+            }
+        };
+
+        let offlineFlagListener = {
+            onGetResult: function(calendar, status, itemType, detail, count, items) {},
+            onOperationComplete: function(calendar, status, opType, id, detail) {
+                let offline_flag = detail;
+                if ((offline_flag == cICL.OFFLINE_FLAG_CREATED_RECORD ||
+                     offline_flag == cICL.OFFLINE_FLAG_MODIFIED_RECORD) && useCache) {
+                    storage.modifyItem(aNewItem, aOldItem, modifyOfflineListener);
+                } else {
+                    self.modifyItem(aNewItem, aOldItem, aListener);
+                }
+            }
+        };
+        storage.getItemOfflineFlag(aOldItem, offlineFlagListener);
+    },
+
+    deleteItemOrUseCache: function deleteItemOrUseCache(aItem, useCache, aListener) {
+        let self = this;
+        let storage = this.mOfflineStorage.QueryInterface(Components.interfaces.calIOfflineStorage);
+        let deleteOfflineListener = {
+            onGetResult: function(calendar, status, itemType, detail, count, items) {},
+            onOperationComplete: function(calendar, status, opType, id, detail) {
+                if (aListener) {
+                    aListener.onOperationComplete(calendar, status, opType, aItem.id, aItem);
+                }
+            }
+        };
+
+        let offlineFlagListener = {
+            onGetResult: function(calendar, status, itemType, detail, count, items) {},
+            onOperationComplete: function(calendar, status, opType, id, detail) {
+                let offline_flag = detail;
+                if ((offline_flag == cICL.OFFLINE_FLAG_CREATED_RECORD ||
+                     offline_flag == cICL.OFFLINE_FLAG_MODIFIED_RECORD) && useCache) {
+                    /* We do not delete the item from the cache, but mark it deleted */
+                    storage.deleteOfflineItem(aItem, aListener);
+                } else {
+                    self.deleteItem(aItem, aListener);
+                }
+            }
+        };
+        storage.getItemOfflineFlag(aItem, offlineFlagListener);
+    },
+
+    notifyPureOperationComplete: function(aListener, aStatus, aOpType, aId, aDetail) {
+        let protoComplete = this.__proto__.__proto__.notifyPureOperationComplete;
+
+        if (protoComplete) {
+            protoComplete.apply(this, arguments);
+        } else {
+            // Shim for older versions of Lightning
+            if (aListener) {
+                try {
+                    aListener.onOperationComplete(this.superCalendar, aStatus, aOpType, aId, aDetail);
+                } catch (exc) {
+                    cal.ERROR(exc);
+                }
+            }
+        }
+    }
+};
+
+/**
+ * Checks if the error code is a code that happens when there is a network
+ * error or similar, that would make the calendar temporarily unavailable.
+ *
+ * @param result        The result code to check.
+ * @return              True, if the code is an unavailable code.
+ */
+function isUnavailableCode(result) {
+    // Stolen from nserror.h
+    const NS_ERROR_MODULE_NETWORK = 6;
+    function NS_ERROR_GET_MODULE(code) {
+        return (((code >> 16) - 0x45) & 0x1fff);
+    }
+
+    if (NS_ERROR_GET_MODULE(result) == NS_ERROR_MODULE_NETWORK &&
+        !Components.isSuccessCode(result)) {
+        // This is a network error, which most likely means we should
+        // retry it some time.
+        return true;
+    }
+
+    // Other potential errors we want to retry with
+    switch (result) {
+        case Components.results.NS_ERROR_NOT_AVAILABLE:
+            return true;
+        default:
+            return false;
+    }
+}
+
+/**
+ * A replacement for calICalendarManager::registerCalendar, that allows
+ * registering calendars with an existing id. This is needed for backwards
+ * compatibility before Gecko 9.
+ *
+ * @param calendar      The calendar to register
+ */
+function gdataRegisterCalendar(calendar) {
+    if (!calendar.id) {
+        calendar.id = cal.getUUID();
+    }
+    let branch = "calendar.registry." + calendar.id + ".";
+
+    cal.setPref(branch + "type", calendar.type);
+    cal.setPref(branch + "uri", calendar.uri.spec);
+
+    let calmgr = cal.getCalendarManager().wrappedJSObject;
+    let calCachedCalendar = Components.utils.getGlobalForObject(calmgr).calCachedCalendar;
+
+    if ((calendar.getProperty("cache.supported") !== false) &&
+        calendar.getProperty("cache.enabled")) {
+        calendar = new calCachedCalendar(calendar);
+    }
+
+    calmgr.setupCalendar(calendar);
+    Components.classes["@mozilla.org/preferences-service;1"]
+              .getService(Components.interfaces.nsIPrefService)
+              .savePrefFile(null);
+
+    if (!calendar.getProperty("disabled") && calendar.canRefresh) {
+        calendar.refresh();
+    }
+
+    calmgr.notifyObservers("onCalendarRegistered", [calendar]);
+}
diff --git a/calendar/providers/gdata/modules/shim/Http.jsm b/calendar/providers/gdata/modules/shim/Http.jsm
new file mode 100644
index 0000000..2280d5c
--- /dev/null
+++ b/calendar/providers/gdata/modules/shim/Http.jsm
@@ -0,0 +1,79 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+var EXPORTED_SYMBOLS = ["percentEncode", "httpRequest"];
+
+const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
+
+function percentEncode(aString)
+  encodeURIComponent(aString).replace(/[!'()]/g, escape).replace(/\*/g, "%2A");
+
+function httpRequest(aUrl, aOptions) {
+  let xhr = Cc["@mozilla.org/xmlextras/xmlhttprequest;1"]
+              .createInstance(Ci.nsIXMLHttpRequest);
+  xhr.mozBackgroundRequest = true; // no error dialogs
+  xhr.open(aOptions.method || (aOptions.postData ? "POST" : "GET"), aUrl);
+  xhr.channel.loadFlags = Ci.nsIChannel.LOAD_ANONYMOUS | // don't send cookies
+                          Ci.nsIChannel.LOAD_BYPASS_CACHE |
+                          Ci.nsIChannel.INHIBIT_CACHING;
+  xhr.onerror = function(aProgressEvent) {
+    if (aOptions.onError) {
+      // adapted from toolkit/mozapps/extensions/nsBlocklistService.js
+      let request = aProgressEvent.target;
+      let status;
+      try {
+        // may throw (local file or timeout)
+        status = request.status;
+      }
+      catch (e) {
+        request = request.channel.QueryInterface(Ci.nsIRequest);
+        status = request.status;
+      }
+      // When status is 0 we don't have a valid channel.
+      let statusText = status ? request.statusText : "offline";
+      aOptions.onError(statusText, null, this);
+    }
+  };
+  xhr.onload = function(aRequest) {
+    try {
+      let target = aRequest.target;
+      if (aOptions.logger)
+        aOptions.logger.debug("Received response: " + target.responseText);
+      if (target.status < 200 || target.status >= 300) {
+        let errorText = target.responseText;
+        if (!errorText || /<(ht|\?x)ml\b/i.test(errorText))
+          errorText = target.statusText;
+        throw target.status + " - " + errorText;
+      }
+      if (aOptions.onLoad)
+        aOptions.onLoad(target.responseText, this);
+    } catch (e) {
+      Cu.reportError(e);
+      if (aOptions.onError)
+        aOptions.onError(e, aRequest.target.responseText, this);
+    }
+  };
+
+  if (aOptions.headers) {
+    aOptions.headers.forEach(function(header) {
+      xhr.setRequestHeader(header[0], header[1]);
+    });
+  }
+
+  // Handle adding postData as defined above.
+  let POSTData = aOptions.postData || "";
+  if (Array.isArray(POSTData)) {
+    xhr.setRequestHeader("Content-Type",
+                         "application/x-www-form-urlencoded; charset=utf-8");
+    POSTData = POSTData.map(function(p) p[0] + "=" + percentEncode(p[1]))
+                       .join("&");
+  }
+
+  if (aOptions.logger) {
+    aOptions.logger.log("sending request to " + aUrl + " (POSTData = " +
+                        POSTData + ")");
+  }
+  xhr.send(POSTData);
+  return xhr;
+}
diff --git a/calendar/providers/gdata/modules/shim/Loader.jsm b/calendar/providers/gdata/modules/shim/Loader.jsm
new file mode 100644
index 0000000..1a17ba9
--- /dev/null
+++ b/calendar/providers/gdata/modules/shim/Loader.jsm
@@ -0,0 +1,206 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+Components.utils.import("resource://calendar/modules/calUtils.jsm");
+
+var EXPORTED_SYMBOLS = ["CuImport", "shimIt"];
+
+var CuImportSubstitutions = {
+    "resource://gre/modules/Promise.jsm": "resource://gdata-provider/modules/shim/Promise.jsm",
+    "resource://gre/modules/Task.jsm": "resource://gdata-provider/modules/shim/Task.jsm",
+    "resource://gre/modules/Timer.jsm": "resource://gdata-provider/modules/shim/Timer.jsm",
+    "resource://gre/modules/Preferences.jsm": "resource://gdata-provider/modules/shim/Preferences.jsm",
+};
+
+/**
+ * Attempt to import a module, falling back to the shim if it does not exist.
+ */
+function CuImport(uriSpec, globalObj) {
+    try {
+        Components.utils.import(uriSpec, globalObj)
+    } catch (e if e.result == Components.results.NS_ERROR_FILE_NOT_FOUND) {
+        if (uriSpec in CuImportSubstitutions) {
+            // If we have a substitution, then load it now.
+            Components.utils.import(CuImportSubstitutions[uriSpec], globalObj);
+        } else {
+            let fn = Components.stack.caller.filename;
+            Components.utils.reportError("[calGoogleCalendar] Missing: " + fn + " -> " + uriSpec);
+        }
+    }
+}
+
+/**
+ * Inject any missing functions and objects into the given global
+ */
+function shimIt(global) {
+    if (!global.String.prototype.startsWith) {
+        Object.defineProperty(global.String.prototype, 'startsWith', {
+            enumerable: false,
+            configurable: false,
+            writable: false,
+            value: function(searchString, position) {
+                position = position || 0;
+                return this.lastIndexOf(searchString, position) === position;
+            }
+        });
+    }
+
+    if (!global.String.prototype.endsWith) {
+        Object.defineProperty(global.String.prototype, 'endsWith', {
+            value: function(searchString, position) {
+                var subjectString = this.toString();
+                if (position === undefined || position > subjectString.length) {
+                    position = subjectString.length;
+                }
+                position -= searchString.length;
+                var lastIndex = subjectString.indexOf(searchString, position);
+                return lastIndex !== -1 && lastIndex === position;
+            }
+        });
+    }
+
+    // See note at the bottom of https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
+    // for why the same method is used for contains/includes.
+    if (!global.String.prototype.contains) {
+        global.String.prototype.contains = StringContains;
+    }
+
+    if (!global.String.prototype.includes) {
+        global.String.prototype.includes = StringContains;
+    }
+
+    if (!global.Map) {
+        global.Map = Map;
+    }
+    if (!global.Set) {
+        global.Set = Set;
+    }
+
+    if (typeof global.Map.prototype.forEach !== "function") {
+        global.Map.prototype.forEach = MapSetForEach;
+    }
+    if (typeof global.Set.prototype.forEach !== "function") {
+        global.Set.prototype.forEach = MapSetForEach;
+    }
+}
+
+/**
+ * Implementation for String.prototype.includes/contains.
+ */
+function StringContains() {
+    return String.prototype.indexOf.apply(this, arguments) !== -1;
+}
+
+/**
+ * forEach implementation for Map and Set, for Thunderbird 24
+ */
+function MapSetForEach(cb) {
+    let iter = this.entries();
+    while (1) {
+        let k, v;
+        try {
+            [k,v] = iter.next();
+        } catch (e if e instanceof StopIteration) {
+              break;
+        }
+        cb(v, k, this);
+    }
+}
+
+/**
+ * This implementation of Map doesn't work quite like the ES6 Map, but it works
+ * well enough for our purposes.
+ */
+function Map(values) {
+    this.data = Object.create(null);
+    if (values) {
+        for each (let [k,v] in values) {
+            this.data[k] = v;
+        }
+    }
+}
+Map.prototype = {
+    has: function(k) k in this.data,
+    set: function(k, v) this.data[k] = v,
+    get: function(k) this.data[k],
+    delete: function(k) delete this.data[k],
+    get size() Object.keys(this.data).length,
+    forEach: function(cb) {
+        for (let k in this.data) {
+            cb(this.data[k], k, this);
+        }
+    },
+
+    toSource: function() Object.prototype.toSource.call(this.data),
+    __iterator__: function() new Iterator(this.data)
+};
+
+/**
+ * Not a particularly fast implementation of Set, but since our keys can be
+ * objects we can't just use normal js objects.
+ */
+function Set(values) {
+    this.data = [];
+    if (values) {
+        values.forEach(this.add, this);
+    }
+}
+Set.prototype = {
+    has: function(v) {
+        for each (let dv in this.data) {
+            if (v == dv) return true;
+        }
+        return false;
+    },
+
+    get size() this.data.length,
+    add: function(v) this.has(v) ? null : this.data.push(v),
+    clear: function() this.data = [],
+    delete: function(v) {
+        for (let i = 0; i < this.data.length; i++) {
+            if (this.data[i] == v) {
+                this.data.splice(i, 1);
+                return;
+            }
+        }
+    },
+
+    forEach: function(cb) {
+        for each (let v in this.data) {
+            cb(v, v, this);
+        }
+    },
+
+    toSource: function() this.data.toSource(),
+    __iterator__: function() {
+        for each (let v in this.data) {
+            yield v;
+        }
+    }
+};
+
+if (!cal.hashColor) {
+    cal.hashColor = function hashColor(str) {
+        // This is the palette of colors in the current colorpicker implementation.
+        // Unfortunately, there is no easy way to extract these colors from the
+        // binding directly.
+        const colorPalette = ["#FFFFFF", "#FFCCCC", "#FFCC99", "#FFFF99", "#FFFFCC",
+                              "#99FF99", "#99FFFF", "#CCFFFF", "#CCCCFF", "#FFCCFF",
+                              "#CCCCCC", "#FF6666", "#FF9966", "#FFFF66", "#FFFF33",
+                              "#66FF99", "#33FFFF", "#66FFFF", "#9999FF", "#FF99FF",
+                              "#C0C0C0", "#FF0000", "#FF9900", "#FFCC66", "#FFFF00",
+                              "#33FF33", "#66CCCC", "#33CCFF", "#6666CC", "#CC66CC",
+                              "#999999", "#CC0000", "#FF6600", "#FFCC33", "#FFCC00",
+                              "#33CC00", "#00CCCC", "#3366FF", "#6633FF", "#CC33CC",
+                              "#666666", "#990000", "#CC6600", "#CC9933", "#999900",
+                              "#009900", "#339999", "#3333FF", "#6600CC", "#993399",
+                              "#333333", "#660000", "#993300", "#996633", "#666600",
+                              "#006600", "#336666", "#000099", "#333399", "#663366",
+                              "#000000", "#330000", "#663300", "#663333", "#333300",
+                              "#003300", "#003333", "#000066", "#330099", "#330033"];
+
+        let sum = Array.map(str || " ", function(e) e.charCodeAt(0)).reduce(function(a,b) a + b);
+        return colorPalette[sum % colorPalette.length];
+    }
+}
diff --git a/calendar/providers/gdata/modules/shim/Preferences.jsm b/calendar/providers/gdata/modules/shim/Preferences.jsm
new file mode 100644
index 0000000..536413a
--- /dev/null
+++ b/calendar/providers/gdata/modules/shim/Preferences.jsm
@@ -0,0 +1,13 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+var EXPORTED_SYMBOLS = ["Preferences"];
+
+Components.utils.import("resource://calendar/modules/calUtils.jsm");
+
+var Preferences = {
+    has: function(k) !!cal.getPrefSafe(k),
+    get: function(k, v) cal.getPrefSafe(k, v),
+    set: function(k, v) cal.setPref(k, v)
+};
diff --git a/calendar/providers/gdata/modules/shim/Promise.jsm b/calendar/providers/gdata/modules/shim/Promise.jsm
new file mode 100644
index 0000000..d2433ce
--- /dev/null
+++ b/calendar/providers/gdata/modules/shim/Promise.jsm
@@ -0,0 +1,156 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+var EXPORTED_SYMBOLS = ["Promise"];
+
+const STATUS_PENDING = 0;
+const STATUS_RESOLVED = 1;
+const STATUS_REJECTED = 2;
+
+function log(msg) {
+    // Enable this to debug promises
+    //dump("PROMISES: " + msg + "\n");
+}
+
+var PromiseWalker = {
+    handlers: [],
+    completePromise: function(aPromise, aStatus, aValue) {
+        if (aPromise._status != STATUS_PENDING) {
+            return;
+        }
+        if (aStatus == STATUS_RESOLVED && aValue &&
+            typeof(aValue.then) == "function") {
+          aValue.then(this.completePromise.bind(this, aPromise, STATUS_RESOLVED),
+                      this.completePromise.bind(this, aPromise, STATUS_REJECTED));
+          return;
+        }
+        aPromise._status = aStatus;
+        aPromise._value = aValue;
+        if (aPromise._handlers.length > 0) {
+            this.schedulePromise(aPromise);
+        } else if (aStatus == STATUS_REJECTED) {
+            log("Pending error: " + aValue);
+        }
+    },
+
+    scheduleWalkerLoop: function() {
+        this.walkerLoopScheduled = true;
+        let thread = Components.classes["@mozilla.org/thread-manager;1"]
+                               .getService(Components.interfaces.nsIThreadManager)
+                               .currentThread;
+        thread.dispatch({
+            run: function() {
+                PromiseWalker.walkerLoop();
+            }
+        }, Components.interfaces.nsIEventTarget.DISPATCH_NORMAL);
+    },
+
+    schedulePromise: function (aPromise) {
+        for each (let handler in aPromise._handlers) {
+            this.handlers.push(handler);
+        }
+        aPromise._handlers.length = 0;
+
+        if (!this.walkerLoopScheduled) {
+            this.scheduleWalkerLoop();
+        }
+    },
+
+    walkerLoopScheduled: false,
+
+    walkerLoop: function() {
+        if (this.handlers.length > 1) {
+            this.scheduleWalkerLoop();
+        } else {
+            this.walkerLoopScheduled = false;
+        }
+
+        while (this.handlers.length > 0) {
+            this.handlers.shift().process();
+        }
+    }
+};
+PromiseWalker.walkerLoop = PromiseWalker.walkerLoop.bind(PromiseWalker);
+
+function Handler(aThisPromise, aOnResolve, aOnReject) {
+    this.thisPromise = aThisPromise;
+    this.onResolve = aOnResolve;
+    this.onReject = aOnReject;
+    this.nextPromise = new Promise(function() {});
+}
+Handler.prototype = {
+    process: function() {
+        let nextStatus = this.thisPromise._status;
+        let nextValue = this.thisPromise._value;
+
+        try {
+            if (nextStatus == STATUS_RESOLVED) {
+                if (typeof(this.onResolve) == "function") {
+                    nextValue = this.onResolve.call(undefined, nextValue);
+                }
+            } else if (typeof(this.onReject) == "function") {
+                nextValue = this.onReject.call(undefined, nextValue);
+                nextStatus = STATUS_RESOLVED;
+            }
+        } catch (ex) {
+            // Enable this to get promise debugging
+            log("EXCEPTION: " + ex + "\n" + ex.stack + ex.printStackTrace);
+            nextStatus = STATUS_REJECTED;
+            nextValue = ex;
+        }
+
+        PromiseWalker.completePromise(this.nextPromise, nextStatus, nextValue);
+    }
+};
+function Deferred() {
+    this.promise = new Promise(function(aResolve, aReject) {
+        this.resolve = aResolve;
+        this.reject = aReject;
+    }.bind(this));
+}
+
+function Promise(executor) {
+    this._handlers = [];
+
+    let resolve = PromiseWalker.completePromise.bind(PromiseWalker, this, STATUS_RESOLVED);
+    let reject = PromiseWalker.completePromise.bind(PromiseWalker, this, STATUS_REJECTED);
+
+    try {
+        executor.call(undefined, resolve, reject);
+    } catch (ex) {
+        reject(ex);
+    }
+
+}
+
+Promise.prototype = {
+    _status: STATUS_PENDING,
+    _value: undefined,
+
+    then: function(aOnResolve, aOnReject) {
+        let handler = new Handler(this, aOnResolve, aOnReject);
+        this._handlers.push(handler);
+        if (this._status != STATUS_PENDING) {
+            PromiseWalker.schedulePromise(this);
+        }
+        return handler.nextPromise;
+    },
+    catch: function(onreject) {
+        return this.then(undefined, onReject);
+    }
+};
+
+Promise.defer = function() {
+    return new Deferred();
+};
+
+Promise.resolve = function(aValue) {
+    if (aValue instanceof Promise) {
+        return aValue;
+    }
+    return new Promise(function(aResolve) aResolve(aValue));
+};
+Promise.reject = function(aReason) {
+    return new Promise(function(_, aReject) aReject(aReason));
+}
diff --git a/calendar/providers/gdata/modules/shim/Task.jsm b/calendar/providers/gdata/modules/shim/Task.jsm
new file mode 100644
index 0000000..a51a128
--- /dev/null
+++ b/calendar/providers/gdata/modules/shim/Task.jsm
@@ -0,0 +1,139 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+this.EXPORTED_SYMBOLS = [
+  "Task"
+];
+
+const Cc = Components.classes;
+const Ci = Components.interfaces;
+const Cu = Components.utils;
+const Cr = Components.results;
+
+Cu.import("resource://gdata-provider/modules/shim/Promise.jsm");
+
+// The following error types are considered programmer errors, which should be
+// reported (possibly redundantly) so as to let programmers fix their code.
+const ERRORS_TO_REPORT = ["EvalError", "RangeError", "ReferenceError", "TypeError"];
+
+let gCurrentTask = null;
+
+function linesOf(string) {
+  let reLine = /([^\r\n])+/g;
+  let match;
+  while ((match = reLine.exec(string))) {
+    yield [match[0], match.index];
+  }
+};
+
+function isGenerator(aValue) {
+  return Object.prototype.toString.call(aValue) == "[object Generator]";
+}
+
+this.Task = {
+  spawn: function Task_spawn(aTask) {
+    return createAsyncFunction(aTask).call(undefined);
+  },
+
+  async: function Task_async(aTask) {
+    if (typeof(aTask) != "function") {
+      throw new TypeError("aTask argument must be a function");
+    }
+
+    return createAsyncFunction(aTask);
+  },
+
+  Result: function Task_Result(aValue) {
+    this.value = aValue;
+  }
+};
+
+function createAsyncFunction(aTask) {
+  let asyncFunction = function () {
+    let result = aTask;
+    if (aTask && typeof(aTask) == "function") {
+      if (aTask.isAsyncFunction) {
+        throw new TypeError(
+          "Cannot use an async function in place of a promise. " +
+          "You should either invoke the async function first " +
+          "or use 'Task.spawn' instead of 'Task.async' to start " +
+          "the Task and return its promise.");
+      }
+
+      try {
+        // Let's call into the function ourselves.
+        result = aTask.apply(this, arguments);
+      } catch (ex if ex instanceof Task.Result) {
+        return Promise.resolve(ex.value);
+      } catch (ex) {
+        return Promise.reject(ex);
+      }
+    }
+
+    if (isGenerator(result)) {
+      // This is an iterator resulting from calling a generator function.
+      return new TaskImpl(result).deferred.promise;
+    }
+
+    // Just propagate the given value to the caller as a resolved promise.
+    return Promise.resolve(result);
+  };
+
+  asyncFunction.isAsyncFunction = true;
+
+  return asyncFunction;
+}
+
+function TaskImpl(iterator) {
+  this.deferred = Promise.defer();
+  this._iterator = iterator;
+  this._run(true);
+}
+
+TaskImpl.prototype = {
+  deferred: null,
+  _iterator: null,
+
+  _run: function TaskImpl_run(aSendResolved, aSendValue) {
+    try {
+      gCurrentTask = this;
+
+      try {
+        let yielded = aSendResolved ? this._iterator.send(aSendValue)
+                                    : this._iterator.throw(aSendValue);
+        this._handleResultValue(yielded);
+      } catch (ex if ex instanceof Task.Result) {
+        this.deferred.resolve(ex.value);
+      } catch (ex if ex instanceof StopIteration) {
+        this.deferred.resolve(undefined);
+      } catch (ex) {
+        this._handleException(ex);
+      }
+    } finally {
+      if (gCurrentTask == this) {
+        gCurrentTask = null;
+      }
+    }
+  },
+
+  _handleResultValue: function TaskImpl_handleResultValue(aValue) {
+    if (isGenerator(aValue)) {
+      aValue = Task.spawn(aValue);
+    }
+
+    if (aValue && typeof(aValue.then) == "function") {
+      aValue.then(this._run.bind(this, true),
+                  this._run.bind(this, false));
+    } else {
+      this._run(true, aValue);
+    }
+  },
+
+  _handleException: function TaskImpl_handleException(aException) {
+    gCurrentTask = this;
+    this.deferred.reject(aException);
+  }
+};
diff --git a/calendar/providers/gdata/modules/shim/Timer.jsm b/calendar/providers/gdata/modules/shim/Timer.jsm
new file mode 100644
index 0000000..8668365
--- /dev/null
+++ b/calendar/providers/gdata/modules/shim/Timer.jsm
@@ -0,0 +1,14 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+var EXPORTED_SYMBOLS = ["setTimeout"];
+
+function setTimeout(func, timeout) {
+    let timer = Components.classes["@mozilla.org/timer;1"]
+                          .createInstance(Components.interfaces.nsITimer);
+
+    timer.initWithCallback({ notify: func }, timeout, timer.TYPE_ONE_SHOT);
+    // Timer.jsm usually keeps track of the timers to be able to cancel them,
+    // but we only use it for postponing things so this is enough.
+}
diff --git a/calendar/providers/gdata/modules/timezoneMap.jsm b/calendar/providers/gdata/modules/timezoneMap.jsm
new file mode 100644
index 0000000..e0e1547
--- /dev/null
+++ b/calendar/providers/gdata/modules/timezoneMap.jsm
@@ -0,0 +1,106 @@
+// Mappings Copyright  1991-2013 Unicode, Inc. with modifications.
+// http://unicode.org/repos/cldr/trunk/common/supplemental/windowsZones.xml
+
+var EXPORTED_SYMBOLS = ["windowsTimezoneMap"];
+
+var windowsTimezoneMap = {
+    "Hawaiian Standard Time": "Pacific/Honolulu",
+    "Alaskan Standard Time": "America/Anchorage",
+    "Pacific Standard Time (Mexico)": "America/Santa_Isabel",
+    "Pacific Standard Time": "America/Los_Angeles",
+    "US Mountain Standard Time": "America/Phoenix",
+    "Mountain Standard Time (Mexico)": "America/Chihuahua",
+    "Mountain Standard Time": "America/Denver",
+    "Central America Standard Time": "America/Guatemala",
+    "Central Standard Time": "America/Chicago",
+    "Central Standard Time (Mexico)": "America/Mexico_City",
+    "Canada Central Standard Time": "America/Regina",
+    "SA Pacific Standard Time": "America/Bogota",
+    "Eastern Standard Time": "America/New_York",
+    "US Eastern Standard Time": "America/Indianapolis",
+    "Venezuela Standard Time": "America/Caracas",
+    "Paraguay Standard Time": "America/Asuncion",
+    "Atlantic Standard Time": "America/Halifax",
+    "Central Brazilian Standard Time": "America/Cuiaba",
+    "SA Western Standard Time": "America/La_Paz",
+    "Pacific SA Standard Time": "America/Santiago",
+    "Newfoundland Standard Time": "America/St_Johns",
+    "E. South America Standard Time": "America/Sao_Paulo",
+    "Argentina Standard Time": "America/Buenos_Aires",
+    "SA Eastern Standard Time": "America/Cayenne",
+    "Greenland Standard Time": "America/Godthab",
+    "Montevideo Standard Time": "America/Montevideo",
+    "Bahia Standard Time": "America/Bahia",
+    "Azores Standard Time": "Atlantic/Azores",
+    "Cape Verde Standard Time": "Atlantic/Cape_Verde",
+    "Morocco Standard Time": "Africa/Casablanca",
+    "GMT Standard Time": "Europe/London",
+    "Greenwich Standard Time": "Atlantic/Reykjavik",
+    "W. Europe Standard Time": "Europe/Berlin",
+    "Central Europe Standard Time": "Europe/Budapest",
+    "Romance Standard Time": "Europe/Paris",
+    "Central European Standard Time": "Europe/Warsaw",
+    "W. Central Africa Standard Time": "Africa/Lagos",
+    "Namibia Standard Time": "Africa/Windhoek",
+    "Jordan Standard Time": "Asia/Amman",
+    "GTB Standard Time": "Europe/Bucharest",
+    "Middle East Standard Time": "Asia/Beirut",
+    "Egypt Standard Time": "Africa/Cairo",
+    "Syria Standard Time": "Asia/Damascus",
+    "South Africa Standard Time": "Africa/Johannesburg",
+    "FLE Standard Time": "Europe/Kiev",
+    "Turkey Standard Time": "Europe/Istanbul",
+    "Israel Standard Time": "Asia/Jerusalem",
+    "Kaliningrad Standard Time": "Europe/Kaliningrad",
+    "Libya Standard Time": "Africa/Tripoli",
+    "Arabic Standard Time": "Asia/Baghdad",
+    "Arab Standard Time": "Asia/Riyadh",
+    "Belarus Standard Time": "Europe/Minsk",
+    "Russian Standard Time": "Europe/Moscow",
+    "E. Africa Standard Time": "Africa/Nairobi",
+    "Iran Standard Time": "Asia/Tehran",
+    "Arabian Standard Time": "Asia/Dubai",
+    "Azerbaijan Standard Time": "Asia/Baku",
+    "Russia Time Zone 3": "Europe/Samara",
+    "Mauritius Standard Time": "Indian/Mauritius",
+    "Georgian Standard Time": "Asia/Tbilisi",
+    "Caucasus Standard Time": "Asia/Yerevan",
+    "Afghanistan Standard Time": "Asia/Kabul",
+    "West Asia Standard Time": "Asia/Tashkent",
+    "Ekaterinburg Standard Time": "Asia/Yekaterinburg",
+    "Pakistan Standard Time": "Asia/Karachi",
+    "India Standard Time": "Asia/Calcutta",
+    "Sri Lanka Standard Time": "Asia/Colombo",
+    "Nepal Standard Time": "Asia/Katmandu",
+    "Central Asia Standard Time": "Asia/Almaty",
+    "Bangladesh Standard Time": "Asia/Dhaka",
+    "N. Central Asia Standard Time": "Asia/Novosibirsk",
+    "Myanmar Standard Time": "Asia/Rangoon",
+    "SE Asia Standard Time": "Asia/Bangkok",
+    "North Asia Standard Time": "Asia/Krasnoyarsk",
+    "China Standard Time": "Asia/Shanghai",
+    "North Asia East Standard Time": "Asia/Irkutsk",
+    "Singapore Standard Time": "Asia/Singapore",
+    "W. Australia Standard Time": "Australia/Perth",
+    "Taipei Standard Time": "Asia/Taipei",
+    "Ulaanbaatar Standard Time": "Asia/Ulaanbaatar",
+    "Tokyo Standard Time": "Asia/Tokyo",
+    "Korea Standard Time": "Asia/Seoul",
+    "Yakutsk Standard Time": "Asia/Yakutsk",
+    "Cen. Australia Standard Time": "Australia/Adelaide",
+    "AUS Central Standard Time": "Australia/Darwin",
+    "E. Australia Standard Time": "Australia/Brisbane",
+    "AUS Eastern Standard Time": "Australia/Sydney",
+    "West Pacific Standard Time": "Pacific/Port_Moresby",
+    "Tasmania Standard Time": "Australia/Hobart",
+    "Magadan Standard Time": "Asia/Magadan",
+    "Vladivostok Standard Time": "Asia/Vladivostok",
+    "Russia Time Zone 10": "Asia/Srednekolymsk",
+    "Central Pacific Standard Time": "Pacific/Guadalcanal",
+    "Russia Time Zone 11": "Asia/Kamchatka",
+    "New Zealand Standard Time": "Pacific/Auckland",
+    "Fiji Standard Time": "Pacific/Fiji",
+    "Tonga Standard Time": "Pacific/Tongatapu",
+    "Samoa Standard Time": "Pacific/Apia",
+    "Line Islands Standard Time": "Pacific/Kiritimati",
+};
diff --git a/calendar/providers/gdata/moz.build b/calendar/providers/gdata/moz.build
index e257cc9..cd0dfc4 100644
--- a/calendar/providers/gdata/moz.build
+++ b/calendar/providers/gdata/moz.build
@@ -3,12 +3,34 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
+XPI_NAME = 'gdata-provider'
+
 DIRS += [
-    'components',
     'locales',
-    'public',
 ]
 
-XPI_NAME = 'gdata-provider'
+EXTRA_JS_MODULES += [
+    'modules/gdataLogging.jsm',
+    'modules/gdataRequest.jsm',
+    'modules/gdataSession.jsm',
+    'modules/gdataUtils.jsm',
+    'modules/OAuth2.jsm',
+    'modules/timezoneMap.jsm',
+]
+
+EXTRA_JS_MODULES.shim = [
+    'modules/shim/Calendar.jsm',
+    'modules/shim/Http.jsm',
+    'modules/shim/Loader.jsm',
+    'modules/shim/Preferences.jsm',
+    'modules/shim/Promise.jsm',
+    'modules/shim/Task.jsm',
+    'modules/shim/Timer.jsm',
+]
+
+EXTRA_COMPONENTS += [
+    'components/calGoogleCalendar.js',
+    'components/calGoogleCalendar.manifest',
+]
 
 JAR_MANIFESTS += ['jar.mn']
diff --git a/calendar/providers/gdata/public/calIGoogleCalendar.idl b/calendar/providers/gdata/public/calIGoogleCalendar.idl
deleted file mode 100644
index 1beec62..0000000
--- a/calendar/providers/gdata/public/calIGoogleCalendar.idl
+++ /dev/null
@@ -1,81 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "calICalendar.idl"
-
-interface calIGoogleSession;
-interface nsIURI;
-
-[scriptable, uuid(d1a6e988-4b4d-45a5-ba46-43e501ea96e3)]
-interface calIGoogleCalendar : calICalendar
-{
-    /**
-     * attribute googleCalendarName
-     * Google's Calendar name. This represents the <calendar name> in
-     * http://www.google.com/calendar/feeds/<calendar name>/private/full
-     */
-    readonly attribute AUTF8String googleCalendarName;
-
-    /**
-     * attribute isDefaultCalendar
-     * If true, this is the users default calendar. Non-default calendars have
-     * a calendar name that contains "@group.calendar.google.com"
-     */
-    readonly attribute boolean isDefaultCalendar;
-
-    /**
-     * While calICalendar::uri returns the uri set by the user, fullUri returns
-     * Google's "full" feed.
-     *
-     * XXX This will go away once the provider implements a custom add calendar
-     * wizard, since uri will always be set to the full uri in that case.
-     */
-    attribute nsIURI fullUri;
-
-    /**
-     * The username used to access the calendar. Changing this sets the session
-     * to a calIGoogleSession object with the given username.
-     */
-    attribute AUTF8String googleUser;
-
-    /**
-     * The session object associated with this calendar. Set this by changing
-     * the googleUser attribute.
-     */
-    readonly attribute calIGoogleSession session;
-
-    /**
-     * The calender title as provided by Google. This information is cached.
-     */
-    attribute AUTF8String title;
-
-    /**
-     * The access level that was set in Google's calendar UI. This information
-     * is cached.
-     */
-    attribute AUTF8String access;
-
-    /**
-     * If set, the calendar is "selected" in the Google Calendar UI.
-     */
-    attribute boolean selected;
-
-    /**
-     * If set, the calendar is hidden from the Google Calendar UI. It is still
-     * visible when managing calendars though.
-     */
-    attribute boolean hidden;
-
-    /**
-     * The color that was set in Google's calendar UI. This information is
-     * cached.
-     */
-    attribute AUTF8String color;
-
-    /**
-     * The timezone that was set in Google's calendar UI. This information is
-     * cached.
-     */
-    attribute AUTF8String timezone;
-};
diff --git a/calendar/providers/gdata/public/calIGoogleRequest.idl b/calendar/providers/gdata/public/calIGoogleRequest.idl
deleted file mode 100644
index 54330a2..0000000
--- a/calendar/providers/gdata/public/calIGoogleRequest.idl
+++ /dev/null
@@ -1,123 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "calIOperation.idl"
-
-interface calICalendar;
-interface calIGoogleSession;
-interface calIGoogleCalendar;
-interface calIGenericOperationListener;
-interface calIOperationListener;
-interface calIDateTime;
-interface calIItemBase;
-
-interface nsIVariant;
-
-[scriptable, uuid(53a3438a-21bc-4a0f-b813-77a8b4f19282)]
-interface calIGoogleRequest : calIOperation {
-
-    const unsigned long LOGIN = 0;
-    const unsigned long ADD = 1;
-    const unsigned long MODIFY = 2;
-    const unsigned long DELETE = 3;
-    const unsigned long GET = 4;
-
-    /**
-     * The type of request. Must be one of the above constants.
-     */
-    attribute uint32_t type;
-
-    /**
-     * The request uri string
-     */
-    attribute AUTF8String uri;
-
-    /**
-     * The operation listener. This is not called by the request object, but can
-     * be used by the response listener to call the original listener that
-     * caused the request
-     */
-    attribute calIOperationListener operationListener;
-
-    /**
-     * The response listener. This will be called as soon as the request to
-     * google has completed.
-     */
-    attribute calIGenericOperationListener responseListener;
-
-    /**
-     * The calendar that initiated the request
-     */
-    attribute calIGoogleCalendar calendar;
-
-    /**
-     * The destination calendar, used for synchronization runs.
-     */
-    attribute calICalendar destinationCal;
-
-    /**
-     * If set to false, an authentication failure should not cause any dialogs
-     * to show up that cause reauthentication, but the failure should be
-     * returned directly.
-     *
-     * This attribute defaults to true.
-     */
-    attribute boolean reauthenticate;
-
-    /**
-     * Various options to be carried through to the response listener.
-     * XXX The corresponding options are not set up automatically just by
-     * setting these options. You still need to use addQueryParameter to filter
-     * by item range or other property.
-     */
-    attribute calIDateTime itemRangeStart;
-    attribute calIDateTime itemRangeEnd;
-    attribute unsigned long itemFilter;
-    attribute AUTF8String itemId;
-    attribute boolean useCache;
-
-    /**
-     * For add/modify/delete item requests, these contain the old and new items.
-     */
-    attribute calIItemBase newItem;
-    attribute calIItemBase oldItem;
-
-    /**
-     * Set up some upload data using the given content type
-     *
-     * @param aContentType      The value of the content type header to be set.
-     * @param aData             The Data to be uploaded.
-     */
-    void setUploadData(in AUTF8String aContentType, in AUTF8String aData);
-
-    /**
-     * Adds a query parameter to the request. These will be escaped.
-     *
-     * @param aKey      The key of the query parameter.
-     * @param aValue    The value of the query parameter.
-     */
-    void addQueryParameter(in AUTF8String aKey, in AUTF8String aValue);
-
-    /**
-     * Run the request, using the specified session.
-     *
-     * @param aSession      The session to request with.
-     */
-    void commit(in calIGoogleSession aSession);
-
-    /**
-     * Tell listeners that the operation failed
-     *
-     * @param aCode     The error code to use.
-     * @param aMessage  The error message to use.
-     */
-    void fail(in uint32_t aCode, in AUTF8String aMessage);
-
-    /**
-     * Tell listeners that the operation succeeded.
-     *
-     * @param aMessage  The error message to use.
-     */
-    void succeed(in AUTF8String aMessage);
-};
diff --git a/calendar/providers/gdata/public/calIGoogleSession.idl b/calendar/providers/gdata/public/calIGoogleSession.idl
deleted file mode 100644
index dd092f2..0000000
--- a/calendar/providers/gdata/public/calIGoogleSession.idl
+++ /dev/null
@@ -1,84 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "nsISupports.idl"
-
-interface calIGoogleSession;
-interface calIGoogleCalendar;
-interface calIEvent;
-interface calIDateTime;
-interface calIGenericOperationListener;
-interface calIOperationListener;
-interface calIGoogleRequest;
-interface calIOperation;
-
-interface nsIVariant;
-
-[scriptable, uuid(6a7ba1f0-f271-49b0-8e93-5ca33651b4af)]
-interface calIGoogleSessionManager : nsISupports {
-    /**
-     * getSessionByUsername
-     * Get a Session object for the specified username. If aCreate is false,
-     * null will be returned if the session doesn't exist. Otherwise, the
-     * session will be created.
-     *
-     * @param aUsername The username to get the session for
-     * @param aCreate   If true, the session will be created prior to returning
-     */
-     calIGoogleSession getSessionByUsername(in AUTF8String aUsername, in boolean aCreate);
-
-};
-
-[scriptable, uuid(652f6233-e03f-438a-bd3b-39877f68c0f4)]
-interface calIGoogleSession : nsISupports {
-    /**
-     * The Authentication Token from Google
-     */
-    readonly attribute AUTF8String authToken;
-
-    /**
-     * The username for this session. To get a session with a different
-     * username, use calIGoogleSessionManager.
-     */
-    readonly attribute AUTF8String userName;
-
-    /**
-     * If set, the password will persist across restarts.
-     */
-    attribute boolean persist;
-
-    /**
-     * The user's full name, usually retrieved from the XML <author> fields. If
-     * unset, this will return the userName attribute.
-     */
-    attribute AUTF8String fullName;
-
-    /**
-     * The password used to authenticate. It is only important to implement the
-     * setter here, since the password is only used internally.
-     */
-    attribute AUTF8String password;
-
-    /**
-     * Resets the Auth token and sets the persist attribute to false.
-     */
-    void invalidate();
-
-    /**
-     * getCalendars
-     * Get the list of calendars for this session. The operaion listener will be
-     * called with an array of calIGoogleCalendars.
-     *
-     * @param aListener The listener to call when the calendars were retrieved
-     */
-    calIOperation getCalendars(in calIGenericOperationListener aListener);
-
-    /**
-     * asyncItemRequest
-     * Send a request to Google, logging in to the session if required.
-     *
-     * @param aRequest      The calIGoogleRequest to send
-     */
-    void asyncItemRequest(in calIGoogleRequest aRequest);
-};
diff --git a/calendar/providers/gdata/public/moz.build b/calendar/providers/gdata/public/moz.build
deleted file mode 100644
index 62751b8..0000000
--- a/calendar/providers/gdata/public/moz.build
+++ /dev/null
@@ -1,13 +0,0 @@
-# vim: set filetype=python:
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-XPIDL_SOURCES += [
-    'calIGoogleCalendar.idl',
-    'calIGoogleRequest.idl',
-    'calIGoogleSession.idl',
-]
-
-XPIDL_MODULE = 'gdata'
-
diff --git a/calendar/test/unit/test_gdata_provider.js b/calendar/test/unit/test_gdata_provider.js
new file mode 100644
index 0000000..8f1b732
--- /dev/null
+++ b/calendar/test/unit/test_gdata_provider.js
@@ -0,0 +1,1464 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+(function load_gdata_manifest() {
+  Components.utils.import("resource:///modules/Services.jsm");
+  Services.prefs.setBoolPref("javascript.options.showInConsole", true);
+  Services.prefs.setBoolPref("browser.dom.window.dump.enabled", true);
+  Services.prefs.setBoolPref("calendar.debug.log", true);
+  Services.prefs.setBoolPref("calendar.debug.log.verbose", true);
+
+  let bindir = Services.dirsvc.get("CurProcD", Components.interfaces.nsIFile);
+  bindir.append("extensions");
+  bindir.append("{a62ef8ec-5fdc-40c2-873c-223b8a6925cc}");
+  bindir.append("chrome.manifest");
+  dump("Loading" + bindir.path + "\n");
+  Components.manager.autoRegister(bindir);
+})();
+
+Components.utils.import("resource://testing-common/httpd.js");
+Components.utils.import("resource://gre/modules/NetUtil.jsm");
+Components.utils.import("resource://gre/modules/Preferences.jsm");
+
+Components.utils.import("resource://gdata-provider/modules/gdataSession.jsm");
+Components.utils.import("resource://gdata-provider/modules/gdataUtils.jsm");
+Components.utils.import("resource://calendar/modules/calAsyncUtils.jsm");
+Components.utils.import("resource://calendar/modules/calProviderUtils.jsm");
+
+var MockConflictPrompt = {
+    _origFunc: null,
+    overwrite: false,
+    register: function() {
+        if (!this._origFunc) {
+            this._origFunc = cal.promptOverwrite;
+            cal.promptOverwrite = (aMode, aItem) => {
+                return this.overwrite;
+            };
+        }
+    },
+
+    unregister: function() {
+        if (this._origFunc) {
+            cal.promptOverwrite = this._origFunc;
+            this._origFunc = null;
+        }
+    }
+};
+
+function GDataServer(calendarId, tasksId) {
+    this.server = new HttpServer();
+    this.calendarId = calendarId;
+    this.tasksId = tasksId;
+
+    let events = "/calendar/v3/calendars/" + calendarId + "/events";
+    let tasks = "/tasks/v1/lists/" + tasksId + "/tasks";
+    let calendarList = "/calendar/v3/users/me/calendarList/" + calendarId;
+
+    this.server.registerPathHandler(calendarList, this.router.bind(this, this.calendarListRequest.bind(this)));
+    this.server.registerPathHandler(events, this.router.bind(this, this.eventsRequest.bind(this)));
+    this.server.registerPrefixHandler(events + "/", this.router.bind(this, this.eventsRequest.bind(this)));
+    this.server.registerPathHandler(tasks, this.router.bind(this, this.tasksRequest.bind(this)));
+    this.server.registerPrefixHandler(tasks + "/", this.router.bind(this, this.tasksRequest.bind(this)));
+
+    this.resetRequest();
+
+    let sessionMgr = getGoogleSessionManager();
+    this.session = sessionMgr.getSessionById("xpcshell", true);
+    this.session.oauth = {
+        accessToken: "accessToken",
+        refreshToken: "refreshToken",
+        tokenExpires: Number.MAX_VALUE,
+        connect: function(succ, fail, ui, refresh) {
+            this.accessToken = "accessToken";
+            succ();
+        }
+    };
+}
+
+GDataServer.prototype = {
+    items: null,
+
+    get baseUri() "http://localhost:" + this.server.identity.primaryPort + "/",
+
+    start: function() {
+        this.server.start(-1);
+        do_register_cleanup(() => this.server.stop(() => {}));
+    },
+
+    resetClient: function(client) {
+        this.resetRequest();
+        MockConflictPrompt.unregister();
+        cal.getCalendarManager().unregisterCalendar(client);
+    },
+
+    resetRequest: function() {
+        this.events = [];
+        this.tasks = [];
+        this.nextEtag = null;
+        this.syncs = [];
+        this.nextEventStatus = [];
+
+        this.creator = {
+            "email": "xpcshell@example.com",
+            "self": true,
+            "displayName": "Eggs P. Seashell"
+        };
+
+        this.eventsData = {
+           "kind": "calendar#events",
+           "etag": "\"1410880601360000\"",
+           "nextSyncToken": generateID(),
+           "updated": "2014-09-16T15:16:41.360Z",
+           "accessRole": "owner",
+           "summary": "xpcshell",
+           "timeZone": "Europe/Berlin",
+           "defaultReminders": [],
+           "items": []
+        };
+
+        this.tasksData = {
+            "kind": "tasks#tasks",
+            "etag": "\"1410880601360000\"",
+            "items": []
+        };
+
+        this.calendarListData = {
+            "kind": "calendar#calendarListEntry",
+            "etag": "\"1410084814736000\"",
+            "id": this.calendarId,
+            "summary": "xpcshell",
+            "timeZone": "Europe/Berlin",
+            "colorId": "17",
+            "backgroundColor": "#9a9cff",
+            "foregroundColor": "#000000",
+            "primary": true,
+            "selected": true,
+            "accessRole": "owner",
+            "defaultReminders": [],
+            "notificationSettings": {
+                "notifications": [
+                    { "type": "eventCreation", "method": "email" },
+                    { "type": "eventChange", "method": "email" },
+                    { "type": "eventCancellation",  "method": "email" }
+                ]
+            }
+        };
+    },
+
+    waitForLoad: function(aCalendar) {
+        let { resolve, promise } = Promise.defer();
+        let observer = cal.createAdapter(Components.interfaces.calIObserver, {
+            onLoad: function() {
+                aCalendar.removeObserver(observer);
+                resolve(aCalendar);
+            }
+        });
+        aCalendar.addObserver(observer);
+        return promise;
+    },
+
+    getClient: function() {
+        let uri = "googleapi://xpcshell/" +
+                  "?testport=" + this.server.identity.primaryPort +
+                  (this.calendarId ? "&calendar=" + encodeURIComponent(this.calendarId) : "") +
+                  (this.tasksId ? "&tasks=" + encodeURIComponent(this.tasksId) : "");
+        let calmgr = cal.getCalendarManager();
+        let client = calmgr.createCalendar("gdata", Services.io.newURI(uri, null, null));
+        client.name = "xpcshell";
+        calmgr.registerCalendar(client);
+        MockConflictPrompt.register();
+
+        let cachedCalendar = calmgr.getCalendarById(client.id);
+        return this.waitForLoad(cachedCalendar);
+    },
+
+    router: function(nextHandler, request, response) {
+        try {
+            let method = request.hasHeader("X-HTTP-Method-Override") ?
+                         request.getHeader("X-HTTP-Method-Override") :
+                         request.method;
+            let parameters = new Map([ p.split("=", 2) for (p of request.queryString.split("&")) ]);
+
+            let body;
+            try {
+                body = JSON.parse(NetUtil.readInputStreamToString(request.bodyInputStream,
+                                  request.bodyInputStream.available()));
+            } catch (e) {}
+
+            return nextHandler(request, response, method, parameters, body);
+        } catch (e) {
+            do_print("Server Error: " + e.fileName + ":" + e.lineNumber + ": " + e + "\n");
+        }
+    },
+
+    calendarListRequest: function(request, response, method, parameters, body) {
+        let data = this.calendarListData;
+        response.write(JSON.stringify(data));
+    },
+
+    eventsRequest: function(request, response, method, parameters, body) {
+        if (method == "GET") {
+            let data = this.eventsData;
+            if (request.hasHeader("timeZone")) {
+                data.timeZone = request.getHeader("timeZone");
+            }
+
+            // The fakeserver doesn't support both pagination and sync tokens
+            // for sake of simplicity.
+            if (this.syncs.length) {
+                let syncToken = parameters.get("syncToken") || this.syncs[0].token;
+                let sync = this.syncs.shift();
+                let nextSyncToken = this.syncs[0] ? this.syncs[0].token : "last";
+
+                if (!sync || syncToken != sync.token) {
+                    do_throw("Request in wrong order or not enough syncs");
+                }
+                if (sync.reset) {
+                    response.setStatusLine(null, 410, "Gone");
+                    return;
+                }
+                data.nextSyncToken = nextSyncToken;
+                data.items = sync.events;
+            } else {
+                this.paginateRequest(parameters, this.events, data);
+            }
+            response.write(JSON.stringify(data));
+         } else if (method == "POST") {
+            // Add an event
+            let isImport = request.path.endsWith("/events/import");
+            let data = this.processAddEvent(body, isImport);
+            this.events.push(data);
+            response.setStatusLine(null, 201, "Created");
+            response.write(JSON.stringify(data));
+         } else if (method == "PUT" && request.path.match(/\/events\/([a-z0-9_TZ]+)$/)) {
+            // Modify an event
+            dump("PUTTING EVENT\n" + body);
+            let eventId = RegExp.$1;
+            this.handleModify(request, response, body, this.events, eventId,
+                              this.processModifyEvent.bind(this));
+        } else if (method == "DELETE" && request.path.match(/\/events\/([a-z0-9_TZ]+)$/)) {
+            let eventId = RegExp.$1;
+            this.handleDelete(request, response, this.events, eventId);
+        }
+    },
+
+    tasksRequest: function(request, response, method, parameters, body) {
+        if (method == "GET") {
+            let data = this.tasksData;
+
+            this.paginateRequest(parameters, this.tasks, data);
+            delete data.nextSyncToken;
+
+            response.write(JSON.stringify(data));
+        } else if (method == "POST") {
+            let data = this.processAddTask(body);
+            this.tasks.push(data);
+            response.setStatusLine(null, 201, "Created");
+            response.write(JSON.stringify(data));
+        } else if (method == "PUT" && request.path.match(/\/tasks\/([A-Za-z0-9]+)$/)) {
+            let taskId = RegExp.$1;
+            this.handleModify(request, response, body, this.tasks, taskId,
+                              this.processModifyTask.bind(this));
+        } else if (method == "DELETE" && request.path.match(/\/tasks\/([A-Za-z0-9]+)$/)) {
+            let taskId = RegExp.$1;
+            this.handleDelete(request, response, this.tasks, taskId);
+        }
+    },
+
+    paginateRequest: function(parameters, items, data) {
+        let maxResults = parameters.has("maxResults") ? parseInt(parameters.get("maxResults"), 10) : 50;
+        let offset = parameters.has("pageToken") ? parseInt(parameters.get("pageToken"), 10) || 0 : 0;
+        let nextOffset = offset + maxResults;
+        if (nextOffset > items.length) {
+            delete data.nextPageToken;
+            data.nextSyncToken = "next-sync-token";
+        } else {
+            delete data.nextSyncToken;
+            data.nextPageToken = nextOffset;
+        }
+
+        data.items = items.slice(offset, offset + maxResults);
+    },
+
+    handleModify: function(request, response, body, items, itemId, modifyFunc) {
+        // Modify an event
+        let [foundIndex, foundItem] = findKey(items, "id", itemId);
+
+        let matchTag = request.hasHeader("If-Match") ?
+                       request.getHeader("If-Match") : null;
+
+        if (foundIndex != -1) {
+            if (!matchTag || matchTag == "*" || foundItem.etag == matchTag) {
+                items[foundIndex] = modifyFunc(body, itemId);
+                response.write(JSON.stringify(items[foundIndex]));
+            } else {
+                response.setStatusLine(null, 412, "Precondition Failed");
+            }
+        } else if (matchTag == "*") {
+            let data = modifyFunc(body, itemId);
+            items.push(data);
+            response.write(JSON.stringify(data));
+        } else if (body.recurringEventId) {
+            // Special case for events, won't happen on tasks.  This is an
+            // exception that doesn't exist yet. Allow creation in this case.
+            let [foundParentIndex, foundParent] = findKey(items, "id", body.recurringEventId);
+            if (!matchTag || foundParent.etag == matchTag) {
+                let data = modifyFunc(body, itemId);
+                items.push(data);
+                response.write(JSON.stringify(data));
+            } else {
+                response.setStatusLine(null, 412, "Precondition Failed");
+            }
+        } else if (matchTag) {
+            response.setStatusLine(null, 412, "Precondition Failed");
+        } else {
+            response.setStatusLine(null, 404, "Not Found");
+        }
+    },
+
+    handleDelete: function(request, response, items, itemId) {
+        let [foundIndex, foundItem] = findKey(items, "id", itemId);
+
+        let matchTag = request.hasHeader("If-Match") ?
+                       request.getHeader("If-Match") : null;
+
+        if (foundIndex != -1) {
+            if (!matchTag || matchTag == "*" || items[foundIndex].etag == matchTag) {
+                items.splice(foundIndex, 1);
+                response.setStatusLine(null, 204, "No Content");
+            } else {
+                response.setStatusLine(null, 412, "Precondition Failed");
+            }
+        } else if (matchTag == "*") {
+            response.setStatusLine(null, 410, "Gone");
+        } else if (matchTag) {
+            response.setStatusLine(null, 412, "Precondition Failed");
+        } else {
+            response.setStatusLine(null, 404, "Not Found");
+        }
+    },
+
+    processAddEvent: function(jsonData, isImport) {
+        jsonData.kind = "calendar#event";
+        jsonData.etag = this.nextEtag || '"' + (new Date()).getTime() + '"';
+        jsonData.id = generateID();
+        if (!isImport) jsonData.htmlLink = this.baseUri + "/calendar/event?eid=" + jsonData.id;
+        if (!isImport || !jsonData.iCalUID) jsonData.iCalUID = jsonData.id + "@google.com";
+        if (!isImport || !jsonData.created) jsonData.created = cal.toRFC3339(cal.now());
+        if (!isImport || !jsonData.updated) jsonData.updated = cal.toRFC3339(cal.now());
+        if (!isImport || !jsonData.creator) jsonData.creator = this.creator;
+        if (!isImport || !jsonData.organizer) jsonData.organizer = this.creator;
+        this.nextEtag = null;
+        return jsonData;
+    },
+
+    processModifyEvent: function(jsonData, id) {
+        jsonData.kind = "calendar#event";
+        jsonData.etag = this.nextEtag || '"' + (new Date()).getTime() + '"';
+        jsonData.updated  = cal.toRFC3339(cal.now());
+        jsonData.id = id;
+        jsonData.iCalUID = (jsonData.recurringEventId || jsonData.id) + "@google.com";
+        if (!jsonData.creator) jsonData.creator = this.creator;
+        if (!jsonData.organizer) jsonData.organizer = this.creator;
+
+        this.nextEtag = null;
+        return jsonData;
+    },
+
+    processAddTask: function(jsonData) {
+        jsonData.kind = "tasks#task";
+        jsonData.etag = this.nextEtag || '"' + (new Date()).getTime() + '"';
+        jsonData.id = generateID();
+        jsonData.position = generateID(); // Not a real position, but we don't really use this at the moment
+        if (!jsonData.status) jsonData.status = "needsAction";
+        if (!jsonData.updated) jsonData.updated = cal.toRFC3339(cal.now());
+
+        this.nextEtag = null;
+        return jsonData;
+    },
+
+    processModifyTask: function(jsonData) {
+        jsonData.kind = "tasks#task";
+        jsonData.etag = this.nextEtag || '"' + (new Date()).getTime() + '"';
+        jsonData.updated  = cal.toRFC3339(cal.now());
+        if (!jsonData.status) jsonData.status = "needsAction";
+        if (!jsonData.updated) jsonData.updated = cal.toRFC3339(cal.now());
+
+        this.nextEtag = null;
+        return jsonData;
+    },
+};
+
+function findKey(container, key, searchKey) {
+    let foundIndex = -1;
+    for (let i = 0; i < container.length; i++) {
+        if (container[i][key] == searchKey) {
+            foundIndex = i;
+            break;
+        }
+    }
+
+    let foundItem = foundIndex == -1 ? null : container[foundIndex];
+    return [foundIndex, foundItem];
+}
+
+function generateID() {
+    let c = "abcdefghijklmnopqrstuvwxyz0123456789"
+    let s = "";
+    for (let i = 26; i; i--) {
+      s += c[Math.floor(Math.random() * c.length)];
+    }
+    return s;
+}
+
+function getAllMeta(calendar) {
+    let keys = {}, values = {};
+    calendar.getAllMetaData({}, keys, values);
+    return new Map(keys.value.map((k,i) => [k,values.value[i]]));
+}
+
+function run_test() {
+    do_get_profile();
+    cal.getCalendarManager().startup({onResult: function() {
+        gServer = new GDataServer("calendarId", "tasksId");
+        gServer.start();
+        run_next_test();
+    }});
+}
+
+add_test(function test_migrate_uri() {
+    function checkMigrate(fromUri, session, calendarId, tasksId) {
+        let uri = Services.io.newURI(fromUri, null, null);
+        let client = cal.getCalendarManager().createCalendar("gdata", uri);
+
+        if (session) {
+            let target = ("googleapi://" + session + "/?" +
+                         (calendarId ? "&calendar=" + encodeURIComponent(calendarId) : "") +
+                         (tasksId ? "&tasks=" + encodeURIComponent(tasksId) : "")).replace("?&", "?");
+            do_check_eq(client.getProperty("uri"), target);
+        } else {
+            do_check_eq(client.getProperty("uri"), null);
+        }
+    }
+
+    checkMigrate("http://www.google.com/calendar/feeds/example%40example.com/public/full",
+                 "example@example.com", "example@example.com", null);
+
+    checkMigrate("webcal://www.google.com/calendar/feeds/example%40example.com/public/full",
+                 "example@example.com", "example@example.com", null);
+
+    Preferences.set("calendar.google.calPrefs.example@example.com.googleUser", "example@example.com");
+    checkMigrate("http://www.google.com/calendar/feeds/example%40example.com/public/full",
+                 "example@example.com", "example@example.com", "@default");
+
+    checkMigrate("ehmwtf://www.google.com/calendar/feeds/example%40example.com/public/full");
+    checkMigrate("googleapi://session/?calendar=calendarId&tasksId=tasksId");
+
+    run_next_test();
+});
+
+add_task(function* test_organizerCN() {
+    gServer.events = [];
+    let client = yield gServer.getClient();
+    do_check_eq(client.getProperty("organizerCN"), null);
+    gServer.resetClient(client);
+
+    gServer.events = [{
+       "kind": "calendar#event",
+       "etag": "\"2299601498276000\"",
+       "id": "go6ijb0b46hlpbu4eeu92njevo",
+       "created": "2006-06-08T21:04:52.000Z",
+       "updated": "2006-06-08T21:05:49.138Z",
+       "summary": "New Event",
+       "creator": gServer.creator,
+       "organizer": gServer.creator,
+       "start": { "dateTime": "2006-06-10T18:00:00+02:00" },
+       "end": {"dateTime": "2006-06-10T20:00:00+02:00" },
+       "iCalUID": "go6ijb0b46hlpbu4eeu92njevo@google.com"
+    }];
+    let client = yield gServer.getClient();
+    do_check_eq(client.getProperty("organizerCN"), gServer.creator.displayName);
+    gServer.resetClient(client);
+});
+
+add_task(function* test_always_readOnly() {
+    gServer.events = [{
+       "kind": "calendar#event",
+       "etag": "\"2299601498276000\"",
+       "id": "go6ijb0b46hlpbu4eeu92njevo",
+       "created": "2006-06-08T21:04:52.000Z",
+       "updated": "2006-06-08T21:05:49.138Z",
+       "summary": "New Event",
+       "creator": gServer.creator,
+       "organizer": gServer.creator,
+       "start": { "dateTime": "2006-06-10T18:00:00+02:00" },
+       "end": {"dateTime": "2006-06-10T20:00:00+02:00" },
+       "iCalUID": "go6ijb0b46hlpbu4eeu92njevo@google.com"
+    }];
+    gServer.calendarListData.accessRole = "freeBusyReader";
+    let client = yield gServer.getClient();
+    let pclient = cal.async.promisifyCalendar(client);
+    do_check_true(client.readOnly)
+    client.readOnly = false;
+    do_check_true(client.readOnly)
+
+    let items = yield pclient.getAllItems();
+    do_check_eq(items.length, 1);
+    do_check_neq(items[0].title, "New Event");
+    gServer.resetClient(client);
+
+    gServer.calendarListData.accessRole = "reader";
+    let client = yield gServer.getClient();
+    do_check_true(client.readOnly)
+    client.readOnly = false;
+    do_check_true(client.readOnly)
+    gServer.resetClient(client);
+});
+
+add_task(function* test_reset_sync() {
+    gServer.tasks = [
+       {
+        "kind": "tasks#task",
+        "id": "MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo0MDI1NDg2NjU",
+        "etag": "\"Lck7VNWFJuXdzMtOmrYPx0KFV2s/LTIwNjA4MDcyNDM\"",
+        "title": "New Task",
+        "updated": "2014-09-08T16:30:27.000Z",
+        "selfLink": gServer.baseUri + "/tasks/v1/lists/MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDow/tasks/MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo0MDI1NDg2NjU",
+        "position": "00000000000000130998",
+        "status": "needsAction"
+      },{
+        "kind": "tasks#task",
+        "id": "MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo5OTU0Mjk2MzQ",
+        "etag": "\"Lck7VNWFJuXdzMtOmrYPx0KFV2s/LTQyNTY0MjUwOQ\"",
+        "title": "New Task 2",
+        "updated": "2014-09-08T16:30:27.000Z",
+        "selfLink": gServer.baseUri + "/tasks/v1/lists/MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDow/tasks/MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo5OTU0Mjk2MzQ",
+        "position": "00000000000000130993",
+        "status": "needsAction"
+      }
+    ];
+    gServer.events = [{
+       "kind": "calendar#event",
+       "etag": "\"1\"",
+       "id": "go6ijb0b46hlpbu4eeu92njevo",
+       "created": "2006-06-08T21:04:52.000Z",
+       "updated": "2006-06-08T21:05:49.138Z",
+       "summary": "New Event",
+       "creator": gServer.creator,
+       "organizer": gServer.creator,
+       "start": { "dateTime": "2006-06-10T18:00:00+02:00" },
+       "end": {"dateTime": "2006-06-10T20:00:00+02:00" },
+       "iCalUID": "go6ijb0b46hlpbu4eeu92njevo@google.com"
+    },{
+       "kind": "calendar#event",
+       "etag": "\"2\"",
+       "id": "fepf8uf6n7n04w7feukucs9n8e",
+       "created": "2006-06-08T21:04:52.000Z",
+       "updated": "2006-06-08T21:05:49.138Z",
+       "summary": "New Event 2",
+       "creator": gServer.creator,
+       "organizer": gServer.creator,
+       "start": { "dateTime": "2006-06-10T18:00:00+02:00" },
+       "end": {"dateTime": "2006-06-10T20:00:00+02:00" },
+       "iCalUID": "fepf8uf6n7n04w7feukucs9n8e@google.com"
+    }];
+    let client = yield gServer.getClient();
+    let uncached = client.wrappedJSObject.mUncachedCalendar.wrappedJSObject;
+    let pclient = cal.async.promisifyCalendar(client);
+
+    let items = yield pclient.getAllItems();
+    do_check_eq(items.length, 4);
+
+    do_check_neq(client.getProperty("syncToken.events"), "");
+    do_check_neq(client.getProperty("lastUpdated.tasks"), "");
+
+    yield uncached.resetSync();
+    let items = yield pclient.getAllItems();
+    do_check_eq(items.length, 0);
+
+    do_check_eq(client.getProperty("syncToken.events"), "");
+    do_check_eq(client.getProperty("lastUpdated.tasks"), "");
+
+    gServer.resetClient(client);
+});
+
+add_task(function* test_basicItems() {
+    gServer.events = [
+      {
+         "kind": "calendar#event",
+         "etag": "\"2299601498276000\"",
+         "id": "go6ijb0b46hlpbu4eeu92njevo",
+         "status": "confirmed",
+         "htmlLink": gServer.baseUri + "/calendar/event?eid=eventhash",
+         "created": "2006-06-08T21:04:52.000Z",
+         "updated": "2006-06-08T21:05:49.138Z",
+         "summary": "New Event",
+         "description": "description",
+         "location": "Hard Drive",
+         "colorId": 17,
+         "creator": gServer.creator,
+         "organizer": gServer.creator,
+         "start": { "dateTime": "2006-06-10T18:00:00+02:00" },
+         "end": {"dateTime": "2006-06-10T20:00:00+02:00" },
+         "transparency": "transparent",
+         "visibility": "private",
+         "iCalUID": "go6ijb0b46hlpbu4eeu92njevo@google.com",
+         "sequence": 1,
+         "reminders": {
+            "useDefault": false,
+            "overrides": [{
+                "method": "email",
+                "minutes": 20
+             }]
+         },
+         "attendees": [{
+            "displayName": "attendee name",
+            "email": "attendee@example.com",
+            "optional": true,
+            "responseStatus": "tentative"
+        }],
+
+        "extendedProperties": {
+          "shared": {
+            "X-MOZ-CATEGORIES": "foo,bar"
+          },
+          "private": {
+            "X-MOZ-LASTACK": "2014-01-01T01:01:01Z",
+            "X-MOZ-SNOOZE-TIME": "2014-01-01T02:02:02Z"
+          }
+        }
+      }
+    ];
+
+    gServer.tasks = [
+       {
+        "kind": "tasks#task",
+        "id": "MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo0MDI1NDg2NjU",
+        "etag": "\"Lck7VNWFJuXdzMtOmrYPx0KFV2s/LTIwNjA4MDcyNDM\"",
+        "title": "New Task",
+        "updated": "2014-09-08T16:30:27.000Z",
+        "selfLink": gServer.baseUri + "/tasks/v1/lists/MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDow/tasks/MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo0MDI1NDg2NjU",
+        "position": "00000000000000130998",
+        "status": "completed",
+        "due": "2014-09-04T00:00:00.000Z",
+        "completed": "2014-09-01T17:00:00.000Z",
+        "notes": "description",
+        "parent": "MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo4MDIzOTU2NDc",
+        "links": [{
+          "link": "mailto:something@example.com",
+          "description": "link description",
+          "type": "email"
+        }]
+      }
+    ];
+
+    let client = yield gServer.getClient();
+    let pclient = cal.async.promisifyCalendar(client);
+
+    let items = yield pclient.getAllItems();
+    do_check_eq(items.length, 2);
+
+    let event = cal.isEvent(items[0]) ? items[0]: items[1];
+    do_check_eq(event.id, "go6ijb0b46hlpbu4eeu92njevo@google.com");
+    do_check_eq(event.getProperty("STATUS"), "CONFIRMED");
+    do_check_eq(event.getProperty("URL"), gServer.baseUri + "/calendar/event?eid=eventhash");
+    do_check_eq(event.getProperty("CREATED").icalString, "20060608T210452Z");
+    do_check_eq(event.getProperty("LAST-MODIFIED").icalString, "20060608T210549Z");
+    do_check_eq(event.title, "New Event");
+    do_check_eq(event.getProperty("DESCRIPTION"), "description");
+    do_check_eq(event.getProperty("LOCATION"), "Hard Drive");
+    do_check_eq(event.organizer.id, "mailto:xpcshell@example.com");
+    do_check_eq(event.organizer.commonName, "Eggs P. Seashell");
+    do_check_true(event.organizer.isOrganizer);
+    do_check_eq(event.startDate.icalString, "20060610T180000");
+    do_check_eq(event.startDate.timezone.tzid, "Europe/Berlin");
+    do_check_eq(event.endDate.icalString, "20060610T200000");
+    do_check_eq(event.getProperty("TRANSP"), "TRANSPARENT");
+    do_check_eq(event.privacy, "PRIVATE");
+    do_check_eq(event.getProperty("SEQUENCE"), 1);
+    let alarms = event.getAlarms({});
+    do_check_eq(alarms.length, 1);
+    do_check_eq(alarms[0].action, "EMAIL");
+    do_check_eq(alarms[0].related, alarms[0].ALARM_RELATED_START);
+    do_check_eq(alarms[0].offset.icalString, "-PT20M");
+    do_check_null(alarms[0].getProperty("X-DEFAULT-ALARM"));
+    let attendees = event.getAttendees({});
+    do_check_eq(attendees.length, 1);
+    do_check_eq(attendees[0].id, "mailto:attendee@example.com");
+    do_check_eq(attendees[0].commonName, "attendee name");
+    do_check_eq(attendees[0].role, "OPT-PARTICIPANT");
+    do_check_eq(attendees[0].participationStatus, "TENTATIVE");
+    do_check_eq(event.getCategories({}), "foo,bar");
+    do_check_eq(event.alarmLastAck.icalString, "20140101T010101Z");
+    do_check_eq(event.getProperty("X-MOZ-SNOOZE-TIME"), "20140101T020202Z");
+
+    let task = cal.isToDo(items[0]) ? items[0] : items[1];
+    do_check_eq(task.id, "MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo0MDI1NDg2NjU");
+    do_check_eq(task.title, "New Task");
+    do_check_eq(task.getProperty("LAST-MODIFIED").icalString, "20140908T163027Z");
+    do_check_eq(task.getProperty("X-GOOGLE-SORTKEY"), "00000000000000130998");
+    do_check_true(task.isCompleted);
+    do_check_eq(task.dueDate.icalString, "20140904");
+    do_check_eq(task.completedDate.icalString, "20140901T170000Z");
+    do_check_eq(task.getProperty("DESCRIPTION"), "description");
+    let relations = task.getRelations({});
+    do_check_eq(relations.length, 1);
+    do_check_eq(relations[0].relType, "PARENT");
+    do_check_eq(relations[0].relId, "MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo4MDIzOTU2NDc");
+    let attachments = task.getAttachments({});
+    do_check_eq(attachments.length, 1);
+    do_check_eq(attachments[0].uri.spec, "mailto:something@example.com");
+    do_check_eq(attachments[0].getParameter("X-GOOGLE-TYPE"), "email");
+    do_check_eq(attachments[0].getParameter("FILENAME"), "link description");
+
+    gServer.resetClient(client);
+});
+
+add_task(function* test_addModifyDeleteItem() {
+    let client = yield gServer.getClient();
+    let pclient = cal.async.promisifyCalendar(client.wrappedJSObject);
+    do_check_eq(gServer.events.length, 0);
+    do_check_eq(gServer.tasks.length, 0);
+
+    let event = cal.createEvent([
+        "BEGIN:VEVENT",
+        "CREATED:20060608T210452Z",
+        "LAST-MODIFIED:20060608T210549Z",
+        "DTSTAMP:20060608T210549Z",
+        "SUMMARY:New Event",
+        "STATUS:CONFIRMED",
+        "ORGANIZER;CN=Eggs P. Seashell:mailto:xpcshell@example.com",
+        "ATTENDEE;CN=attendee name;PARTSTAT=TENTATIVE;CUTYPE=INDIVIDUAL;ROLE=OPT-PA",
+        " RTICIPANT:mailto:attendee@example.com",
+        "CATEGORIES:foo",
+        "CATEGORIES:bar",
+        "X-MOZ-LASTACK:20140101T010101Z",
+        "DTSTART:20060610T180000Z",
+        "DTEND:20060610T200000Z",
+        "CLASS:PRIVATE",
+        "URL:http://eventlocation",
+        "DESCRIPTION:description",
+        "LOCATION:Hard Drive",
+        "TRANSP:TRANSPARENT",
+        "SEQUENCE:1",
+        "X-MOZ-SNOOZE-TIME:20140101T020202Z",
+        "BEGIN:VALARM",
+        "ACTION:EMAIL",
+        "TRIGGER;VALUE=DURATION:-PT20M",
+        "SUMMARY:Default Mozilla Summary",
+        "DESCRIPTION:Default Mozilla Description",
+        "END:VALARM",
+        "END:VEVENT"
+    ].join("\r\n"));
+
+    let task = cal.createTodo([
+        "BEGIN:VTODO",
+        "SUMMARY:New Task",
+        "DESCRIPTION:description",
+        "X-SORTKEY:00000000000000130998",
+        "STATUS:COMPLETED",
+        "DUE:20140904",
+        "COMPLETED:20140901T170000Z",
+        "RELATED-TO;RELTYPE=PARENT:MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo4MDIzOTU2NDc",
+        "ATTACH;FILENAME=\"link description\";X-GOOGLE-TYPE=email:mailto:something@example.com",
+        "END:VTODO"
+    ].join("\r\n"));
+
+    // Add an event
+    let addedEvent = yield pclient.adoptItem(event);
+    do_check_neq(addedEvent.id, null);
+    do_check_eq(addedEvent.organizer.id, "mailto:xpcshell@example.com");
+
+    let items = yield pclient.getAllItems();
+    do_check_eq(items.length, 1);
+    do_check_eq(items[0].id, addedEvent.id);
+    do_check_eq(items[0].organizer.id, "mailto:xpcshell@example.com");
+
+    do_check_eq(gServer.events.length, 1)
+    do_check_eq(gServer.tasks.length, 0);
+
+    // Add a task
+    let addedTask = yield pclient.adoptItem(task);
+    do_check_neq(addedTask.id, null);
+
+    let items = yield pclient.getAllItems();
+    do_check_eq(items.length, 2);
+    do_check_eq(items[1].id, addedTask.id);
+
+    do_check_eq(gServer.events.length, 1)
+    do_check_eq(gServer.tasks.length, 1);
+
+    // Modify an event
+    let newEvent = items[0].clone();
+    newEvent.title = "changed";
+
+    let modifiedEvent = yield pclient.modifyItem(newEvent, items[0]);
+    do_check_eq(modifiedEvent.title, "changed");
+    do_check_neq(modifiedEvent.getProperty("LAST-MODIFIED"), addedEvent.getProperty("LAST-MODIFIED"));
+    items = yield pclient.getAllItems();
+    do_check_eq(items.length, 2);
+    do_check_eq(items[0].title, "changed");
+    do_check_eq(items[0].id, addedEvent.id);
+    do_check_eq(items[0].getProperty("LAST-MODIFIED"), modifiedEvent.getProperty("LAST-MODIFIED"));
+    do_check_eq(gServer.events.length, 1);
+    do_check_eq(gServer.tasks.length, 1);
+
+    // Modify a task
+    let newTask = items[1].clone();
+    newTask.title = "changed";
+
+    let modifiedTask = yield pclient.modifyItem(newTask, items[1]);
+    do_check_eq(modifiedTask.title, "changed");
+    do_check_neq(modifiedTask.getProperty("LAST-MODIFIED"), addedTask.getProperty("LAST-MODIFIED"));
+    items = yield pclient.getAllItems();
+    do_check_eq(items.length, 2);
+    do_check_eq(items[1].title, "changed");
+    do_check_eq(items[1].id, addedTask.id);
+    do_check_eq(items[1].getProperty("LAST-MODIFIED"), modifiedTask.getProperty("LAST-MODIFIED"));
+    do_check_eq(gServer.events.length, 1);
+    do_check_eq(gServer.tasks.length, 1);
+
+    // Delete an event
+    yield pclient.deleteItem(modifiedEvent);
+    items = yield pclient.getAllItems();
+    do_check_eq(items.length, 1);
+    do_check_eq(gServer.events.length, 0);
+    do_check_eq(gServer.tasks.length, 1);
+
+    // Delete a task
+    yield pclient.deleteItem(modifiedTask);
+    items = yield pclient.getAllItems();
+    do_check_eq(items.length, 0);
+    do_check_eq(gServer.events.length, 0);
+    do_check_eq(gServer.tasks.length, 0);
+
+    gServer.resetClient(client);
+});
+
+add_task(function* test_recurring_event() {
+    let client = yield gServer.getClient();
+    let pclient = cal.async.promisifyCalendar(client.wrappedJSObject);
+
+    let event = cal.createEvent([
+        "BEGIN:VEVENT",
+        "SUMMARY:Recurring Event",
+        "DTSTART:20060610T180000Z",
+        "DTEND:20060610T200000Z",
+        "RRULE:FREQ=WEEKLY",
+        "END:VEVENT"
+    ].join("\r\n"));
+
+    event = yield pclient.addItem(event);
+    do_check_eq(gServer.events.length, 1);
+    do_check_eq(gServer.events[0].recurrence.length, 1);
+    do_check_eq(gServer.events[0].recurrence[0], "RRULE:FREQ=WEEKLY");
+
+    let occ = event.recurrenceInfo.getNextOccurrence(event.startDate);
+    let changedOcc = occ.clone();
+    changedOcc.title = "changed";
+    event.recurrenceInfo.modifyException(occ, true);
+
+    event = yield pclient.modifyItem(changedOcc, occ);
+    occ = event.recurrenceInfo.getNextOccurrence(event.startDate);
+    do_check_eq(occ.title, "changed");
+    do_check_eq(gServer.events.length, 2);
+
+    gServer.resetClient(client);
+});
+
+add_task(function* test_import_invitation() {
+    Preferences.set("calendar.google.enableAttendees", true);
+    let client = yield gServer.getClient();
+    let pclient = cal.async.promisifyCalendar(client.wrappedJSObject);
+    let event = cal.createEvent([
+        "BEGIN:VEVENT",
+        "UID:xpcshell-import",
+        "CREATED:20060608T210452Z",
+        "LAST-MODIFIED:20060608T210549Z",
+        "DTSTAMP:20060608T210549Z",
+        "SUMMARY:New Event",
+        "STATUS:CONFIRMED",
+        "ORGANIZER;CN=Omlettte B. Clam:mailto:ombclam@example.com",
+        "ATTENDEE;CN=Omlettte B. Clam;PARTSTAT=ACCEPTED;CUTYPE=INDIVIDUAL;",
+        " ROLE=REQ-PARTICIPANT:mailto:ombclam@example.com",
+        "ATTENDEE;CN=Eggs P. Seashell;PARTSTAT=TENTATIVE;CUTYPE=INDIVIDUAL;",
+        " ROLE=REQ-PARTICIPANT:mailto:xpcshell@example.com",
+        "DTSTART:20060610T180000Z",
+        "DTEND:20060610T200000Z",
+        "SEQUENCE:1",
+        "END:VEVENT"
+    ].join("\r\n"));
+
+    let addedItem = yield pclient.adoptItem(event);
+    do_check_eq(gServer.events.length, 1);
+    do_check_eq(addedItem.icalString, event.icalString);
+    gServer.resetClient(client);
+    Preferences.set("calendar.google.enableAttendees", false);
+});
+
+add_task(function* test_metadata() {
+    gServer.events = [{
+        "kind": "calendar#event",
+        "etag": "\"1\"",
+        "id": "go6ijb0b46hlpbu4eeu92njevo",
+        "created": "2006-06-08T21:04:52.000Z",
+        "updated": "2006-06-08T21:05:49.138Z",
+        "summary": "New Event",
+        "creator": gServer.creator,
+        "organizer": gServer.creator,
+        "start": { "dateTime": "2006-06-10T18:00:00+02:00" },
+        "end": {"dateTime": "2006-06-10T20:00:00+02:00" },
+        "iCalUID": "go6ijb0b46hlpbu4eeu92njevo@google.com"
+    }];
+    gServer.tasks = [{
+        "kind": "tasks#task",
+        "id": "MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo0MDI1NDg2NjU",
+        "etag": "\"2\"",
+        "title": "New Task",
+        "updated": "2014-09-08T16:30:27.000Z",
+        "selfLink": gServer.baseUri + "/tasks/v1/lists/MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDow/tasks/MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo0MDI1NDg2NjU",
+        "notes": "description"
+    }];
+
+    let idToEtag = {
+        "go6ijb0b46hlpbu4eeu92njevo@google.com": '"1"',
+        "MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo0MDI1NDg2NjU": '"2"'
+    }
+
+    let client = yield gServer.getClient();
+    let offline = client.wrappedJSObject.mCachedCalendar;
+    let pclient = cal.async.promisifyCalendar(client.wrappedJSObject);
+
+    // Check initial metadata
+    let items = yield pclient.getAllItems();
+    let meta = getAllMeta(offline);
+    let [event, task] = items;
+    do_check_true(cal.isEvent(event));
+    do_check_true(cal.isToDo(task));
+    do_check_eq(meta.size, 2);
+    do_check_eq(meta.get(event.hashId), ['"1"', "go6ijb0b46hlpbu4eeu92njevo", false].join("\u001A"));
+    do_check_eq(meta.get(task.hashId), ['"2"', "MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo0MDI1NDg2NjU", false].join("\u001A"));
+
+    // Modify an event
+    gServer.nextEtag = '"3"';
+    let newEvent = event.clone();
+    newEvent.title = "changed";
+    yield pclient.modifyItem(newEvent, event);
+
+    items = yield pclient.getAllItems();
+    meta = getAllMeta(offline);
+    [event, task] = items;
+    do_check_true(cal.isEvent(event));
+    do_check_true(cal.isToDo(task));
+    do_check_eq(meta.size, 2);
+    do_check_eq(meta.get(event.hashId), ['"3"', "go6ijb0b46hlpbu4eeu92njevo", false].join("\u001A"));
+    do_check_eq(meta.get(task.hashId), ['"2"', "MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo0MDI1NDg2NjU", false].join("\u001A"));
+
+    // Modify a task
+    gServer.nextEtag = '"4"';
+    let newTask = task.clone();
+    newTask.title = "changed";
+    yield pclient.modifyItem(newTask, task);
+
+    items = yield pclient.getAllItems();
+    meta = getAllMeta(offline);
+    [event, task] = items;
+    do_check_eq(meta.size, 2);
+    do_check_eq(meta.get(event.hashId), ['"3"', "go6ijb0b46hlpbu4eeu92njevo", false].join("\u001A"));
+    do_check_eq(meta.get(task.hashId), ['"4"', "MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo0MDI1NDg2NjU", false].join("\u001A"));
+
+    // Delete an event
+    yield pclient.deleteItem(event);
+    meta = getAllMeta(offline);
+    do_check_eq(meta.size, 1);
+    do_check_eq(meta.get(task.hashId), ['"4"', "MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo0MDI1NDg2NjU", false].join("\u001A"));
+
+    // Delete a task
+    yield pclient.deleteItem(task);
+    meta = getAllMeta(offline);
+    do_check_eq(meta.size, 0);
+
+    // Add an event
+    gServer.nextEtag = '"6"';
+    newEvent = yield pclient.addItem(event);
+    meta = getAllMeta(offline);
+    do_check_eq(meta.size, 1);
+    do_check_eq(gServer.events.length, 1);
+    do_check_eq(meta.get(newEvent.hashId), ['"6"', gServer.events[0].id, false].join("\u001A"));
+
+    // Add a task
+    gServer.nextEtag = '"7"';
+    newTask = yield pclient.addItem(task);
+    meta = getAllMeta(offline);
+    do_check_eq(meta.size, 2);
+    do_check_eq(gServer.events.length, 1);
+    do_check_eq(gServer.tasks.length, 1);
+    do_check_eq(meta.get(newEvent.hashId), ['"6"', gServer.events[0].id, false].join("\u001A"));
+    do_check_eq(meta.get(newTask.hashId), ['"7"', gServer.tasks[0].id, false].join("\u001A"));
+
+    gServer.resetClient(client);
+});
+
+add_task(function* test_metadata_recurring() {
+    gServer.events = [{
+        "kind": "calendar#event",
+        "etag": "\"1\"",
+        "id": "go6ijb0b46hlpbu4eeu92njevo",
+        "created": "2006-06-08T21:04:52.000Z",
+        "updated": "2006-06-08T21:05:49.138Z",
+        "summary": "New Event",
+        "creator": gServer.creator,
+        "organizer": gServer.creator,
+        "start": { "dateTime": "2006-06-10T18:00:00+02:00" },
+        "end": {"dateTime": "2006-06-10T20:00:00+02:00" },
+        "iCalUID": "go6ijb0b46hlpbu4eeu92njevo@google.com",
+        "recurrence": [
+            "RRULE:FREQ=WEEKLY"
+        ]
+    },{
+        "kind": "calendar#event",
+        "etag": "\"2\"",
+        "id": "go6ijb0b46hlpbu4eeu92njevo_20060610T160000Z",
+        "summary": "New Event changed",
+        "start": { "dateTime": "2006-06-10T18:00:00+02:00" },
+        "end": {"dateTime": "2006-06-10T20:00:00+02:00" },
+        "recurringEventId": "go6ijb0b46hlpbu4eeu92njevo",
+        "originalStartTime": { "dateTime": "2006-06-10T18:00:00+02:00" }
+    },{
+        "kind": "calendar#event",
+        "etag": "\"3\"",
+        "id": "go6ijb0b46hlpbu4eeu92njevo_20060610T160000Z",
+        "summary": "New Event next week",
+        "start": { "dateTime": "2006-06-17T18:00:00+02:00" },
+        "end": {"dateTime": "2006-06-17T20:00:00+02:00" },
+        "recurringEventId": "go6ijb0b46hlpbu4eeu92njevo",
+        "originalStartTime": { "dateTime": "2006-06-17T18:00:00+02:00" }
+    }];
+
+    let client = yield gServer.getClient();
+    let offline = client.wrappedJSObject.mCachedCalendar;
+    let pclient = cal.async.promisifyCalendar(client.wrappedJSObject);
+    let items = yield pclient.getAllItems();
+
+    let meta = getAllMeta(offline);
+    do_check_eq(meta.size, 3);
+    do_check_eq(meta.get(items[0].hashId), ['"1"', "go6ijb0b46hlpbu4eeu92njevo", false].join("\u001A"));
+
+    // The exception metadata should also exist
+    let exIds = items[0].recurrenceInfo.getExceptionIds({});
+    do_check_eq(exIds.length, 2);
+    let ex = items[0].recurrenceInfo.getExceptionFor(exIds[0]);
+    do_check_eq(meta.get(ex.hashId), ['"2"', "go6ijb0b46hlpbu4eeu92njevo_20060610T160000Z", false].join("\u001A"));
+
+    // Changing an exception should retain the metadata entries
+    let newEx = ex.clone();
+    newEx.title = "New Event changed again";
+    gServer.nextEtag = '"4"';
+    yield pclient.modifyItem(newEx, ex);
+    let meta = getAllMeta(offline);
+    do_check_eq(meta.size, 3);
+    do_check_eq(meta.get(newEx.hashId), ['"4"', "go6ijb0b46hlpbu4eeu92njevo_20060610T160000Z", false].join("\u001A"));
+
+    // Deleting an exception should delete the metadata, as it turns into an EXDATE
+    let newItem = items[0].clone();
+    newItem.recurrenceInfo.removeOccurrenceAt(exIds[0]);
+    yield pclient.modifyItem(newItem, items[0]);
+
+    let meta = getAllMeta(offline);
+    do_check_eq(meta.size, 2);
+
+    // Deleting the master item should remove all metadata entries
+    yield pclient.deleteItem(items[0]);
+    let meta = getAllMeta(offline);
+    do_check_eq(meta.size, 0);
+
+    gServer.resetClient(client);
+});
+
+add_task(function* test_conflict_modify() {
+    // TODO task/event conflicts are handled in the same way so I'm going to
+    // skip adding tests for tasks here, but it probably wouldn't hurt to
+    // create them at some point.
+    gServer.events = [{
+       "kind": "calendar#event",
+       "etag": "\"1\"",
+       "id": "go6ijb0b46hlpbu4eeu92njevo",
+       "created": "2006-06-08T21:04:52.000Z",
+       "updated": "2006-06-08T21:05:49.138Z",
+       "summary": "New Event",
+       "creator": gServer.creator,
+       "organizer": gServer.creator,
+       "start": { "dateTime": "2006-06-10T18:00:00+02:00" },
+       "end": {"dateTime": "2006-06-10T20:00:00+02:00" },
+       "iCalUID": "go6ijb0b46hlpbu4eeu92njevo@google.com"
+    }];
+    let client = yield gServer.getClient();
+    let pclient = cal.async.promisifyCalendar(client.wrappedJSObject);
+    let item = (yield pclient.getAllItems())[0];
+
+    // Case #1: Modified on server, modify locally, overwrite conflict
+    MockConflictPrompt.overwrite = true;
+    let newItem = item.clone();
+    newItem.title = "local change";
+    gServer.events[0].etag = '"2"';
+    gServer.events[0].summary = "remote change";
+    let modifiedItem = yield pclient.modifyItem(newItem, item);
+    item = (yield pclient.getAllItems())[0];
+    do_check_eq(gServer.events[0].summary, "local change");
+    do_check_neq(gServer.events[0].etag, '"2"')
+    do_check_eq(item.title, "local change");
+    do_check_eq(modifiedItem.title, "local change");
+    do_check_eq(gServer.events.length, 1);
+
+    // Case #2: Modified on server, modify locally, don't overwrite conflict
+    MockConflictPrompt.overwrite = false;
+    gServer.events[0].etag = '"3"';
+    gServer.events[0].summary = "remote change";
+    try {
+        modifiedItem = yield pclient.modifyItem(newItem, item);
+        do_throw("Expected modifyItem to be cancelled");
+    } catch (e if e == Components.interfaces.calIErrors.OPERATION_CANCELLED) {
+        // Swallow cancelling the request
+    }
+
+    yield gServer.waitForLoad(client);
+
+    item = (yield pclient.getAllItems())[0];
+    do_check_eq(gServer.events[0].summary, "remote change");
+    do_check_eq(gServer.events[0].etag, '"3"')
+    do_check_eq(item.title, "remote change");
+
+    // Case #3: Modified on server, delete locally, don't overwrite conflict
+    MockConflictPrompt.overwrite = false;
+    gServer.events[0].etag = '"4"';
+    gServer.events[0].summary = "remote change";
+    try {
+        yield pclient.deleteItem(item);
+        do_throw("Expected deleteItem to be cancelled");
+    } catch (e if e == Components.interfaces.calIErrors.OPERATION_CANCELLED) {
+        // Swallow cancelling the request
+    }
+
+    yield gServer.waitForLoad(client);
+
+    item = (yield pclient.getAllItems())[0];
+    do_check_eq(gServer.events[0].summary, "remote change");
+    do_check_eq(gServer.events[0].etag, '"4"')
+    do_check_eq(item.title, "remote change");
+
+    // Case #4: Modified on server, delete locally, overwrite conflict
+    MockConflictPrompt.overwrite = true;
+    gServer.events[0].etag = '"5"';
+    gServer.events[0].summary = "remote change";
+    yield pclient.deleteItem(item);
+    item = (yield pclient.getAllItems())[0];
+    do_check_eq(gServer.events.length, 0);
+
+    gServer.resetClient(client);
+});
+
+add_task(function* test_conflict_delete() {
+    // TODO task/event conflicts are handled in the same way so I'm going to
+    // skip adding tests for tasks here, but it probably wouldn't hurt to
+    // create them at some point.
+    let coreEvent = {
+       "kind": "calendar#event",
+       "etag": "\"2\"",
+       "id": "go6ijb0b46hlpbu4eeu92njevo",
+       "created": "2006-06-08T21:04:52.000Z",
+       "updated": "2006-06-08T21:05:49.138Z",
+       "summary": "New Event",
+       "creator": gServer.creator,
+       "organizer": gServer.creator,
+       "start": { "dateTime": "2006-06-10T18:00:00+02:00" },
+       "end": {"dateTime": "2006-06-10T20:00:00+02:00" },
+       "iCalUID": "go6ijb0b46hlpbu4eeu92njevo@google.com"
+    };
+
+    // Load intial event to server
+    gServer.events = [coreEvent];
+    let client = yield gServer.getClient();
+    let pclient = cal.async.promisifyCalendar(client.wrappedJSObject);
+    let item = (yield pclient.getAllItems())[0];
+
+    // Case #1: Deleted on server, modify locally, overwrite conflict
+    MockConflictPrompt.overwrite = true;
+    gServer.events = [];
+    let newItem = item.clone();
+    newItem.title = "local change";
+    let modifiedItem = yield pclient.modifyItem(newItem, item);
+    item = (yield pclient.getAllItems())[0];
+    do_check_eq(gServer.events[0].summary, "local change");
+    do_check_neq(gServer.events[0].etag, '"2"')
+    do_check_eq(item.title, "local change");
+    do_check_eq(modifiedItem.title, "local change");
+    do_check_eq(gServer.events.length, 1);
+
+    // Case #2: Deleted on server, modify locally, don't overwrite conflict
+    MockConflictPrompt.overwrite = false;
+    gServer.events = [];
+    try {
+        modifiedItem = yield pclient.modifyItem(newItem, item);
+        do_throw("Expected modifyItem to be cancelled");
+    } catch (e if e == Components.interfaces.calIErrors.OPERATION_CANCELLED) {
+        // Swallow cancelling the request
+    }
+    // The next synchronize should cause the event to be deleted locally.
+    coreEvent.status = "cancelled";
+    gServer.events = [coreEvent];
+
+    yield gServer.waitForLoad(client);
+
+    let items = yield pclient.getAllItems();
+    do_check_eq(items.length, 0);
+    do_check_eq(gServer.events.length, 1);
+
+    // Put the event back in the calendar for the next run
+    delete gServer.events[0].status;
+    client.refresh();
+    yield gServer.waitForLoad(client);
+    items = yield pclient.getAllItems();
+    do_check_eq(items.length, 1);
+
+    // Case #3: Deleted on server, delete locally, don't overwrite conflict
+    MockConflictPrompt.overwrite = false;
+    gServer.events = [];
+    try {
+        yield pclient.deleteItem(item);
+        do_throw("Expected deleteItem to be cancelled");
+    } catch (e if e == Components.interfaces.calIErrors.OPERATION_CANCELLED) {
+        // Swallow cancelling the request
+    }
+    // The next synchronize should cause the event to be deleted locally.
+    coreEvent.status = "cancelled";
+    gServer.events = [coreEvent];
+    yield gServer.waitForLoad(client);
+
+    items = yield pclient.getAllItems();
+    do_check_eq(items.length, 0);
+
+    // Put the event back in the calendar for the next run
+    delete gServer.events[0].status;
+    client.refresh();
+    yield gServer.waitForLoad(client);
+    items = yield pclient.getAllItems();
+    do_check_eq(items.length, 1);
+
+    // Case #4: Deleted on server, delete locally, overwrite conflict
+    MockConflictPrompt.overwrite = true;
+    gServer.events = [];
+    yield pclient.deleteItem(item);
+    items = yield pclient.getAllItems();
+    do_check_eq(items.length, 0);
+
+    gServer.resetClient(client);
+});
+
+add_task(function* test_default_alarms() {
+    let defaultReminders = [
+        { method: "popup", minutes: 10 },
+        { method: "email", minutes: 20 },
+    ];
+    gServer.calendarListData.defaultReminders = defaultReminders;
+    gServer.eventsData.defaultReminders = defaultReminders;
+    gServer.events = [{
+       "kind": "calendar#event",
+       "etag": "\"2\"",
+       "id": "go6ijb0b46hlpbu4eeu92njevo",
+       "created": "2006-06-08T21:04:52.000Z",
+       "updated": "2006-06-08T21:05:49.138Z",
+       "summary": "Default Reminder",
+       "creator": gServer.creator,
+       "organizer": gServer.creator,
+       "start": { "dateTime": "2006-06-10T18:00:00+02:00" },
+       "end": {"dateTime": "2006-06-10T20:00:00+02:00" },
+       "iCalUID": "go6ijb0b46hlpbu4eeu92njevo@google.com",
+       "reminders": { "useDefault": true }
+    }];
+
+    // Case #1: read default alarms from event stream
+    let client = yield gServer.getClient();
+    let pclient = cal.async.promisifyCalendar(client.wrappedJSObject);
+    do_check_eq(client.getProperty("settings.defaultReminders"), JSON.stringify(defaultReminders));
+
+    let item = (yield pclient.getAllItems())[0];
+    let alarms = item.getAlarms({});
+
+    do_check_eq(alarms.length, 2);
+    do_check_true(alarms.every(x => x.getProperty("X-DEFAULT-ALARM") == "TRUE"));
+    do_check_eq(alarms[0].action, "DISPLAY");
+    do_check_eq(alarms[0].offset.icalString, "-PT10M");
+    do_check_eq(alarms[1].action, "EMAIL");
+    do_check_eq(alarms[1].offset.icalString, "-PT20M");
+
+    // Case #2: add an item with only default alarms
+    let event = cal.createEvent([
+        "BEGIN:VEVENT",
+        "SUMMARY:Default Alarms",
+        "DTSTART:20060610T180000Z",
+        "DTEND:20060610T200000Z",
+        "BEGIN:VALARM",
+        "X-DEFAULT-ALARM:TRUE",
+        "ACTION:DISPLAY",
+        "TRIGGER;VALUE=DURATION:PT0S",
+        "DESCRIPTION:Description",
+        "END:VALARM",
+        "END:VEVENT"
+    ].join("\r\n"));
+
+    yield pclient.addItem(event);
+    do_check_true(gServer.events[1].reminders.useDefault);
+    do_check_eq(gServer.events[1].reminders.overrides.length, 0);
+
+    // Case #3: Mixed default/non-default alarms. Not sure this will happen
+    let event = cal.createEvent([
+        "BEGIN:VEVENT",
+        "SUMMARY:Default Alarms",
+        "DTSTART:20060610T180000Z",
+        "DTEND:20060610T200000Z",
+        "BEGIN:VALARM",
+        "ACTION:DISPLAY",
+        "X-DEFAULT-ALARM:TRUE",
+        "TRIGGER;VALUE=DURATION:-PT1M",
+        "DESCRIPTION:Description",
+        "END:VALARM",
+        "BEGIN:VALARM",
+        "ACTION:DISPLAY",
+        "TRIGGER;VALUE=DURATION:-PT5M",
+        "DESCRIPTION:Description",
+        "END:VALARM",
+        "END:VEVENT"
+    ].join("\r\n"));
+
+    yield pclient.addItem(event);
+    do_check_true(gServer.events[2].reminders.useDefault);
+    do_check_eq(gServer.events[2].reminders.overrides.length, 1);
+    do_check_eq(gServer.events[2].reminders.overrides[0].minutes, 5);
+
+    gServer.resetClient(client);
+});
+
+add_task(function* test_paginate() {
+    gServer.events = [{
+       "kind": "calendar#event",
+       "etag": "\"1\"",
+       "id": "go6ijb0b46hlpbu4eeu92njevo",
+       "created": "2006-06-08T21:04:52.000Z",
+       "updated": "2006-06-08T21:05:49.138Z",
+       "summary": "New Event",
+       "creator": gServer.creator,
+       "organizer": gServer.creator,
+       "start": { "dateTime": "2006-06-10T18:00:00+02:00" },
+       "end": {"dateTime": "2006-06-10T20:00:00+02:00" },
+       "iCalUID": "go6ijb0b46hlpbu4eeu92njevo@google.com"
+    },{
+       "kind": "calendar#event",
+       "etag": "\"2\"",
+       "id": "fepf8uf6n7n04w7feukucs9n8e",
+       "created": "2006-06-08T21:04:52.000Z",
+       "updated": "2006-06-08T21:05:49.138Z",
+       "summary": "New Event 2",
+       "creator": gServer.creator,
+       "organizer": gServer.creator,
+       "start": { "dateTime": "2006-06-10T18:00:00+02:00" },
+       "end": {"dateTime": "2006-06-10T20:00:00+02:00" },
+       "iCalUID": "fepf8uf6n7n04w7feukucs9n8e@google.com"
+    }];
+
+    gServer.tasks = [
+       {
+        "kind": "tasks#task",
+        "id": "MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo0MDI1NDg2NjU",
+        "etag": "\"Lck7VNWFJuXdzMtOmrYPx0KFV2s/LTIwNjA4MDcyNDM\"",
+        "title": "New Task",
+        "updated": "2014-09-08T16:30:27.000Z",
+        "selfLink": gServer.baseUri + "/tasks/v1/lists/MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDow/tasks/MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo0MDI1NDg2NjU",
+        "position": "00000000000000130998",
+        "status": "needsAction"
+      },{
+        "kind": "tasks#task",
+        "id": "MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo5OTU0Mjk2MzQ",
+        "etag": "\"Lck7VNWFJuXdzMtOmrYPx0KFV2s/LTQyNTY0MjUwOQ\"",
+        "title": "New Task 2",
+        "updated": "2014-09-08T16:30:27.000Z",
+        "selfLink": gServer.baseUri + "/tasks/v1/lists/MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDow/tasks/MTEyMDE2MDE5NzE0NjYzMDk4ODI6MDo5OTU0Mjk2MzQ",
+        "position": "00000000000000130993",
+        "status": "needsAction"
+      }
+    ];
+
+    Preferences.set("calendar.google.maxResultsPerRequest", 1);
+
+    let client = yield gServer.getClient();
+    let pclient = cal.async.promisifyCalendar(client);
+
+    // Make sure all pages were requested
+    do_check_eq(gServer.eventsData.nextPageToken, null);
+    do_check_eq(gServer.tasksData.nextPageToken, null);
+
+    // ...and we have all items. Not checking props
+    // because the other tests do this sufficiently.
+    let items = yield pclient.getAllItems();
+    do_check_eq(items.length, 4);
+
+    do_check_eq(client.getProperty("syncToken.events"), "next-sync-token");
+
+    Preferences.reset("calendar.google.maxResultsPerRequest");
+    gServer.resetClient(client);
+});
+
+add_task(function* test_incremental_reset() {
+    gServer.syncs = [{
+        token: "1",
+        events: [{
+            "kind": "calendar#event",
+            "etag": "\"1\"",
+            "id": "go6ijb0b46hlpbu4eeu92njevo",
+            "created": "2006-06-08T21:04:52.000Z",
+            "updated": "2006-06-08T21:05:49.138Z",
+            "summary": "New Event",
+            "creator": gServer.creator,
+            "organizer": gServer.creator,
+            "start": { "dateTime": "2006-06-10T18:00:00+02:00" },
+            "end": {"dateTime": "2006-06-10T20:00:00+02:00" },
+            "iCalUID": "go6ijb0b46hlpbu4eeu92njevo@google.com"
+        }]
+    },{
+        token: "2",
+        reset: true
+    },{
+        token: "3",
+        events: [{
+            "kind": "calendar#event",
+            "etag": "\"2\"",
+            "id": "fepf8uf6n7n04w7feukucs9n8e",
+            "created": "2006-06-08T21:04:52.000Z",
+            "updated": "2006-06-08T21:05:49.138Z",
+            "summary": "New Event 2",
+            "creator": gServer.creator,
+            "organizer": gServer.creator,
+            "start": { "dateTime": "2006-06-10T18:00:00+02:00" },
+            "end": {"dateTime": "2006-06-10T20:00:00+02:00" },
+            "iCalUID": "fepf8uf6n7n04w7feukucs9n8e@google.com"
+        }]
+    }];
+    let client = yield gServer.getClient();
+    let pclient = cal.async.promisifyCalendar(client);
+
+    let items = yield pclient.getAllItems();
+    do_check_eq(items.length, 1);
+    do_check_eq(items[0].title, "New Event");
+
+    client.refresh();
+    yield gServer.waitForLoad(client);
+
+    items = yield pclient.getAllItems();
+    do_check_eq(items.length, 1);
+    do_check_eq(items[0].title, "New Event 2");
+
+    do_check_eq(gServer.syncs.length, 0);
+    do_check_eq(client.getProperty("syncToken.events"), "last");
+
+    gServer.resetClient(client);
+});
diff --git a/calendar/test/unit/xpcshell.ini b/calendar/test/unit/xpcshell.ini
index 70e4303..3e75f80 100644
--- a/calendar/test/unit/xpcshell.ini
+++ b/calendar/test/unit/xpcshell.ini
@@ -23,6 +23,7 @@ run-sequentially = Avoid bustage.
 [test_duration.js]
 [test_freebusy.js]
 [test_freebusy_service.js]
+[test_gdata_provider.js]
 [test_hashedarray.js]
 [test_ics.js]
 [test_ics_parser.js]
